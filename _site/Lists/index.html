<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lists: Lists and higher-order functions | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Lists: Lists and higher-order functions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://roger-uw.github.io/PLFA-zh/Lists/" />
<meta property="og:url" content="https://roger-uw.github.io/PLFA-zh/Lists/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://roger-uw.github.io/PLFA-zh/Lists/","headline":"Lists: Lists and higher-order functions","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">目录</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Lists: Lists and higher-order functions</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Decidable/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Lists.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Lambda/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="159" class="Keyword">module</a> <a id="166" href="/PLFA-zh/Lists/" class="Module">plfa.Lists</a> <a id="177" class="Keyword">where</a></pre>

<p>This chapter discusses the list data type.  It gives further examples
of many of the techniques we have developed so far, and provides
examples of polymorphic types and higher-order functions.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="414" class="Keyword">import</a> <a id="421" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="459" class="Symbol">as</a> <a id="462" class="Module">Eq</a>
<a id="465" class="Keyword">open</a> <a id="470" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="473" class="Keyword">using</a> <a id="479" class="Symbol">(</a><a id="480" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="483" class="Symbol">;</a> <a id="485" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="489" class="Symbol">;</a> <a id="491" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="494" class="Symbol">;</a> <a id="496" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a><a id="501" class="Symbol">;</a> <a id="503" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="507" class="Symbol">)</a>
<a id="509" class="Keyword">open</a> <a id="514" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#3975" class="Module">Eq.≡-Reasoning</a>
<a id="529" class="Keyword">open</a> <a id="534" class="Keyword">import</a> <a id="541" href="https://agda.github.io/agda-stdlib/Data.Bool.html" class="Module">Data.Bool</a> <a id="551" class="Keyword">using</a> <a id="557" class="Symbol">(</a><a id="558" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a><a id="562" class="Symbol">;</a> <a id="564" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#92" class="InductiveConstructor">true</a><a id="568" class="Symbol">;</a> <a id="570" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#86" class="InductiveConstructor">false</a><a id="575" class="Symbol">;</a> <a id="577" href="https://agda.github.io/agda-stdlib/Data.Bool.Base.html#864" class="Function">T</a><a id="578" class="Symbol">;</a> <a id="580" href="https://agda.github.io/agda-stdlib/Data.Bool.Base.html#1012" class="Function Operator">_∧_</a><a id="583" class="Symbol">;</a> <a id="585" href="https://agda.github.io/agda-stdlib/Data.Bool.Base.html#1070" class="Function Operator">_∨_</a><a id="588" class="Symbol">;</a> <a id="590" href="https://agda.github.io/agda-stdlib/Data.Bool.Base.html#730" class="Function">not</a><a id="593" class="Symbol">)</a>
<a id="595" class="Keyword">open</a> <a id="600" class="Keyword">import</a> <a id="607" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="616" class="Keyword">using</a> <a id="622" class="Symbol">(</a><a id="623" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="624" class="Symbol">;</a> <a id="626" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="630" class="Symbol">;</a> <a id="632" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="635" class="Symbol">;</a> <a id="637" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="640" class="Symbol">;</a> <a id="642" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a><a id="645" class="Symbol">;</a> <a id="647" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#320" class="Primitive Operator">_∸_</a><a id="650" class="Symbol">;</a> <a id="652" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#845" class="Datatype Operator">_≤_</a><a id="655" class="Symbol">;</a> <a id="657" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a><a id="660" class="Symbol">;</a> <a id="662" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a><a id="665" class="Symbol">)</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="699" class="Keyword">using</a>
  <a id="707" class="Symbol">(</a><a id="708" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9375" class="Function">+-assoc</a><a id="715" class="Symbol">;</a> <a id="717" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9476" class="Function">+-identityˡ</a><a id="728" class="Symbol">;</a> <a id="730" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9531" class="Function">+-identityʳ</a><a id="741" class="Symbol">;</a> <a id="743" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#15493" class="Function">*-assoc</a><a id="750" class="Symbol">;</a> <a id="752" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#14397" class="Function">*-identityˡ</a><a id="763" class="Symbol">;</a> <a id="765" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#14461" class="Function">*-identityʳ</a><a id="776" class="Symbol">)</a>
<a id="778" class="Keyword">open</a> <a id="783" class="Keyword">import</a> <a id="790" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="807" class="Keyword">using</a> <a id="813" class="Symbol">(</a><a id="814" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="816" class="Symbol">;</a> <a id="818" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="821" class="Symbol">;</a> <a id="823" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="826" class="Symbol">;</a> <a id="828" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="830" class="Symbol">)</a>
<a id="832" class="Keyword">open</a> <a id="837" class="Keyword">import</a> <a id="844" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="857" class="Keyword">using</a> <a id="863" class="Symbol">(</a><a id="864" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">_×_</a><a id="867" class="Symbol">;</a> <a id="869" href="https://agda.github.io/agda-stdlib/Data.Product.html#881" class="Function">∃</a><a id="870" class="Symbol">;</a> <a id="872" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃-syntax</a><a id="880" class="Symbol">)</a> <a id="882" class="Keyword">renaming</a> <a id="891" class="Symbol">(</a><a id="892" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="896" class="Symbol">to</a> <a id="899" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="904" class="Symbol">)</a>
<a id="906" class="Keyword">open</a> <a id="911" class="Keyword">import</a> <a id="918" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="927" class="Keyword">using</a> <a id="933" class="Symbol">(</a><a id="934" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">_∘_</a><a id="937" class="Symbol">)</a>
<a id="939" class="Keyword">open</a> <a id="944" class="Keyword">import</a> <a id="951" href="https://agda.github.io/agda-stdlib/Level.html" class="Module">Level</a> <a id="957" class="Keyword">using</a> <a id="963" class="Symbol">(</a><a id="964" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#408" class="Postulate">Level</a><a id="969" class="Symbol">)</a>
<a id="971" class="Keyword">open</a> <a id="976" class="Keyword">import</a> <a id="983" href="/PLFA-zh/Isomorphism/" class="Module">plfa.Isomorphism</a> <a id="1000" class="Keyword">using</a> <a id="1006" class="Symbol">(</a><a id="1007" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">_≃_</a><a id="1010" class="Symbol">;</a> <a id="1012" href="/PLFA-zh/Isomorphism/#15055" class="Record Operator">_⇔_</a><a id="1015" class="Symbol">)</a></pre>

<h2 id="lists">Lists</h2>

<p>Lists are defined in Agda as follows:</p>
<pre class="Agda"><a id="1091" class="Keyword">data</a> <a id="List"></a><a id="1096" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="1101" class="Symbol">(</a><a id="1102" href="/PLFA-zh/Lists/#1102" class="Bound">A</a> <a id="1104" class="Symbol">:</a> <a id="1106" class="PrimitiveType">Set</a><a id="1109" class="Symbol">)</a> <a id="1111" class="Symbol">:</a> <a id="1113" class="PrimitiveType">Set</a> <a id="1117" class="Keyword">where</a>
  <a id="List.[]"></a><a id="1125" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>  <a id="1129" class="Symbol">:</a> <a id="1131" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="1136" href="/PLFA-zh/Lists/#1102" class="Bound">A</a>
  <a id="List._∷_"></a><a id="1140" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">_∷_</a> <a id="1144" class="Symbol">:</a> <a id="1146" href="/PLFA-zh/Lists/#1102" class="Bound">A</a> <a id="1148" class="Symbol">→</a> <a id="1150" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="1155" href="/PLFA-zh/Lists/#1102" class="Bound">A</a> <a id="1157" class="Symbol">→</a> <a id="1159" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="1164" href="/PLFA-zh/Lists/#1102" class="Bound">A</a>

<a id="1167" class="Keyword">infixr</a> <a id="1174" class="Number">5</a> <a id="1176" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">_∷_</a></pre>
<p>Let’s unpack this definition. If <code class="highlighter-rouge">A</code> is a set, then <code class="highlighter-rouge">List A</code> is a set.
The next two lines tell us that <code class="highlighter-rouge">[]</code> (pronounced <em>nil</em>) is a list of
type <code class="highlighter-rouge">A</code> (often called the <em>empty</em> list), and that <code class="highlighter-rouge">_∷_</code> (pronounced
<em>cons</em>, short for <em>constructor</em>) takes a value of type <code class="highlighter-rouge">A</code> and a value
of type <code class="highlighter-rouge">List A</code> and returns a value of type <code class="highlighter-rouge">List A</code>.  Operator <code class="highlighter-rouge">_∷_</code>
has precedence level 5 and associates to the right.</p>

<p>For example,</p>
<pre class="Agda"><a id="1621" href="/PLFA-zh/Lists/#1621" class="Function">_</a> <a id="1623" class="Symbol">:</a> <a id="1625" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="1630" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="1632" class="Symbol">_</a> <a id="1634" class="Symbol">=</a> <a id="1636" class="Number">0</a> <a id="1638" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="1640" class="Number">1</a> <a id="1642" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="1644" class="Number">2</a> <a id="1646" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="1648" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a></pre>
<p>denotes the list of the first three natural numbers.  Since <code class="highlighter-rouge">_∷_</code>
associates to the right, the term parses as <code class="highlighter-rouge">0 ∷ (1 ∷ (2 ∷ []))</code>.
Here <code class="highlighter-rouge">0</code> is the first element of the list, called the <em>head</em>,
and <code class="highlighter-rouge">1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the
<em>tail</em>. A list is a strange beast: it has a head and a tail,
nothing in between, and the tail is itself another list!</p>

<p>As we’ve seen, parameterised types can be translated to
indexed types. The definition above is equivalent to the following:</p>
<pre class="Agda"><a id="2179" class="Keyword">data</a> <a id="List′"></a><a id="2184" href="/PLFA-zh/Lists/#2184" class="Datatype">List′</a> <a id="2190" class="Symbol">:</a> <a id="2192" class="PrimitiveType">Set</a> <a id="2196" class="Symbol">→</a> <a id="2198" class="PrimitiveType">Set</a> <a id="2202" class="Keyword">where</a>
  <a id="List′.[]′"></a><a id="2210" href="/PLFA-zh/Lists/#2210" class="InductiveConstructor">[]′</a>  <a id="2215" class="Symbol">:</a> <a id="2217" class="Symbol">∀</a> <a id="2219" class="Symbol">{</a><a id="2220" href="/PLFA-zh/Lists/#2220" class="Bound">A</a> <a id="2222" class="Symbol">:</a> <a id="2224" class="PrimitiveType">Set</a><a id="2227" class="Symbol">}</a> <a id="2229" class="Symbol">→</a> <a id="2231" href="/PLFA-zh/Lists/#2184" class="Datatype">List′</a> <a id="2237" href="/PLFA-zh/Lists/#2220" class="Bound">A</a>
  <a id="List′._∷′_"></a><a id="2241" href="/PLFA-zh/Lists/#2241" class="InductiveConstructor Operator">_∷′_</a> <a id="2246" class="Symbol">:</a> <a id="2248" class="Symbol">∀</a> <a id="2250" class="Symbol">{</a><a id="2251" href="/PLFA-zh/Lists/#2251" class="Bound">A</a> <a id="2253" class="Symbol">:</a> <a id="2255" class="PrimitiveType">Set</a><a id="2258" class="Symbol">}</a> <a id="2260" class="Symbol">→</a> <a id="2262" href="/PLFA-zh/Lists/#2251" class="Bound">A</a> <a id="2264" class="Symbol">→</a> <a id="2266" href="/PLFA-zh/Lists/#2184" class="Datatype">List′</a> <a id="2272" href="/PLFA-zh/Lists/#2251" class="Bound">A</a> <a id="2274" class="Symbol">→</a> <a id="2276" href="/PLFA-zh/Lists/#2184" class="Datatype">List′</a> <a id="2282" href="/PLFA-zh/Lists/#2251" class="Bound">A</a></pre>
<p>Each constructor takes the parameter as an implicit argument.
Thus, our example list could also be written:</p>
<pre class="Agda"><a id="2416" href="/PLFA-zh/Lists/#2416" class="Function">_</a> <a id="2418" class="Symbol">:</a> <a id="2420" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="2425" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="2427" class="Symbol">_</a> <a id="2429" class="Symbol">=</a> <a id="2431" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">_∷_</a> <a id="2435" class="Symbol">{</a><a id="2436" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="2437" class="Symbol">}</a> <a id="2439" class="Number">0</a> <a id="2441" class="Symbol">(</a><a id="2442" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">_∷_</a> <a id="2446" class="Symbol">{</a><a id="2447" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="2448" class="Symbol">}</a> <a id="2450" class="Number">1</a> <a id="2452" class="Symbol">(</a><a id="2453" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">_∷_</a> <a id="2457" class="Symbol">{</a><a id="2458" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="2459" class="Symbol">}</a> <a id="2461" class="Number">2</a> <a id="2463" class="Symbol">(</a><a id="2464" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="2467" class="Symbol">{</a><a id="2468" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="2469" class="Symbol">})))</a></pre>
<p>where here we have provided the implicit parameters explicitly.</p>

<p>Including the pragma:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{-# BUILTIN LIST List #-}
</code></pre></div></div>

<p>tells Agda that the type <code class="highlighter-rouge">List</code> corresponds to the Haskell type
list, and the constructors <code class="highlighter-rouge">[]</code> and <code class="highlighter-rouge">_∷_</code> correspond to nil and
cons respectively, allowing a more efficient representation of lists.</p>

<h2 id="list-syntax">List syntax</h2>

<p>We can write lists more conveniently by introducing the following definitions:</p>
<pre class="Agda"><a id="2912" class="Keyword">pattern</a> <a id="[_]"></a><a id="2920" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[_]</a> <a id="2924" href="/PLFA-zh/Lists/#2928" class="Bound">z</a> <a id="2926" class="Symbol">=</a> <a id="2928" href="/PLFA-zh/Lists/#2928" class="Bound">z</a> <a id="2930" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="2932" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="2935" class="Keyword">pattern</a> <a id="[_,_]"></a><a id="2943" href="/PLFA-zh/Lists/#2943" class="InductiveConstructor Operator">[_,_]</a> <a id="2949" href="/PLFA-zh/Lists/#2955" class="Bound">y</a> <a id="2951" href="/PLFA-zh/Lists/#2959" class="Bound">z</a> <a id="2953" class="Symbol">=</a> <a id="2955" href="/PLFA-zh/Lists/#2955" class="Bound">y</a> <a id="2957" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="2959" href="/PLFA-zh/Lists/#2959" class="Bound">z</a> <a id="2961" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="2963" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="2966" class="Keyword">pattern</a> <a id="[_,_,_]"></a><a id="2974" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[_,_,_]</a> <a id="2982" href="/PLFA-zh/Lists/#2990" class="Bound">x</a> <a id="2984" href="/PLFA-zh/Lists/#2994" class="Bound">y</a> <a id="2986" href="/PLFA-zh/Lists/#2998" class="Bound">z</a> <a id="2988" class="Symbol">=</a> <a id="2990" href="/PLFA-zh/Lists/#2990" class="Bound">x</a> <a id="2992" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="2994" href="/PLFA-zh/Lists/#2994" class="Bound">y</a> <a id="2996" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="2998" href="/PLFA-zh/Lists/#2998" class="Bound">z</a> <a id="3000" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3002" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="3005" class="Keyword">pattern</a> <a id="[_,_,_,_]"></a><a id="3013" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="3023" href="/PLFA-zh/Lists/#3033" class="Bound">w</a> <a id="3025" href="/PLFA-zh/Lists/#3037" class="Bound">x</a> <a id="3027" href="/PLFA-zh/Lists/#3041" class="Bound">y</a> <a id="3029" href="/PLFA-zh/Lists/#3045" class="Bound">z</a> <a id="3031" class="Symbol">=</a> <a id="3033" href="/PLFA-zh/Lists/#3033" class="Bound">w</a> <a id="3035" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3037" href="/PLFA-zh/Lists/#3037" class="Bound">x</a> <a id="3039" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3041" href="/PLFA-zh/Lists/#3041" class="Bound">y</a> <a id="3043" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3045" href="/PLFA-zh/Lists/#3045" class="Bound">z</a> <a id="3047" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3049" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="3052" class="Keyword">pattern</a> <a id="[_,_,_,_,_]"></a><a id="3060" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="3072" href="/PLFA-zh/Lists/#3084" class="Bound">v</a> <a id="3074" href="/PLFA-zh/Lists/#3088" class="Bound">w</a> <a id="3076" href="/PLFA-zh/Lists/#3092" class="Bound">x</a> <a id="3078" href="/PLFA-zh/Lists/#3096" class="Bound">y</a> <a id="3080" href="/PLFA-zh/Lists/#3100" class="Bound">z</a> <a id="3082" class="Symbol">=</a> <a id="3084" href="/PLFA-zh/Lists/#3084" class="Bound">v</a> <a id="3086" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3088" href="/PLFA-zh/Lists/#3088" class="Bound">w</a> <a id="3090" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3092" href="/PLFA-zh/Lists/#3092" class="Bound">x</a> <a id="3094" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3096" href="/PLFA-zh/Lists/#3096" class="Bound">y</a> <a id="3098" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3100" href="/PLFA-zh/Lists/#3100" class="Bound">z</a> <a id="3102" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3104" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="3107" class="Keyword">pattern</a> <a id="[_,_,_,_,_,_]"></a><a id="3115" href="/PLFA-zh/Lists/#3115" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="3129" href="/PLFA-zh/Lists/#3143" class="Bound">u</a> <a id="3131" href="/PLFA-zh/Lists/#3147" class="Bound">v</a> <a id="3133" href="/PLFA-zh/Lists/#3151" class="Bound">w</a> <a id="3135" href="/PLFA-zh/Lists/#3155" class="Bound">x</a> <a id="3137" href="/PLFA-zh/Lists/#3159" class="Bound">y</a> <a id="3139" href="/PLFA-zh/Lists/#3163" class="Bound">z</a> <a id="3141" class="Symbol">=</a> <a id="3143" href="/PLFA-zh/Lists/#3143" class="Bound">u</a> <a id="3145" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3147" href="/PLFA-zh/Lists/#3147" class="Bound">v</a> <a id="3149" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3151" href="/PLFA-zh/Lists/#3151" class="Bound">w</a> <a id="3153" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3155" href="/PLFA-zh/Lists/#3155" class="Bound">x</a> <a id="3157" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3159" href="/PLFA-zh/Lists/#3159" class="Bound">y</a> <a id="3161" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3163" href="/PLFA-zh/Lists/#3163" class="Bound">z</a> <a id="3165" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3167" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a></pre>
<p>This is our first use of pattern declarations.  For instance,
the third line tells us that <code class="highlighter-rouge">[ x , y , z ]</code> is equivalent to
<code class="highlighter-rouge">x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in
a pattern on the left-hand side of an equation, or a term
on the right-hand side of an equation.</p>

<h2 id="append">Append</h2>

<p>Our first function on lists is written <code class="highlighter-rouge">_++_</code> and pronounced
<em>append</em>:</p>

<pre class="Agda"><a id="3561" class="Keyword">infixr</a> <a id="3568" class="Number">5</a> <a id="3570" href="/PLFA-zh/Lists/#3576" class="Function Operator">_++_</a>

<a id="_++_"></a><a id="3576" href="/PLFA-zh/Lists/#3576" class="Function Operator">_++_</a> <a id="3581" class="Symbol">:</a> <a id="3583" class="Symbol">∀</a> <a id="3585" class="Symbol">{</a><a id="3586" href="/PLFA-zh/Lists/#3586" class="Bound">A</a> <a id="3588" class="Symbol">:</a> <a id="3590" class="PrimitiveType">Set</a><a id="3593" class="Symbol">}</a> <a id="3595" class="Symbol">→</a> <a id="3597" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="3602" href="/PLFA-zh/Lists/#3586" class="Bound">A</a> <a id="3604" class="Symbol">→</a> <a id="3606" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="3611" href="/PLFA-zh/Lists/#3586" class="Bound">A</a> <a id="3613" class="Symbol">→</a> <a id="3615" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="3620" href="/PLFA-zh/Lists/#3586" class="Bound">A</a>
<a id="3622" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>       <a id="3631" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="3634" href="/PLFA-zh/Lists/#3634" class="Bound">ys</a>  <a id="3638" class="Symbol">=</a>  <a id="3641" href="/PLFA-zh/Lists/#3634" class="Bound">ys</a>
<a id="3644" class="Symbol">(</a><a id="3645" href="/PLFA-zh/Lists/#3645" class="Bound">x</a> <a id="3647" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3649" href="/PLFA-zh/Lists/#3649" class="Bound">xs</a><a id="3651" class="Symbol">)</a> <a id="3653" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="3656" href="/PLFA-zh/Lists/#3656" class="Bound">ys</a>  <a id="3660" class="Symbol">=</a>  <a id="3663" href="/PLFA-zh/Lists/#3645" class="Bound">x</a> <a id="3665" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="3667" class="Symbol">(</a><a id="3668" href="/PLFA-zh/Lists/#3649" class="Bound">xs</a> <a id="3671" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="3674" href="/PLFA-zh/Lists/#3656" class="Bound">ys</a><a id="3676" class="Symbol">)</a></pre>
<p>The type <code class="highlighter-rouge">A</code> is an implicit argument to append, making it a
<em>polymorphic</em> function (one that can be used at many types).  The
empty list appended to another list yields the other list.  A
non-empty list appended to another list yields a list with head the
same as the head of the first list and tail the same as the tail of
the first list appended to the second list.</p>

<p>Here is an example, showing how to compute the result
of appending two lists:</p>
<pre class="Agda"><a id="4149" href="/PLFA-zh/Lists/#4149" class="Function">_</a> <a id="4151" class="Symbol">:</a> <a id="4153" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="4155" class="Number">0</a> <a id="4157" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="4159" class="Number">1</a> <a id="4161" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="4163" class="Number">2</a> <a id="4165" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="4167" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4170" href="/PLFA-zh/Lists/#2943" class="InductiveConstructor Operator">[</a> <a id="4172" class="Number">3</a> <a id="4174" href="/PLFA-zh/Lists/#2943" class="InductiveConstructor Operator">,</a> <a id="4176" class="Number">4</a> <a id="4178" href="/PLFA-zh/Lists/#2943" class="InductiveConstructor Operator">]</a> <a id="4180" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="4182" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">[</a> <a id="4184" class="Number">0</a> <a id="4186" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">,</a> <a id="4188" class="Number">1</a> <a id="4190" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">,</a> <a id="4192" class="Number">2</a> <a id="4194" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">,</a> <a id="4196" class="Number">3</a> <a id="4198" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">,</a> <a id="4200" class="Number">4</a> <a id="4202" href="/PLFA-zh/Lists/#3060" class="InductiveConstructor Operator">]</a>
<a id="4204" class="Symbol">_</a> <a id="4206" class="Symbol">=</a>
  <a id="4210" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="4220" class="Number">0</a> <a id="4222" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4224" class="Number">1</a> <a id="4226" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4228" class="Number">2</a> <a id="4230" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4232" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4235" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4238" class="Number">3</a> <a id="4240" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4242" class="Number">4</a> <a id="4244" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4246" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="4251" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4259" class="Number">0</a> <a id="4261" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4263" class="Symbol">(</a><a id="4264" class="Number">1</a> <a id="4266" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4268" class="Number">2</a> <a id="4270" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4272" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4275" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4278" class="Number">3</a> <a id="4280" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4282" class="Number">4</a> <a id="4284" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4286" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="4288" class="Symbol">)</a>
  <a id="4292" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4300" class="Number">0</a> <a id="4302" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4304" class="Number">1</a> <a id="4306" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4308" class="Symbol">(</a><a id="4309" class="Number">2</a> <a id="4311" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4313" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4316" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4319" class="Number">3</a> <a id="4321" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4323" class="Number">4</a> <a id="4325" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4327" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="4329" class="Symbol">)</a>
  <a id="4333" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4341" class="Number">0</a> <a id="4343" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4345" class="Number">1</a> <a id="4347" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4349" class="Number">2</a> <a id="4351" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4353" class="Symbol">(</a><a id="4354" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4357" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4360" class="Number">3</a> <a id="4362" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4364" class="Number">4</a> <a id="4366" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4368" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="4370" class="Symbol">)</a>
  <a id="4374" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4382" class="Number">0</a> <a id="4384" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4386" class="Number">1</a> <a id="4388" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4390" class="Number">2</a> <a id="4392" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4394" class="Number">3</a> <a id="4396" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4398" class="Number">4</a> <a id="4400" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4402" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="4407" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Appending two lists requires time linear in the
number of elements in the first list.</p>

<h2 id="reasoning-about-append">Reasoning about append</h2>

<p>We can reason about lists in much the same way that we reason
about numbers.  Here is the proof that append is associative:</p>
<pre class="Agda"><a id="++-assoc"></a><a id="4672" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a> <a id="4681" class="Symbol">:</a> <a id="4683" class="Symbol">∀</a> <a id="4685" class="Symbol">{</a><a id="4686" href="/PLFA-zh/Lists/#4686" class="Bound">A</a> <a id="4688" class="Symbol">:</a> <a id="4690" class="PrimitiveType">Set</a><a id="4693" class="Symbol">}</a> <a id="4695" class="Symbol">(</a><a id="4696" href="/PLFA-zh/Lists/#4696" class="Bound">xs</a> <a id="4699" href="/PLFA-zh/Lists/#4699" class="Bound">ys</a> <a id="4702" href="/PLFA-zh/Lists/#4702" class="Bound">zs</a> <a id="4705" class="Symbol">:</a> <a id="4707" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="4712" href="/PLFA-zh/Lists/#4686" class="Bound">A</a><a id="4713" class="Symbol">)</a>
  <a id="4717" class="Symbol">→</a> <a id="4719" class="Symbol">(</a><a id="4720" href="/PLFA-zh/Lists/#4696" class="Bound">xs</a> <a id="4723" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4726" href="/PLFA-zh/Lists/#4699" class="Bound">ys</a><a id="4728" class="Symbol">)</a> <a id="4730" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4733" href="/PLFA-zh/Lists/#4702" class="Bound">zs</a> <a id="4736" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="4738" href="/PLFA-zh/Lists/#4696" class="Bound">xs</a> <a id="4741" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4744" class="Symbol">(</a><a id="4745" href="/PLFA-zh/Lists/#4699" class="Bound">ys</a> <a id="4748" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4751" href="/PLFA-zh/Lists/#4702" class="Bound">zs</a><a id="4753" class="Symbol">)</a>
<a id="4755" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a> <a id="4764" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4767" href="/PLFA-zh/Lists/#4767" class="Bound">ys</a> <a id="4770" href="/PLFA-zh/Lists/#4770" class="Bound">zs</a> <a id="4773" class="Symbol">=</a>
  <a id="4777" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="4787" class="Symbol">(</a><a id="4788" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4791" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4794" href="/PLFA-zh/Lists/#4767" class="Bound">ys</a><a id="4796" class="Symbol">)</a> <a id="4798" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4801" href="/PLFA-zh/Lists/#4770" class="Bound">zs</a>
  <a id="4806" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4814" href="/PLFA-zh/Lists/#4767" class="Bound">ys</a> <a id="4817" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4820" href="/PLFA-zh/Lists/#4770" class="Bound">zs</a>
  <a id="4825" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4833" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="4836" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4839" class="Symbol">(</a><a id="4840" href="/PLFA-zh/Lists/#4767" class="Bound">ys</a> <a id="4843" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4846" href="/PLFA-zh/Lists/#4770" class="Bound">zs</a><a id="4848" class="Symbol">)</a>
  <a id="4852" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="4854" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a> <a id="4863" class="Symbol">(</a><a id="4864" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="4866" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4868" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a><a id="4870" class="Symbol">)</a> <a id="4872" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a> <a id="4875" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a> <a id="4878" class="Symbol">=</a>
  <a id="4882" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="4892" class="Symbol">(</a><a id="4893" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="4895" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4897" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="4900" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4903" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a><a id="4905" class="Symbol">)</a> <a id="4907" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4910" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a>
  <a id="4915" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4923" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="4925" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4927" class="Symbol">(</a><a id="4928" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="4931" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4934" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a><a id="4936" class="Symbol">)</a> <a id="4938" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4941" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a>
  <a id="4946" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="4954" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="4956" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="4958" class="Symbol">((</a><a id="4960" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="4963" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4966" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a><a id="4968" class="Symbol">)</a> <a id="4970" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="4973" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a><a id="4975" class="Symbol">)</a>
  <a id="4979" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="4982" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="4987" class="Symbol">(</a><a id="4988" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="4990" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷_</a><a id="4992" class="Symbol">)</a> <a id="4994" class="Symbol">(</a><a id="4995" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a> <a id="5004" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="5007" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a> <a id="5010" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a><a id="5012" class="Symbol">)</a> <a id="5014" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="5020" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="5022" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="5024" class="Symbol">(</a><a id="5025" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="5028" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5031" class="Symbol">(</a><a id="5032" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a> <a id="5035" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5038" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a><a id="5040" class="Symbol">))</a>
  <a id="5045" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5053" href="/PLFA-zh/Lists/#4864" class="Bound">x</a> <a id="5055" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="5057" href="/PLFA-zh/Lists/#4868" class="Bound">xs</a> <a id="5060" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5063" class="Symbol">(</a><a id="5064" href="/PLFA-zh/Lists/#4872" class="Bound">ys</a> <a id="5067" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5070" href="/PLFA-zh/Lists/#4875" class="Bound">zs</a><a id="5072" class="Symbol">)</a>
  <a id="5076" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>The proof is by induction on the first argument. The base case instantiates
to <code class="highlighter-rouge">[]</code>, and follows by straightforward computation.
The inductive case instantiates to <code class="highlighter-rouge">x ∷ xs</code>,
and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated by a recursive
invocation of the proof, in this case <code class="highlighter-rouge">++-assoc xs ys zs</code>.</p>

<p>Recall that Agda supports <a href="/PLFA-zh/Induction/#sections">sections</a>.
Applying <code class="highlighter-rouge">cong (x ∷_)</code> promotes the inductive hypothesis:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xs ++ (ys ++ zs) ≡ (xs ++ ys) ++ zs
</code></pre></div></div>

<p>to the equality:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x ∷ (xs ++ (ys ++ zs)) ≡ x ∷ ((xs ++ ys) ++ zs)
</code></pre></div></div>

<p>which is needed in the proof.</p>

<p>It is also easy to show that <code class="highlighter-rouge">[]</code> is a left and right identity for <code class="highlighter-rouge">_++_</code>.
That it is a left identity is immediate from the definition:</p>
<pre class="Agda"><a id="++-identityˡ"></a><a id="5884" href="/PLFA-zh/Lists/#5884" class="Function">++-identityˡ</a> <a id="5897" class="Symbol">:</a> <a id="5899" class="Symbol">∀</a> <a id="5901" class="Symbol">{</a><a id="5902" href="/PLFA-zh/Lists/#5902" class="Bound">A</a> <a id="5904" class="Symbol">:</a> <a id="5906" class="PrimitiveType">Set</a><a id="5909" class="Symbol">}</a> <a id="5911" class="Symbol">(</a><a id="5912" href="/PLFA-zh/Lists/#5912" class="Bound">xs</a> <a id="5915" class="Symbol">:</a> <a id="5917" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="5922" href="/PLFA-zh/Lists/#5902" class="Bound">A</a><a id="5923" class="Symbol">)</a> <a id="5925" class="Symbol">→</a> <a id="5927" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="5930" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5933" href="/PLFA-zh/Lists/#5912" class="Bound">xs</a> <a id="5936" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="5938" href="/PLFA-zh/Lists/#5912" class="Bound">xs</a>
<a id="5941" href="/PLFA-zh/Lists/#5884" class="Function">++-identityˡ</a> <a id="5954" href="/PLFA-zh/Lists/#5954" class="Bound">xs</a> <a id="5957" class="Symbol">=</a>
  <a id="5961" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="5971" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="5974" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="5977" href="/PLFA-zh/Lists/#5954" class="Bound">xs</a>
  <a id="5982" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="5990" href="/PLFA-zh/Lists/#5954" class="Bound">xs</a>
  <a id="5995" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>That it is a right identity follows by simple induction:</p>
<pre class="Agda"><a id="++-identityʳ"></a><a id="6078" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a> <a id="6091" class="Symbol">:</a> <a id="6093" class="Symbol">∀</a> <a id="6095" class="Symbol">{</a><a id="6096" href="/PLFA-zh/Lists/#6096" class="Bound">A</a> <a id="6098" class="Symbol">:</a> <a id="6100" class="PrimitiveType">Set</a><a id="6103" class="Symbol">}</a> <a id="6105" class="Symbol">(</a><a id="6106" href="/PLFA-zh/Lists/#6106" class="Bound">xs</a> <a id="6109" class="Symbol">:</a> <a id="6111" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="6116" href="/PLFA-zh/Lists/#6096" class="Bound">A</a><a id="6117" class="Symbol">)</a> <a id="6119" class="Symbol">→</a> <a id="6121" href="/PLFA-zh/Lists/#6106" class="Bound">xs</a> <a id="6124" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="6127" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="6130" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="6132" href="/PLFA-zh/Lists/#6106" class="Bound">xs</a>
<a id="6135" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a> <a id="6148" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="6151" class="Symbol">=</a>
  <a id="6155" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="6165" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="6168" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="6171" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="6176" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6184" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="6189" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="6191" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a> <a id="6204" class="Symbol">(</a><a id="6205" href="/PLFA-zh/Lists/#6205" class="Bound">x</a> <a id="6207" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6209" href="/PLFA-zh/Lists/#6209" class="Bound">xs</a><a id="6211" class="Symbol">)</a> <a id="6213" class="Symbol">=</a>
  <a id="6217" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="6227" class="Symbol">(</a><a id="6228" href="/PLFA-zh/Lists/#6205" class="Bound">x</a> <a id="6230" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6232" href="/PLFA-zh/Lists/#6209" class="Bound">xs</a><a id="6234" class="Symbol">)</a> <a id="6236" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="6239" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="6244" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6252" href="/PLFA-zh/Lists/#6205" class="Bound">x</a> <a id="6254" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6256" class="Symbol">(</a><a id="6257" href="/PLFA-zh/Lists/#6209" class="Bound">xs</a> <a id="6260" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="6263" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="6265" class="Symbol">)</a>
  <a id="6269" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="6272" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="6277" class="Symbol">(</a><a id="6278" href="/PLFA-zh/Lists/#6205" class="Bound">x</a> <a id="6280" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷_</a><a id="6282" class="Symbol">)</a> <a id="6284" class="Symbol">(</a><a id="6285" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a> <a id="6298" href="/PLFA-zh/Lists/#6209" class="Bound">xs</a><a id="6300" class="Symbol">)</a> <a id="6302" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="6308" href="/PLFA-zh/Lists/#6205" class="Bound">x</a> <a id="6310" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6312" href="/PLFA-zh/Lists/#6209" class="Bound">xs</a>
  <a id="6317" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>As we will see later,
these three properties establish that <code class="highlighter-rouge">_++_</code> and <code class="highlighter-rouge">[]</code> form
a <em>monoid</em> over lists.</p>

<h2 id="length">Length</h2>

<p>Our next function finds the length of a list:</p>
<pre class="Agda"><a id="length"></a><a id="6505" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6512" class="Symbol">:</a> <a id="6514" class="Symbol">∀</a> <a id="6516" class="Symbol">{</a><a id="6517" href="/PLFA-zh/Lists/#6517" class="Bound">A</a> <a id="6519" class="Symbol">:</a> <a id="6521" class="PrimitiveType">Set</a><a id="6524" class="Symbol">}</a> <a id="6526" class="Symbol">→</a> <a id="6528" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="6533" href="/PLFA-zh/Lists/#6517" class="Bound">A</a> <a id="6535" class="Symbol">→</a> <a id="6537" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="6539" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6546" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>        <a id="6556" class="Symbol">=</a>  <a id="6559" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>
<a id="6564" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6571" class="Symbol">(</a><a id="6572" href="/PLFA-zh/Lists/#6572" class="Bound">x</a> <a id="6574" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6576" href="/PLFA-zh/Lists/#6576" class="Bound">xs</a><a id="6578" class="Symbol">)</a>  <a id="6581" class="Symbol">=</a>  <a id="6584" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="6588" class="Symbol">(</a><a id="6589" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6596" href="/PLFA-zh/Lists/#6576" class="Bound">xs</a><a id="6598" class="Symbol">)</a></pre>
<p>Again, it takes an implicit parameter <code class="highlighter-rouge">A</code>.
The length of the empty list is zero.
The length of a non-empty list
is one greater than the length of the tail of the list.</p>

<p>Here is an example showing how to compute the length of a list:</p>
<pre class="Agda"><a id="6857" href="/PLFA-zh/Lists/#6857" class="Function">_</a> <a id="6859" class="Symbol">:</a> <a id="6861" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6868" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="6870" class="Number">0</a> <a id="6872" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="6874" class="Number">1</a> <a id="6876" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="6878" class="Number">2</a> <a id="6880" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="6882" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="6884" class="Number">3</a>
<a id="6886" class="Symbol">_</a> <a id="6888" class="Symbol">=</a>
  <a id="6892" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="6902" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6909" class="Symbol">(</a><a id="6910" class="Number">0</a> <a id="6912" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6914" class="Number">1</a> <a id="6916" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6918" class="Number">2</a> <a id="6920" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6922" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="6924" class="Symbol">)</a>
  <a id="6928" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6936" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="6940" class="Symbol">(</a><a id="6941" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6948" class="Symbol">(</a><a id="6949" class="Number">1</a> <a id="6951" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6953" class="Number">2</a> <a id="6955" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6957" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="6959" class="Symbol">))</a>
  <a id="6964" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="6972" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="6976" class="Symbol">(</a><a id="6977" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="6981" class="Symbol">(</a><a id="6982" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="6989" class="Symbol">(</a><a id="6990" class="Number">2</a> <a id="6992" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="6994" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="6996" class="Symbol">)))</a>
  <a id="7002" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7010" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7014" class="Symbol">(</a><a id="7015" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7019" class="Symbol">(</a><a id="7020" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7024" class="Symbol">(</a><a id="7025" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7032" class="Symbol">{</a><a id="7033" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="7034" class="Symbol">}</a> <a id="7036" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="7038" class="Symbol">)))</a>
  <a id="7044" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7052" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7056" class="Symbol">(</a><a id="7057" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7061" class="Symbol">(</a><a id="7062" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7066" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="7070" class="Symbol">))</a>
  <a id="7075" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Computing the length of a list requires time
linear in the number of elements in the list.</p>

<p>In the second-to-last line, we cannot write simply <code class="highlighter-rouge">length []</code> but
must instead write <code class="highlighter-rouge">length {ℕ} []</code>.  Since <code class="highlighter-rouge">[]</code> has no elements, Agda
has insufficient information to infer the implicit parameter.</p>

<h2 id="reasoning-about-length">Reasoning about length</h2>

<p>The length of one list appended to another is the
sum of the lengths of the lists:</p>
<pre class="Agda"><a id="length-++"></a><a id="7504" href="/PLFA-zh/Lists/#7504" class="Function">length-++</a> <a id="7514" class="Symbol">:</a> <a id="7516" class="Symbol">∀</a> <a id="7518" class="Symbol">{</a><a id="7519" href="/PLFA-zh/Lists/#7519" class="Bound">A</a> <a id="7521" class="Symbol">:</a> <a id="7523" class="PrimitiveType">Set</a><a id="7526" class="Symbol">}</a> <a id="7528" class="Symbol">(</a><a id="7529" href="/PLFA-zh/Lists/#7529" class="Bound">xs</a> <a id="7532" href="/PLFA-zh/Lists/#7532" class="Bound">ys</a> <a id="7535" class="Symbol">:</a> <a id="7537" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="7542" href="/PLFA-zh/Lists/#7519" class="Bound">A</a><a id="7543" class="Symbol">)</a>
  <a id="7547" class="Symbol">→</a> <a id="7549" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7556" class="Symbol">(</a><a id="7557" href="/PLFA-zh/Lists/#7529" class="Bound">xs</a> <a id="7560" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="7563" href="/PLFA-zh/Lists/#7532" class="Bound">ys</a><a id="7565" class="Symbol">)</a> <a id="7567" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="7569" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7576" href="/PLFA-zh/Lists/#7529" class="Bound">xs</a> <a id="7579" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="7581" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7588" href="/PLFA-zh/Lists/#7532" class="Bound">ys</a>
<a id="7591" href="/PLFA-zh/Lists/#7504" class="Function">length-++</a> <a id="7601" class="Symbol">{</a><a id="7602" href="/PLFA-zh/Lists/#7602" class="Bound">A</a><a id="7603" class="Symbol">}</a> <a id="7605" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="7608" href="/PLFA-zh/Lists/#7608" class="Bound">ys</a> <a id="7611" class="Symbol">=</a>
  <a id="7615" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="7625" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7632" class="Symbol">(</a><a id="7633" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="7636" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="7639" href="/PLFA-zh/Lists/#7608" class="Bound">ys</a><a id="7641" class="Symbol">)</a>
  <a id="7645" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7653" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7660" href="/PLFA-zh/Lists/#7608" class="Bound">ys</a>
  <a id="7665" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7673" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7680" class="Symbol">{</a><a id="7681" href="/PLFA-zh/Lists/#7602" class="Bound">A</a><a id="7682" class="Symbol">}</a> <a id="7684" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="7687" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="7689" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7696" href="/PLFA-zh/Lists/#7608" class="Bound">ys</a>
  <a id="7701" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="7703" href="/PLFA-zh/Lists/#7504" class="Function">length-++</a> <a id="7713" class="Symbol">(</a><a id="7714" href="/PLFA-zh/Lists/#7714" class="Bound">x</a> <a id="7716" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="7718" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a><a id="7720" class="Symbol">)</a> <a id="7722" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a> <a id="7725" class="Symbol">=</a>
  <a id="7729" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="7739" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7746" class="Symbol">((</a><a id="7748" href="/PLFA-zh/Lists/#7714" class="Bound">x</a> <a id="7750" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="7752" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a><a id="7754" class="Symbol">)</a> <a id="7756" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="7759" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a><a id="7761" class="Symbol">)</a>
  <a id="7765" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7773" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7777" class="Symbol">(</a><a id="7778" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7785" class="Symbol">(</a><a id="7786" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a> <a id="7789" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="7792" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a><a id="7794" class="Symbol">))</a>
  <a id="7799" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="7802" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="7807" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7811" class="Symbol">(</a><a id="7812" href="/PLFA-zh/Lists/#7504" class="Function">length-++</a> <a id="7822" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a> <a id="7825" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a><a id="7827" class="Symbol">)</a> <a id="7829" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="7835" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7839" class="Symbol">(</a><a id="7840" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7847" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a> <a id="7850" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="7852" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7859" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a><a id="7861" class="Symbol">)</a>
  <a id="7865" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="7873" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7880" class="Symbol">(</a><a id="7881" href="/PLFA-zh/Lists/#7714" class="Bound">x</a> <a id="7883" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="7885" href="/PLFA-zh/Lists/#7718" class="Bound">xs</a><a id="7887" class="Symbol">)</a> <a id="7889" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="7891" href="/PLFA-zh/Lists/#6505" class="Function">length</a> <a id="7898" href="/PLFA-zh/Lists/#7722" class="Bound">ys</a>
  <a id="7903" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>The proof is by induction on the first argument. The base case
instantiates to <code class="highlighter-rouge">[]</code>, and follows by straightforward computation.  As
before, Agda cannot infer the implicit type parameter to <code class="highlighter-rouge">length</code>, and
it must be given explicitly.  The inductive case instantiates to
<code class="highlighter-rouge">x ∷ xs</code>, and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated
by a recursive invocation of the proof, in this case <code class="highlighter-rouge">length-++ xs ys</code>,
and it is promoted by the congruence <code class="highlighter-rouge">cong suc</code>.</p>

<h2 id="reverse">Reverse</h2>

<p>Using append, it is easy to formulate a function to reverse a list:</p>
<pre class="Agda"><a id="reverse"></a><a id="8543" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8551" class="Symbol">:</a> <a id="8553" class="Symbol">∀</a> <a id="8555" class="Symbol">{</a><a id="8556" href="/PLFA-zh/Lists/#8556" class="Bound">A</a> <a id="8558" class="Symbol">:</a> <a id="8560" class="PrimitiveType">Set</a><a id="8563" class="Symbol">}</a> <a id="8565" class="Symbol">→</a> <a id="8567" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="8572" href="/PLFA-zh/Lists/#8556" class="Bound">A</a> <a id="8574" class="Symbol">→</a> <a id="8576" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="8581" href="/PLFA-zh/Lists/#8556" class="Bound">A</a>
<a id="8583" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8591" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>        <a id="8601" class="Symbol">=</a>  <a id="8604" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="8607" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8615" class="Symbol">(</a><a id="8616" href="/PLFA-zh/Lists/#8616" class="Bound">x</a> <a id="8618" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8620" href="/PLFA-zh/Lists/#8620" class="Bound">xs</a><a id="8622" class="Symbol">)</a>  <a id="8625" class="Symbol">=</a>  <a id="8628" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8636" href="/PLFA-zh/Lists/#8620" class="Bound">xs</a> <a id="8639" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="8642" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="8644" href="/PLFA-zh/Lists/#8616" class="Bound">x</a> <a id="8646" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a></pre>
<p>The reverse of the empty list is the empty list.
The reverse of a non-empty list
is the reverse of its tail appended to a unit list
containing its head.</p>

<p>Here is an example showing how to reverse a list:</p>
<pre class="Agda"><a id="8876" href="/PLFA-zh/Lists/#8876" class="Function">_</a> <a id="8878" class="Symbol">:</a> <a id="8880" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8888" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="8890" class="Number">0</a> <a id="8892" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="8894" class="Number">1</a> <a id="8896" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="8898" class="Number">2</a> <a id="8900" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="8902" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="8904" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="8906" class="Number">2</a> <a id="8908" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="8910" class="Number">1</a> <a id="8912" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="8914" class="Number">0</a> <a id="8916" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="8918" class="Symbol">_</a> <a id="8920" class="Symbol">=</a>
  <a id="8924" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="8934" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8942" class="Symbol">(</a><a id="8943" class="Number">0</a> <a id="8945" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8947" class="Number">1</a> <a id="8949" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8951" class="Number">2</a> <a id="8953" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8955" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="8957" class="Symbol">)</a>
  <a id="8961" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="8969" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="8977" class="Symbol">(</a><a id="8978" class="Number">1</a> <a id="8980" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8982" class="Number">2</a> <a id="8984" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="8986" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="8988" class="Symbol">)</a> <a id="8990" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="8993" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="8995" class="Number">0</a> <a id="8997" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="9001" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9009" class="Symbol">(</a><a id="9010" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="9018" class="Symbol">(</a><a id="9019" class="Number">2</a> <a id="9021" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9023" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9025" class="Symbol">)</a> <a id="9027" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9030" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9032" class="Number">1</a> <a id="9034" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="9035" class="Symbol">)</a> <a id="9037" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9040" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9042" class="Number">0</a> <a id="9044" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="9048" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9056" class="Symbol">((</a><a id="9058" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="9066" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9069" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9072" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9074" class="Number">2</a> <a id="9076" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="9077" class="Symbol">)</a> <a id="9079" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9082" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9084" class="Number">1</a> <a id="9086" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="9087" class="Symbol">)</a> <a id="9089" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9092" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9094" class="Number">0</a> <a id="9096" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="9100" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9108" class="Symbol">((</a><a id="9110" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9113" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9116" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9118" class="Number">2</a> <a id="9120" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="9121" class="Symbol">)</a> <a id="9123" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9126" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9128" class="Number">1</a> <a id="9130" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="9131" class="Symbol">)</a> <a id="9133" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9136" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="9138" class="Number">0</a> <a id="9140" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="9144" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9152" class="Symbol">((</a><a id="9154" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9157" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9160" class="Number">2</a> <a id="9162" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9164" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9166" class="Symbol">)</a> <a id="9168" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9171" class="Number">1</a> <a id="9173" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9175" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9177" class="Symbol">)</a> <a id="9179" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9182" class="Number">0</a> <a id="9184" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9186" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="9191" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9199" class="Symbol">(</a><a id="9200" class="Number">2</a> <a id="9202" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9204" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9207" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9210" class="Number">1</a> <a id="9212" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9214" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9216" class="Symbol">)</a> <a id="9218" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9221" class="Number">0</a> <a id="9223" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9225" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="9230" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9238" class="Number">2</a> <a id="9240" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9242" class="Symbol">(</a><a id="9243" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9246" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9249" class="Number">1</a> <a id="9251" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9253" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9255" class="Symbol">)</a> <a id="9257" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9260" class="Number">0</a> <a id="9262" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9264" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="9269" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9277" class="Symbol">(</a><a id="9278" class="Number">2</a> <a id="9280" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9282" class="Number">1</a> <a id="9284" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9286" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9288" class="Symbol">)</a> <a id="9290" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9293" class="Number">0</a> <a id="9295" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9297" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="9302" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9310" class="Number">2</a> <a id="9312" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9314" class="Symbol">(</a><a id="9315" class="Number">1</a> <a id="9317" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9319" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9322" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9325" class="Number">0</a> <a id="9327" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9329" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9331" class="Symbol">)</a>
  <a id="9335" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9343" class="Number">2</a> <a id="9345" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9347" class="Number">1</a> <a id="9349" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9351" class="Symbol">(</a><a id="9352" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="9355" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="9358" class="Number">0</a> <a id="9360" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9362" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="9364" class="Symbol">)</a>
  <a id="9368" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9376" class="Number">2</a> <a id="9378" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9380" class="Number">1</a> <a id="9382" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9384" class="Number">0</a> <a id="9386" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="9388" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="9393" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="9401" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="9403" class="Number">2</a> <a id="9405" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="9407" class="Number">1</a> <a id="9409" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="9411" class="Number">0</a> <a id="9413" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
  <a id="9417" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Reversing a list in this way takes time <em>quadratic</em> in the length of
the list. This is because reverse ends up appending lists of lengths
<code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, up to <code class="highlighter-rouge">n - 1</code>, where <code class="highlighter-rouge">n</code> is the length of the list being
reversed, append takes time linear in the length of the first
list, and the sum of the numbers up to <code class="highlighter-rouge">n - 1</code> is <code class="highlighter-rouge">n * (n - 1) / 2</code>.
(We will validate that last fact in an exercise later in this chapter.)</p>

<h4 id="exercise-reverse--commute-recommended">Exercise <code class="highlighter-rouge">reverse-++-commute</code> (recommended)</h4>

<p>Show that the reverse of one list appended to another is the
reverse of the second appended to the reverse of the first:</p>
<pre class="Agda"><a id="10023" class="Keyword">postulate</a>
  <a id="reverse-++-commute"></a><a id="10035" href="/PLFA-zh/Lists/#10035" class="Postulate">reverse-++-commute</a> <a id="10054" class="Symbol">:</a> <a id="10056" class="Symbol">∀</a> <a id="10058" class="Symbol">{</a><a id="10059" href="/PLFA-zh/Lists/#10059" class="Bound">A</a> <a id="10061" class="Symbol">:</a> <a id="10063" class="PrimitiveType">Set</a><a id="10066" class="Symbol">}</a> <a id="10068" class="Symbol">{</a><a id="10069" href="/PLFA-zh/Lists/#10069" class="Bound">xs</a> <a id="10072" href="/PLFA-zh/Lists/#10072" class="Bound">ys</a> <a id="10075" class="Symbol">:</a> <a id="10077" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="10082" href="/PLFA-zh/Lists/#10059" class="Bound">A</a><a id="10083" class="Symbol">}</a>
    <a id="10089" class="Symbol">→</a> <a id="10091" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="10099" class="Symbol">(</a><a id="10100" href="/PLFA-zh/Lists/#10069" class="Bound">xs</a> <a id="10103" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="10106" href="/PLFA-zh/Lists/#10072" class="Bound">ys</a><a id="10108" class="Symbol">)</a> <a id="10110" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="10112" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="10120" href="/PLFA-zh/Lists/#10072" class="Bound">ys</a> <a id="10123" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="10126" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="10134" href="/PLFA-zh/Lists/#10069" class="Bound">xs</a></pre>

<h4 id="exercise-reverse-involutive-recommended">Exercise <code class="highlighter-rouge">reverse-involutive</code> (recommended)</h4>

<p>A function is an <em>involution</em> if when applied twice it acts
as the identity function.  Show that reverse is an involution:</p>
<pre class="Agda"><a id="10335" class="Keyword">postulate</a>
  <a id="reverse-involutive"></a><a id="10347" href="/PLFA-zh/Lists/#10347" class="Postulate">reverse-involutive</a> <a id="10366" class="Symbol">:</a> <a id="10368" class="Symbol">∀</a> <a id="10370" class="Symbol">{</a><a id="10371" href="/PLFA-zh/Lists/#10371" class="Bound">A</a> <a id="10373" class="Symbol">:</a> <a id="10375" class="PrimitiveType">Set</a><a id="10378" class="Symbol">}</a> <a id="10380" class="Symbol">{</a><a id="10381" href="/PLFA-zh/Lists/#10381" class="Bound">xs</a> <a id="10384" class="Symbol">:</a> <a id="10386" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="10391" href="/PLFA-zh/Lists/#10371" class="Bound">A</a><a id="10392" class="Symbol">}</a>
    <a id="10398" class="Symbol">→</a> <a id="10400" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="10408" class="Symbol">(</a><a id="10409" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="10417" href="/PLFA-zh/Lists/#10381" class="Bound">xs</a><a id="10419" class="Symbol">)</a> <a id="10421" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="10423" href="/PLFA-zh/Lists/#10381" class="Bound">xs</a></pre>

<h2 id="faster-reverse">Faster reverse</h2>

<p>The definition above, while easy to reason about, is less efficient than
one might expect since it takes time quadratic in the length of the list.
The idea is that we generalise reverse to take an additional argument:</p>
<pre class="Agda"><a id="shunt"></a><a id="10689" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="10695" class="Symbol">:</a> <a id="10697" class="Symbol">∀</a> <a id="10699" class="Symbol">{</a><a id="10700" href="/PLFA-zh/Lists/#10700" class="Bound">A</a> <a id="10702" class="Symbol">:</a> <a id="10704" class="PrimitiveType">Set</a><a id="10707" class="Symbol">}</a> <a id="10709" class="Symbol">→</a> <a id="10711" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="10716" href="/PLFA-zh/Lists/#10700" class="Bound">A</a> <a id="10718" class="Symbol">→</a> <a id="10720" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="10725" href="/PLFA-zh/Lists/#10700" class="Bound">A</a> <a id="10727" class="Symbol">→</a> <a id="10729" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="10734" href="/PLFA-zh/Lists/#10700" class="Bound">A</a>
<a id="10736" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="10742" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>       <a id="10751" href="/PLFA-zh/Lists/#10751" class="Bound">ys</a>  <a id="10755" class="Symbol">=</a>  <a id="10758" href="/PLFA-zh/Lists/#10751" class="Bound">ys</a>
<a id="10761" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="10767" class="Symbol">(</a><a id="10768" href="/PLFA-zh/Lists/#10768" class="Bound">x</a> <a id="10770" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="10772" href="/PLFA-zh/Lists/#10772" class="Bound">xs</a><a id="10774" class="Symbol">)</a> <a id="10776" href="/PLFA-zh/Lists/#10776" class="Bound">ys</a>  <a id="10780" class="Symbol">=</a>  <a id="10783" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="10789" href="/PLFA-zh/Lists/#10772" class="Bound">xs</a> <a id="10792" class="Symbol">(</a><a id="10793" href="/PLFA-zh/Lists/#10768" class="Bound">x</a> <a id="10795" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="10797" href="/PLFA-zh/Lists/#10776" class="Bound">ys</a><a id="10799" class="Symbol">)</a></pre>
<p>The definition is by recursion on the first argument. The second argument
actually becomes <em>larger</em>, but this is not a problem because the argument
on which we recurse becomes <em>smaller</em>.</p>

<p>Shunt is related to reverse as follows:</p>
<pre class="Agda"><a id="shunt-reverse"></a><a id="11053" href="/PLFA-zh/Lists/#11053" class="Function">shunt-reverse</a> <a id="11067" class="Symbol">:</a> <a id="11069" class="Symbol">∀</a> <a id="11071" class="Symbol">{</a><a id="11072" href="/PLFA-zh/Lists/#11072" class="Bound">A</a> <a id="11074" class="Symbol">:</a> <a id="11076" class="PrimitiveType">Set</a><a id="11079" class="Symbol">}</a> <a id="11081" class="Symbol">(</a><a id="11082" href="/PLFA-zh/Lists/#11082" class="Bound">xs</a> <a id="11085" href="/PLFA-zh/Lists/#11085" class="Bound">ys</a> <a id="11088" class="Symbol">:</a> <a id="11090" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="11095" href="/PLFA-zh/Lists/#11072" class="Bound">A</a><a id="11096" class="Symbol">)</a>
  <a id="11100" class="Symbol">→</a> <a id="11102" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="11108" href="/PLFA-zh/Lists/#11082" class="Bound">xs</a> <a id="11111" href="/PLFA-zh/Lists/#11085" class="Bound">ys</a> <a id="11114" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="11116" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11124" href="/PLFA-zh/Lists/#11082" class="Bound">xs</a> <a id="11127" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11130" href="/PLFA-zh/Lists/#11085" class="Bound">ys</a>
<a id="11133" href="/PLFA-zh/Lists/#11053" class="Function">shunt-reverse</a> <a id="11147" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="11150" href="/PLFA-zh/Lists/#11150" class="Bound">ys</a> <a id="11153" class="Symbol">=</a>
  <a id="11157" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="11167" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="11173" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="11176" href="/PLFA-zh/Lists/#11150" class="Bound">ys</a>
  <a id="11181" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11189" href="/PLFA-zh/Lists/#11150" class="Bound">ys</a>
  <a id="11194" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11202" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11210" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="11213" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11216" href="/PLFA-zh/Lists/#11150" class="Bound">ys</a>
  <a id="11221" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="11223" href="/PLFA-zh/Lists/#11053" class="Function">shunt-reverse</a> <a id="11237" class="Symbol">(</a><a id="11238" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11240" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11242" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a><a id="11244" class="Symbol">)</a> <a id="11246" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a> <a id="11249" class="Symbol">=</a>
  <a id="11253" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="11263" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="11269" class="Symbol">(</a><a id="11270" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11272" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11274" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a><a id="11276" class="Symbol">)</a> <a id="11278" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a>
  <a id="11283" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11291" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="11297" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11300" class="Symbol">(</a><a id="11301" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11303" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11305" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a><a id="11307" class="Symbol">)</a>
  <a id="11311" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="11314" href="/PLFA-zh/Lists/#11053" class="Function">shunt-reverse</a> <a id="11328" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11331" class="Symbol">(</a><a id="11332" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11334" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11336" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a><a id="11338" class="Symbol">)</a> <a id="11340" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="11346" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11354" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11357" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11360" class="Symbol">(</a><a id="11361" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11363" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11365" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a><a id="11367" class="Symbol">)</a>
  <a id="11371" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11379" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11387" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11390" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11393" class="Symbol">(</a><a id="11394" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="11396" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11398" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a> <a id="11400" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11403" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a><a id="11405" class="Symbol">)</a>
  <a id="11409" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="11412" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="11416" class="Symbol">(</a><a id="11417" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a> <a id="11426" class="Symbol">(</a><a id="11427" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11435" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a><a id="11437" class="Symbol">)</a> <a id="11439" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="11441" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11443" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a> <a id="11445" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a><a id="11447" class="Symbol">)</a> <a id="11449" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="11455" class="Symbol">(</a><a id="11456" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11464" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a> <a id="11467" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11470" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="11472" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11474" href="/PLFA-zh/Lists/#2920" class="InductiveConstructor Operator">]</a><a id="11475" class="Symbol">)</a> <a id="11477" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11480" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a>
  <a id="11485" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="11493" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="11501" class="Symbol">(</a><a id="11502" href="/PLFA-zh/Lists/#11238" class="Bound">x</a> <a id="11504" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="11506" href="/PLFA-zh/Lists/#11242" class="Bound">xs</a><a id="11508" class="Symbol">)</a> <a id="11510" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="11513" href="/PLFA-zh/Lists/#11246" class="Bound">ys</a>
  <a id="11518" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>The proof is by induction on the first argument.
The base case instantiates to <code class="highlighter-rouge">[]</code>, and follows by straightforward computation.
The inductive case instantiates to <code class="highlighter-rouge">x ∷ xs</code> and follows by the inductive
hypothesis and associativity of append.  When we invoke the inductive hypothesis,
the second argument actually becomes <em>larger</em>, but this is not a problem because
the argument on which we induct becomes <em>smaller</em>.</p>

<p>Generalising on an auxiliary argument, which becomes larger as the argument on
which we recurse or induct becomes smaller, is a common trick. It belongs in
your quiver of arrows, ready to slay the right problem.</p>

<p>Having defined shunt be generalisation, it is now easy to respecialise to
give a more efficient definition of reverse:</p>
<pre class="Agda"><a id="reverse′"></a><a id="12293" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12302" class="Symbol">:</a> <a id="12304" class="Symbol">∀</a> <a id="12306" class="Symbol">{</a><a id="12307" href="/PLFA-zh/Lists/#12307" class="Bound">A</a> <a id="12309" class="Symbol">:</a> <a id="12311" class="PrimitiveType">Set</a><a id="12314" class="Symbol">}</a> <a id="12316" class="Symbol">→</a> <a id="12318" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="12323" href="/PLFA-zh/Lists/#12307" class="Bound">A</a> <a id="12325" class="Symbol">→</a> <a id="12327" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="12332" href="/PLFA-zh/Lists/#12307" class="Bound">A</a>
<a id="12334" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12343" href="/PLFA-zh/Lists/#12343" class="Bound">xs</a> <a id="12346" class="Symbol">=</a> <a id="12348" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="12354" href="/PLFA-zh/Lists/#12343" class="Bound">xs</a> <a id="12357" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a></pre>

<p>Given our previous lemma, it is straightforward to show
the two definitions equivalent:</p>
<pre class="Agda"><a id="reverses"></a><a id="12473" href="/PLFA-zh/Lists/#12473" class="Function">reverses</a> <a id="12482" class="Symbol">:</a> <a id="12484" class="Symbol">∀</a> <a id="12486" class="Symbol">{</a><a id="12487" href="/PLFA-zh/Lists/#12487" class="Bound">A</a> <a id="12489" class="Symbol">:</a> <a id="12491" class="PrimitiveType">Set</a><a id="12494" class="Symbol">}</a> <a id="12496" class="Symbol">(</a><a id="12497" href="/PLFA-zh/Lists/#12497" class="Bound">xs</a> <a id="12500" class="Symbol">:</a> <a id="12502" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="12507" href="/PLFA-zh/Lists/#12487" class="Bound">A</a><a id="12508" class="Symbol">)</a>
  <a id="12512" class="Symbol">→</a> <a id="12514" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12523" href="/PLFA-zh/Lists/#12497" class="Bound">xs</a> <a id="12526" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="12528" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="12536" href="/PLFA-zh/Lists/#12497" class="Bound">xs</a>
<a id="12539" href="/PLFA-zh/Lists/#12473" class="Function">reverses</a> <a id="12548" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a> <a id="12551" class="Symbol">=</a>
  <a id="12555" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="12565" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12574" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a>
  <a id="12579" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12587" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="12593" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a> <a id="12596" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="12601" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="12604" href="/PLFA-zh/Lists/#11053" class="Function">shunt-reverse</a> <a id="12618" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a> <a id="12621" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="12624" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="12630" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="12638" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a> <a id="12641" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="12644" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="12649" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="12652" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a> <a id="12665" class="Symbol">(</a><a id="12666" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="12674" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a><a id="12676" class="Symbol">)</a> <a id="12678" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>  
    <a id="12686" href="/PLFA-zh/Lists/#8543" class="Function">reverse</a> <a id="12694" href="/PLFA-zh/Lists/#12548" class="Bound">xs</a>
  <a id="12699" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<p>Here is an example showing fast reverse of the list <code class="highlighter-rouge">[ 0 , 1 , 2 ]</code>:</p>
<pre class="Agda"><a id="12795" href="/PLFA-zh/Lists/#12795" class="Function">_</a> <a id="12797" class="Symbol">:</a> <a id="12799" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12808" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="12810" class="Number">0</a> <a id="12812" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="12814" class="Number">1</a> <a id="12816" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="12818" class="Number">2</a> <a id="12820" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="12822" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="12824" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="12826" class="Number">2</a> <a id="12828" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="12830" class="Number">1</a> <a id="12832" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="12834" class="Number">0</a> <a id="12836" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="12838" class="Symbol">_</a> <a id="12840" class="Symbol">=</a>
  <a id="12844" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="12854" href="/PLFA-zh/Lists/#12293" class="Function">reverse′</a> <a id="12863" class="Symbol">(</a><a id="12864" class="Number">0</a> <a id="12866" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12868" class="Number">1</a> <a id="12870" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12872" class="Number">2</a> <a id="12874" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12876" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12878" class="Symbol">)</a>
  <a id="12882" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12890" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="12896" class="Symbol">(</a><a id="12897" class="Number">0</a> <a id="12899" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12901" class="Number">1</a> <a id="12903" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12905" class="Number">2</a> <a id="12907" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12909" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12911" class="Symbol">)</a> <a id="12913" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="12918" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12926" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="12932" class="Symbol">(</a><a id="12933" class="Number">1</a> <a id="12935" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12937" class="Number">2</a> <a id="12939" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12941" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12943" class="Symbol">)</a> <a id="12945" class="Symbol">(</a><a id="12946" class="Number">0</a> <a id="12948" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12950" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12952" class="Symbol">)</a>
  <a id="12956" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="12964" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="12970" class="Symbol">(</a><a id="12971" class="Number">2</a> <a id="12973" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12975" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12977" class="Symbol">)</a> <a id="12979" class="Symbol">(</a><a id="12980" class="Number">1</a> <a id="12982" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12984" class="Number">0</a> <a id="12986" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="12988" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="12990" class="Symbol">)</a>
  <a id="12994" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="13002" href="/PLFA-zh/Lists/#10689" class="Function">shunt</a> <a id="13008" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="13011" class="Symbol">(</a><a id="13012" class="Number">2</a> <a id="13014" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13016" class="Number">1</a> <a id="13018" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13020" class="Number">0</a> <a id="13022" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13024" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="13026" class="Symbol">)</a>
  <a id="13030" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="13038" class="Number">2</a> <a id="13040" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13042" class="Number">1</a> <a id="13044" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13046" class="Number">0</a> <a id="13048" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13050" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="13055" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Now the time to reverse a list is linear in the length of the list.</p>

<h2 id="Map">Map</h2>

<p>Map applies a function to every element of a list to generate a corresponding list.
Map is an example of a <em>higher-order function</em>, one which takes a function as an
argument or returns a function as a result:</p>
<pre class="Agda"><a id="map"></a><a id="13374" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13378" class="Symbol">:</a> <a id="13380" class="Symbol">∀</a> <a id="13382" class="Symbol">{</a><a id="13383" href="/PLFA-zh/Lists/#13383" class="Bound">A</a> <a id="13385" href="/PLFA-zh/Lists/#13385" class="Bound">B</a> <a id="13387" class="Symbol">:</a> <a id="13389" class="PrimitiveType">Set</a><a id="13392" class="Symbol">}</a> <a id="13394" class="Symbol">→</a> <a id="13396" class="Symbol">(</a><a id="13397" href="/PLFA-zh/Lists/#13383" class="Bound">A</a> <a id="13399" class="Symbol">→</a> <a id="13401" href="/PLFA-zh/Lists/#13385" class="Bound">B</a><a id="13402" class="Symbol">)</a> <a id="13404" class="Symbol">→</a> <a id="13406" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="13411" href="/PLFA-zh/Lists/#13383" class="Bound">A</a> <a id="13413" class="Symbol">→</a> <a id="13415" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="13420" href="/PLFA-zh/Lists/#13385" class="Bound">B</a>
<a id="13422" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13426" href="/PLFA-zh/Lists/#13426" class="Bound">f</a> <a id="13428" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>        <a id="13438" class="Symbol">=</a>  <a id="13441" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="13444" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13448" href="/PLFA-zh/Lists/#13448" class="Bound">f</a> <a id="13450" class="Symbol">(</a><a id="13451" href="/PLFA-zh/Lists/#13451" class="Bound">x</a> <a id="13453" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13455" href="/PLFA-zh/Lists/#13455" class="Bound">xs</a><a id="13457" class="Symbol">)</a>  <a id="13460" class="Symbol">=</a>  <a id="13463" href="/PLFA-zh/Lists/#13448" class="Bound">f</a> <a id="13465" href="/PLFA-zh/Lists/#13451" class="Bound">x</a> <a id="13467" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13469" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13473" href="/PLFA-zh/Lists/#13448" class="Bound">f</a> <a id="13475" href="/PLFA-zh/Lists/#13455" class="Bound">xs</a></pre>
<p>Map of the empty list is the empty list.
Map of a non-empty list yields a list
with head the same as the function applied to the head of the given list,
and tail the same as map of the function applied to the tail of the given list.</p>

<p>Here is an example showing how to use map to increment every element of a list:</p>
<pre class="Agda"><a id="13816" href="/PLFA-zh/Lists/#13816" class="Function">_</a> <a id="13818" class="Symbol">:</a> <a id="13820" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13824" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13828" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="13830" class="Number">0</a> <a id="13832" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="13834" class="Number">1</a> <a id="13836" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="13838" class="Number">2</a> <a id="13840" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="13842" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="13844" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="13846" class="Number">1</a> <a id="13848" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="13850" class="Number">2</a> <a id="13852" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="13854" class="Number">3</a> <a id="13856" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="13858" class="Symbol">_</a> <a id="13860" class="Symbol">=</a>
  <a id="13864" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="13874" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13878" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13882" class="Symbol">(</a><a id="13883" class="Number">0</a> <a id="13885" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13887" class="Number">1</a> <a id="13889" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13891" class="Number">2</a> <a id="13893" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13895" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="13897" class="Symbol">)</a>
  <a id="13901" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="13909" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13913" class="Number">0</a> <a id="13915" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13917" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13921" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13925" class="Symbol">(</a><a id="13926" class="Number">1</a> <a id="13928" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13930" class="Number">2</a> <a id="13932" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13934" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="13936" class="Symbol">)</a>
  <a id="13940" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="13948" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13952" class="Number">0</a> <a id="13954" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13956" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13960" class="Number">1</a> <a id="13962" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13964" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="13968" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13972" class="Symbol">(</a><a id="13973" class="Number">2</a> <a id="13975" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13977" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="13979" class="Symbol">)</a>
  <a id="13983" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="13991" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13995" class="Number">0</a> <a id="13997" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="13999" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14003" class="Number">1</a> <a id="14005" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14007" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14011" class="Number">2</a> <a id="14013" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14015" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="14019" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14023" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="14028" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14036" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14040" class="Number">0</a> <a id="14042" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14044" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14048" class="Number">1</a> <a id="14050" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14052" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14056" class="Number">2</a> <a id="14058" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14060" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="14065" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14073" class="Number">1</a> <a id="14075" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14077" class="Number">2</a> <a id="14079" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14081" class="Number">3</a> <a id="14083" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="14085" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="14090" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Map requires time linear in the length of the list.</p>

<p>It is often convenient to exploit currying by applying
map to a function to yield a new function, and at a later
point applying the resulting function:</p>
<pre class="Agda"><a id="sucs"></a><a id="14321" href="/PLFA-zh/Lists/#14321" class="Function">sucs</a> <a id="14326" class="Symbol">:</a> <a id="14328" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="14333" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="14335" class="Symbol">→</a> <a id="14337" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="14342" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="14344" href="/PLFA-zh/Lists/#14321" class="Function">sucs</a> <a id="14349" class="Symbol">=</a> <a id="14351" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="14355" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a>

<a id="14360" href="/PLFA-zh/Lists/#14360" class="Function">_</a> <a id="14362" class="Symbol">:</a> <a id="14364" href="/PLFA-zh/Lists/#14321" class="Function">sucs</a> <a id="14369" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="14371" class="Number">0</a> <a id="14373" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14375" class="Number">1</a> <a id="14377" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14379" class="Number">2</a> <a id="14381" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a> <a id="14383" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="14385" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="14387" class="Number">1</a> <a id="14389" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14391" class="Number">2</a> <a id="14393" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14395" class="Number">3</a> <a id="14397" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="14399" class="Symbol">_</a> <a id="14401" class="Symbol">=</a>
  <a id="14405" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="14415" href="/PLFA-zh/Lists/#14321" class="Function">sucs</a> <a id="14420" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="14422" class="Number">0</a> <a id="14424" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14426" class="Number">1</a> <a id="14428" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14430" class="Number">2</a> <a id="14432" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
  <a id="14436" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14444" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="14448" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14452" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="14454" class="Number">0</a> <a id="14456" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14458" class="Number">1</a> <a id="14460" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14462" class="Number">2</a> <a id="14464" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
  <a id="14468" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="14476" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="14478" class="Number">1</a> <a id="14480" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14482" class="Number">2</a> <a id="14484" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="14486" class="Number">3</a> <a id="14488" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
  <a id="14492" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<p>Any type that is parameterised on another type, such as lists, has a
corresponding map, which accepts a function and returns a function
from the type parameterised on the domain of the function to the type
parameterised on the range of the function. Further, a type that is
parameterised on <em>n</em> types will have a map that is parameterised on
<em>n</em> functions.</p>

<h4 id="exercise-map-compose">Exercise <code class="highlighter-rouge">map-compose</code></h4>

<p>Prove that the map of a composition is equal to the composition of two maps:</p>
<pre class="Agda"><a id="14984" class="Keyword">postulate</a>
  <a id="map-compose"></a><a id="14996" href="/PLFA-zh/Lists/#14996" class="Postulate">map-compose</a> <a id="15008" class="Symbol">:</a> <a id="15010" class="Symbol">∀</a> <a id="15012" class="Symbol">{</a><a id="15013" href="/PLFA-zh/Lists/#15013" class="Bound">A</a> <a id="15015" href="/PLFA-zh/Lists/#15015" class="Bound">B</a> <a id="15017" href="/PLFA-zh/Lists/#15017" class="Bound">C</a> <a id="15019" class="Symbol">:</a> <a id="15021" class="PrimitiveType">Set</a><a id="15024" class="Symbol">}</a> <a id="15026" class="Symbol">{</a><a id="15027" href="/PLFA-zh/Lists/#15027" class="Bound">f</a> <a id="15029" class="Symbol">:</a> <a id="15031" href="/PLFA-zh/Lists/#15013" class="Bound">A</a> <a id="15033" class="Symbol">→</a> <a id="15035" href="/PLFA-zh/Lists/#15015" class="Bound">B</a><a id="15036" class="Symbol">}</a> <a id="15038" class="Symbol">{</a><a id="15039" href="/PLFA-zh/Lists/#15039" class="Bound">g</a> <a id="15041" class="Symbol">:</a> <a id="15043" href="/PLFA-zh/Lists/#15015" class="Bound">B</a> <a id="15045" class="Symbol">→</a> <a id="15047" href="/PLFA-zh/Lists/#15017" class="Bound">C</a><a id="15048" class="Symbol">}</a>
    <a id="15054" class="Symbol">→</a> <a id="15056" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15060" class="Symbol">(</a><a id="15061" href="/PLFA-zh/Lists/#15039" class="Bound">g</a> <a id="15063" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="15065" href="/PLFA-zh/Lists/#15027" class="Bound">f</a><a id="15066" class="Symbol">)</a> <a id="15068" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="15070" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15074" href="/PLFA-zh/Lists/#15039" class="Bound">g</a> <a id="15076" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="15078" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15082" href="/PLFA-zh/Lists/#15027" class="Bound">f</a></pre>
<p>The last step of the proof requires extensionality.</p>

<h4 id="exercise-map--commute">Exercise <code class="highlighter-rouge">map-++-commute</code></h4>

<p>Prove the following relationship between map and append:</p>
<pre class="Agda"><a id="15250" class="Keyword">postulate</a>
  <a id="map-++-commute"></a><a id="15262" href="/PLFA-zh/Lists/#15262" class="Postulate">map-++-commute</a> <a id="15277" class="Symbol">:</a> <a id="15279" class="Symbol">∀</a> <a id="15281" class="Symbol">{</a><a id="15282" href="/PLFA-zh/Lists/#15282" class="Bound">A</a> <a id="15284" href="/PLFA-zh/Lists/#15284" class="Bound">B</a> <a id="15286" class="Symbol">:</a> <a id="15288" class="PrimitiveType">Set</a><a id="15291" class="Symbol">}</a> <a id="15293" class="Symbol">{</a><a id="15294" href="/PLFA-zh/Lists/#15294" class="Bound">f</a> <a id="15296" class="Symbol">:</a> <a id="15298" href="/PLFA-zh/Lists/#15282" class="Bound">A</a> <a id="15300" class="Symbol">→</a> <a id="15302" href="/PLFA-zh/Lists/#15284" class="Bound">B</a><a id="15303" class="Symbol">}</a> <a id="15305" class="Symbol">{</a><a id="15306" href="/PLFA-zh/Lists/#15306" class="Bound">xs</a> <a id="15309" href="/PLFA-zh/Lists/#15309" class="Bound">ys</a> <a id="15312" class="Symbol">:</a> <a id="15314" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="15319" href="/PLFA-zh/Lists/#15282" class="Bound">A</a><a id="15320" class="Symbol">}</a>
   <a id="15325" class="Symbol">→</a>  <a id="15328" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15332" href="/PLFA-zh/Lists/#15294" class="Bound">f</a> <a id="15334" class="Symbol">(</a><a id="15335" href="/PLFA-zh/Lists/#15306" class="Bound">xs</a> <a id="15338" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="15341" href="/PLFA-zh/Lists/#15309" class="Bound">ys</a><a id="15343" class="Symbol">)</a> <a id="15345" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="15347" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15351" href="/PLFA-zh/Lists/#15294" class="Bound">f</a> <a id="15353" href="/PLFA-zh/Lists/#15306" class="Bound">xs</a> <a id="15356" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="15359" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="15363" href="/PLFA-zh/Lists/#15294" class="Bound">f</a> <a id="15365" href="/PLFA-zh/Lists/#15309" class="Bound">ys</a></pre>

<h4 id="exercise-map-tree">Exercise <code class="highlighter-rouge">map-Tree</code></h4>

<p>Define a type of trees with leaves of type <code class="highlighter-rouge">A</code> and internal
nodes of type <code class="highlighter-rouge">B</code>:</p>
<pre class="Agda"><a id="15498" class="Keyword">data</a> <a id="Tree"></a><a id="15503" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15508" class="Symbol">(</a><a id="15509" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15511" href="/PLFA-zh/Lists/#15511" class="Bound">B</a> <a id="15513" class="Symbol">:</a> <a id="15515" class="PrimitiveType">Set</a><a id="15518" class="Symbol">)</a> <a id="15520" class="Symbol">:</a> <a id="15522" class="PrimitiveType">Set</a> <a id="15526" class="Keyword">where</a>
  <a id="Tree.leaf"></a><a id="15534" href="/PLFA-zh/Lists/#15534" class="InductiveConstructor">leaf</a> <a id="15539" class="Symbol">:</a> <a id="15541" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15543" class="Symbol">→</a> <a id="15545" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15550" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15552" href="/PLFA-zh/Lists/#15511" class="Bound">B</a>
  <a id="Tree.node"></a><a id="15556" href="/PLFA-zh/Lists/#15556" class="InductiveConstructor">node</a> <a id="15561" class="Symbol">:</a> <a id="15563" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15568" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15570" href="/PLFA-zh/Lists/#15511" class="Bound">B</a> <a id="15572" class="Symbol">→</a> <a id="15574" href="/PLFA-zh/Lists/#15511" class="Bound">B</a> <a id="15576" class="Symbol">→</a> <a id="15578" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15583" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15585" href="/PLFA-zh/Lists/#15511" class="Bound">B</a> <a id="15587" class="Symbol">→</a> <a id="15589" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15594" href="/PLFA-zh/Lists/#15509" class="Bound">A</a> <a id="15596" href="/PLFA-zh/Lists/#15511" class="Bound">B</a></pre>
<p>Define a suitable map operator over trees:</p>
<pre class="Agda"><a id="15665" class="Keyword">postulate</a>
  <a id="map-Tree"></a><a id="15677" href="/PLFA-zh/Lists/#15677" class="Postulate">map-Tree</a> <a id="15686" class="Symbol">:</a> <a id="15688" class="Symbol">∀</a> <a id="15690" class="Symbol">{</a><a id="15691" href="/PLFA-zh/Lists/#15691" class="Bound">A</a> <a id="15693" href="/PLFA-zh/Lists/#15693" class="Bound">B</a> <a id="15695" href="/PLFA-zh/Lists/#15695" class="Bound">C</a> <a id="15697" href="/PLFA-zh/Lists/#15697" class="Bound">D</a> <a id="15699" class="Symbol">:</a> <a id="15701" class="PrimitiveType">Set</a><a id="15704" class="Symbol">}</a>
    <a id="15710" class="Symbol">→</a> <a id="15712" class="Symbol">(</a><a id="15713" href="/PLFA-zh/Lists/#15691" class="Bound">A</a> <a id="15715" class="Symbol">→</a> <a id="15717" href="/PLFA-zh/Lists/#15695" class="Bound">C</a><a id="15718" class="Symbol">)</a> <a id="15720" class="Symbol">→</a> <a id="15722" class="Symbol">(</a><a id="15723" href="/PLFA-zh/Lists/#15693" class="Bound">B</a> <a id="15725" class="Symbol">→</a> <a id="15727" href="/PLFA-zh/Lists/#15697" class="Bound">D</a><a id="15728" class="Symbol">)</a> <a id="15730" class="Symbol">→</a> <a id="15732" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15737" href="/PLFA-zh/Lists/#15691" class="Bound">A</a> <a id="15739" href="/PLFA-zh/Lists/#15693" class="Bound">B</a> <a id="15741" class="Symbol">→</a> <a id="15743" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="15748" href="/PLFA-zh/Lists/#15695" class="Bound">C</a> <a id="15750" href="/PLFA-zh/Lists/#15697" class="Bound">D</a></pre>

<h2 id="Fold">Fold</h2>

<p>Fold takes an operator and a value, and uses the operator to combine
each of the elements of the list, taking the given value as the result
for the empty list:</p>
<pre class="Agda"><a id="foldr"></a><a id="15955" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="15961" class="Symbol">:</a> <a id="15963" class="Symbol">∀</a> <a id="15965" class="Symbol">{</a><a id="15966" href="/PLFA-zh/Lists/#15966" class="Bound">A</a> <a id="15968" href="/PLFA-zh/Lists/#15968" class="Bound">B</a> <a id="15970" class="Symbol">:</a> <a id="15972" class="PrimitiveType">Set</a><a id="15975" class="Symbol">}</a> <a id="15977" class="Symbol">→</a> <a id="15979" class="Symbol">(</a><a id="15980" href="/PLFA-zh/Lists/#15966" class="Bound">A</a> <a id="15982" class="Symbol">→</a> <a id="15984" href="/PLFA-zh/Lists/#15968" class="Bound">B</a> <a id="15986" class="Symbol">→</a> <a id="15988" href="/PLFA-zh/Lists/#15968" class="Bound">B</a><a id="15989" class="Symbol">)</a> <a id="15991" class="Symbol">→</a> <a id="15993" href="/PLFA-zh/Lists/#15968" class="Bound">B</a> <a id="15995" class="Symbol">→</a> <a id="15997" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="16002" href="/PLFA-zh/Lists/#15966" class="Bound">A</a> <a id="16004" class="Symbol">→</a> <a id="16006" href="/PLFA-zh/Lists/#15968" class="Bound">B</a>
<a id="16008" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16014" href="/PLFA-zh/Lists/#16014" class="Bound Operator">_⊗_</a> <a id="16018" href="/PLFA-zh/Lists/#16018" class="Bound">e</a> <a id="16020" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>        <a id="16030" class="Symbol">=</a>  <a id="16033" href="/PLFA-zh/Lists/#16018" class="Bound">e</a>
<a id="16035" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16041" href="/PLFA-zh/Lists/#16041" class="Bound Operator">_⊗_</a> <a id="16045" href="/PLFA-zh/Lists/#16045" class="Bound">e</a> <a id="16047" class="Symbol">(</a><a id="16048" href="/PLFA-zh/Lists/#16048" class="Bound">x</a> <a id="16050" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16052" href="/PLFA-zh/Lists/#16052" class="Bound">xs</a><a id="16054" class="Symbol">)</a>  <a id="16057" class="Symbol">=</a>  <a id="16060" href="/PLFA-zh/Lists/#16048" class="Bound">x</a> <a id="16062" href="/PLFA-zh/Lists/#16041" class="Bound Operator">⊗</a> <a id="16064" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16070" href="/PLFA-zh/Lists/#16041" class="Bound Operator">_⊗_</a> <a id="16074" href="/PLFA-zh/Lists/#16045" class="Bound">e</a> <a id="16076" href="/PLFA-zh/Lists/#16052" class="Bound">xs</a></pre>
<p>Fold of the empty list is the given value.
Fold of a non-empty list uses the operator to combine
the head of the list and the fold of the tail of the list.</p>

<p>Here is an example showing how to use fold to find the sum of a list:</p>
<pre class="Agda"><a id="16330" href="/PLFA-zh/Lists/#16330" class="Function">_</a> <a id="16332" class="Symbol">:</a> <a id="16334" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16340" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16344" class="Number">0</a> <a id="16346" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="16348" class="Number">1</a> <a id="16350" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16352" class="Number">2</a> <a id="16354" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16356" class="Number">3</a> <a id="16358" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16360" class="Number">4</a> <a id="16362" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a> <a id="16364" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16366" class="Number">10</a>
<a id="16369" class="Symbol">_</a> <a id="16371" class="Symbol">=</a>
  <a id="16375" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="16385" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16391" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16395" class="Number">0</a> <a id="16397" class="Symbol">(</a><a id="16398" class="Number">1</a> <a id="16400" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16402" class="Number">2</a> <a id="16404" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16406" class="Number">3</a> <a id="16408" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16410" class="Number">4</a> <a id="16412" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16414" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="16416" class="Symbol">)</a>
  <a id="16420" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16428" class="Number">1</a> <a id="16430" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16432" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16438" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16442" class="Number">0</a> <a id="16444" class="Symbol">(</a><a id="16445" class="Number">2</a> <a id="16447" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16449" class="Number">3</a> <a id="16451" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16453" class="Number">4</a> <a id="16455" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16457" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="16459" class="Symbol">)</a>
  <a id="16463" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16471" class="Number">1</a> <a id="16473" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16475" class="Symbol">(</a><a id="16476" class="Number">2</a> <a id="16478" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16480" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16486" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16490" class="Number">0</a> <a id="16492" class="Symbol">(</a><a id="16493" class="Number">3</a> <a id="16495" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16497" class="Number">4</a> <a id="16499" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16501" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="16503" class="Symbol">))</a>
  <a id="16508" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16516" class="Number">1</a> <a id="16518" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16520" class="Symbol">(</a><a id="16521" class="Number">2</a> <a id="16523" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16525" class="Symbol">(</a><a id="16526" class="Number">3</a> <a id="16528" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16530" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16536" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16540" class="Number">0</a> <a id="16542" class="Symbol">(</a><a id="16543" class="Number">4</a> <a id="16545" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="16547" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="16549" class="Symbol">)))</a>
  <a id="16555" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16563" class="Number">1</a> <a id="16565" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16567" class="Symbol">(</a><a id="16568" class="Number">2</a> <a id="16570" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16572" class="Symbol">(</a><a id="16573" class="Number">3</a> <a id="16575" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16577" class="Symbol">(</a><a id="16578" class="Number">4</a> <a id="16580" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16582" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16588" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16592" class="Number">0</a> <a id="16594" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a><a id="16596" class="Symbol">)))</a>
  <a id="16602" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16610" class="Number">1</a> <a id="16612" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16614" class="Symbol">(</a><a id="16615" class="Number">2</a> <a id="16617" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16619" class="Symbol">(</a><a id="16620" class="Number">3</a> <a id="16622" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16624" class="Symbol">(</a><a id="16625" class="Number">4</a> <a id="16627" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="16629" class="Number">0</a><a id="16630" class="Symbol">)))</a>
  <a id="16636" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>
<p>Fold requires time linear in the length of the list.</p>

<p>It is often convenient to exploit currying by applying
fold to an operator and a value to yield a new function,
and at a later point applying the resulting function:</p>
<pre class="Agda"><a id="sum"></a><a id="16882" href="/PLFA-zh/Lists/#16882" class="Function">sum</a> <a id="16886" class="Symbol">:</a> <a id="16888" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="16893" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="16895" class="Symbol">→</a> <a id="16897" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="16899" href="/PLFA-zh/Lists/#16882" class="Function">sum</a> <a id="16903" class="Symbol">=</a> <a id="16905" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="16911" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="16915" class="Number">0</a>

<a id="16918" href="/PLFA-zh/Lists/#16918" class="Function">_</a> <a id="16920" class="Symbol">:</a> <a id="16922" href="/PLFA-zh/Lists/#16882" class="Function">sum</a> <a id="16926" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="16928" class="Number">1</a> <a id="16930" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16932" class="Number">2</a> <a id="16934" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16936" class="Number">3</a> <a id="16938" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16940" class="Number">4</a> <a id="16942" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a> <a id="16944" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16946" class="Number">10</a>
<a id="16949" class="Symbol">_</a> <a id="16951" class="Symbol">=</a>
  <a id="16955" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="16965" href="/PLFA-zh/Lists/#16882" class="Function">sum</a> <a id="16969" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="16971" class="Number">1</a> <a id="16973" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16975" class="Number">2</a> <a id="16977" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16979" class="Number">3</a> <a id="16981" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="16983" class="Number">4</a> <a id="16985" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a>
  <a id="16989" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="16997" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="17003" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="17007" class="Number">0</a> <a id="17009" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="17011" class="Number">1</a> <a id="17013" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="17015" class="Number">2</a> <a id="17017" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="17019" class="Number">3</a> <a id="17021" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="17023" class="Number">4</a> <a id="17025" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a>
  <a id="17029" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="17037" class="Number">10</a>
  <a id="17042" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<p>Just as the list type has two constructors, <code class="highlighter-rouge">[]</code> and <code class="highlighter-rouge">_∷_</code>,
so the fold function takes two arguments, <code class="highlighter-rouge">e</code> and <code class="highlighter-rouge">_⊗_</code>
(in addition to the list argument).
In general, a data type with <em>n</em> constructors will have
a corresponding fold function that takes <em>n</em> arguments.</p>

<h4 id="exercise-product-recommended">Exercise <code class="highlighter-rouge">product</code> (recommended)</h4>

<p>Use fold to define a function to find the product of a list of numbers.
For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>product [ 1 , 2 , 3 , 4 ] ≡ 24
</code></pre></div></div>

<pre class="Agda"><a id="17495" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-foldr--recommended">Exercise <code class="highlighter-rouge">foldr-++</code> (recommended)</h4>

<p>Show that fold and append are related as follows:</p>
<pre class="Agda"><a id="17633" class="Keyword">postulate</a>
  <a id="foldr-++"></a><a id="17645" href="/PLFA-zh/Lists/#17645" class="Postulate">foldr-++</a> <a id="17654" class="Symbol">:</a> <a id="17656" class="Symbol">∀</a> <a id="17658" class="Symbol">{</a><a id="17659" href="/PLFA-zh/Lists/#17659" class="Bound">A</a> <a id="17661" href="/PLFA-zh/Lists/#17661" class="Bound">B</a> <a id="17663" class="Symbol">:</a> <a id="17665" class="PrimitiveType">Set</a><a id="17668" class="Symbol">}</a> <a id="17670" class="Symbol">(</a><a id="17671" href="/PLFA-zh/Lists/#17671" class="Bound Operator">_⊗_</a> <a id="17675" class="Symbol">:</a> <a id="17677" href="/PLFA-zh/Lists/#17659" class="Bound">A</a> <a id="17679" class="Symbol">→</a> <a id="17681" href="/PLFA-zh/Lists/#17661" class="Bound">B</a> <a id="17683" class="Symbol">→</a> <a id="17685" href="/PLFA-zh/Lists/#17661" class="Bound">B</a><a id="17686" class="Symbol">)</a> <a id="17688" class="Symbol">(</a><a id="17689" href="/PLFA-zh/Lists/#17689" class="Bound">e</a> <a id="17691" class="Symbol">:</a> <a id="17693" href="/PLFA-zh/Lists/#17661" class="Bound">B</a><a id="17694" class="Symbol">)</a> <a id="17696" class="Symbol">(</a><a id="17697" href="/PLFA-zh/Lists/#17697" class="Bound">xs</a> <a id="17700" href="/PLFA-zh/Lists/#17700" class="Bound">ys</a> <a id="17703" class="Symbol">:</a> <a id="17705" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="17710" href="/PLFA-zh/Lists/#17659" class="Bound">A</a><a id="17711" class="Symbol">)</a> <a id="17713" class="Symbol">→</a>
    <a id="17719" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="17725" href="/PLFA-zh/Lists/#17671" class="Bound Operator">_⊗_</a> <a id="17729" href="/PLFA-zh/Lists/#17689" class="Bound">e</a> <a id="17731" class="Symbol">(</a><a id="17732" href="/PLFA-zh/Lists/#17697" class="Bound">xs</a> <a id="17735" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="17738" href="/PLFA-zh/Lists/#17700" class="Bound">ys</a><a id="17740" class="Symbol">)</a> <a id="17742" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17744" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="17750" href="/PLFA-zh/Lists/#17671" class="Bound Operator">_⊗_</a> <a id="17754" class="Symbol">(</a><a id="17755" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="17761" href="/PLFA-zh/Lists/#17671" class="Bound Operator">_⊗_</a> <a id="17765" href="/PLFA-zh/Lists/#17689" class="Bound">e</a> <a id="17767" href="/PLFA-zh/Lists/#17700" class="Bound">ys</a><a id="17769" class="Symbol">)</a> <a id="17771" href="/PLFA-zh/Lists/#17697" class="Bound">xs</a></pre>

<h4 id="exercise-map-is-foldr">Exercise <code class="highlighter-rouge">map-is-foldr</code></h4>

<p>Show that map can be defined using fold:</p>
<pre class="Agda"><a id="17871" class="Keyword">postulate</a>
  <a id="map-is-foldr"></a><a id="17883" href="/PLFA-zh/Lists/#17883" class="Postulate">map-is-foldr</a> <a id="17896" class="Symbol">:</a> <a id="17898" class="Symbol">∀</a> <a id="17900" class="Symbol">{</a><a id="17901" href="/PLFA-zh/Lists/#17901" class="Bound">A</a> <a id="17903" href="/PLFA-zh/Lists/#17903" class="Bound">B</a> <a id="17905" class="Symbol">:</a> <a id="17907" class="PrimitiveType">Set</a><a id="17910" class="Symbol">}</a> <a id="17912" class="Symbol">{</a><a id="17913" href="/PLFA-zh/Lists/#17913" class="Bound">f</a> <a id="17915" class="Symbol">:</a> <a id="17917" href="/PLFA-zh/Lists/#17901" class="Bound">A</a> <a id="17919" class="Symbol">→</a> <a id="17921" href="/PLFA-zh/Lists/#17903" class="Bound">B</a><a id="17922" class="Symbol">}</a> <a id="17924" class="Symbol">→</a>
    <a id="17930" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="17934" href="/PLFA-zh/Lists/#17913" class="Bound">f</a> <a id="17936" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17938" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="17944" class="Symbol">(λ</a> <a id="17947" href="/PLFA-zh/Lists/#17947" class="Bound">x</a> <a id="17949" href="/PLFA-zh/Lists/#17949" class="Bound">xs</a> <a id="17952" class="Symbol">→</a> <a id="17954" href="/PLFA-zh/Lists/#17913" class="Bound">f</a> <a id="17956" href="/PLFA-zh/Lists/#17947" class="Bound">x</a> <a id="17958" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="17960" href="/PLFA-zh/Lists/#17949" class="Bound">xs</a><a id="17962" class="Symbol">)</a> <a id="17964" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a></pre>
<p>This requires extensionality.</p>

<h4 id="exercise-fold-tree">Exercise <code class="highlighter-rouge">fold-Tree</code></h4>

<p>Define a suitable fold function for the type of trees given earlier:</p>
<pre class="Agda"><a id="18118" class="Keyword">postulate</a>
  <a id="fold-Tree"></a><a id="18130" href="/PLFA-zh/Lists/#18130" class="Postulate">fold-Tree</a> <a id="18140" class="Symbol">:</a> <a id="18142" class="Symbol">∀</a> <a id="18144" class="Symbol">{</a><a id="18145" href="/PLFA-zh/Lists/#18145" class="Bound">A</a> <a id="18147" href="/PLFA-zh/Lists/#18147" class="Bound">B</a> <a id="18149" href="/PLFA-zh/Lists/#18149" class="Bound">C</a> <a id="18151" class="Symbol">:</a> <a id="18153" class="PrimitiveType">Set</a><a id="18156" class="Symbol">}</a>
    <a id="18162" class="Symbol">→</a> <a id="18164" class="Symbol">(</a><a id="18165" href="/PLFA-zh/Lists/#18145" class="Bound">A</a> <a id="18167" class="Symbol">→</a> <a id="18169" href="/PLFA-zh/Lists/#18149" class="Bound">C</a><a id="18170" class="Symbol">)</a> <a id="18172" class="Symbol">→</a> <a id="18174" class="Symbol">(</a><a id="18175" href="/PLFA-zh/Lists/#18149" class="Bound">C</a> <a id="18177" class="Symbol">→</a> <a id="18179" href="/PLFA-zh/Lists/#18147" class="Bound">B</a> <a id="18181" class="Symbol">→</a> <a id="18183" href="/PLFA-zh/Lists/#18149" class="Bound">C</a> <a id="18185" class="Symbol">→</a> <a id="18187" href="/PLFA-zh/Lists/#18149" class="Bound">C</a><a id="18188" class="Symbol">)</a> <a id="18190" class="Symbol">→</a> <a id="18192" href="/PLFA-zh/Lists/#15503" class="Datatype">Tree</a> <a id="18197" href="/PLFA-zh/Lists/#18145" class="Bound">A</a> <a id="18199" href="/PLFA-zh/Lists/#18147" class="Bound">B</a> <a id="18201" class="Symbol">→</a> <a id="18203" href="/PLFA-zh/Lists/#18149" class="Bound">C</a></pre>

<pre class="Agda"><a id="18230" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-map-is-fold-tree">Exercise <code class="highlighter-rouge">map-is-fold-Tree</code></h4>

<p>Demonstrate an analogue of <code class="highlighter-rouge">map-is-foldr</code> for the type of trees.</p>

<pre class="Agda"><a id="18378" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-sum-downfrom-stretch">Exercise <code class="highlighter-rouge">sum-downFrom</code> (stretch)</h4>

<p>Define a function that counts down as follows:</p>
<pre class="Agda"><a id="downFrom"></a><a id="18513" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18522" class="Symbol">:</a> <a id="18524" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="18526" class="Symbol">→</a> <a id="18528" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="18533" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="18535" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18544" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>     <a id="18553" class="Symbol">=</a>  <a id="18556" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="18559" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18568" class="Symbol">(</a><a id="18569" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="18573" href="/PLFA-zh/Lists/#18573" class="Bound">n</a><a id="18574" class="Symbol">)</a>  <a id="18577" class="Symbol">=</a>  <a id="18580" href="/PLFA-zh/Lists/#18573" class="Bound">n</a> <a id="18582" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="18584" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18593" href="/PLFA-zh/Lists/#18573" class="Bound">n</a></pre>
<p>For example:</p>
<pre class="Agda"><a id="18632" href="/PLFA-zh/Lists/#18632" class="Function">_</a> <a id="18634" class="Symbol">:</a> <a id="18636" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18645" class="Number">3</a> <a id="18647" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="18649" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="18651" class="Number">2</a> <a id="18653" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="18655" class="Number">1</a> <a id="18657" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="18659" class="Number">0</a> <a id="18661" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="18663" class="Symbol">_</a> <a id="18665" class="Symbol">=</a> <a id="18667" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Prove that the sum of the numbers <code class="highlighter-rouge">(n - 1) + ⋯ + 0</code> is
equal to <code class="highlighter-rouge">n * (n ∸ 1) / 2</code>:</p>
<pre class="Agda"><a id="18779" class="Keyword">postulate</a>
  <a id="sum-downFrom"></a><a id="18791" href="/PLFA-zh/Lists/#18791" class="Postulate">sum-downFrom</a> <a id="18804" class="Symbol">:</a> <a id="18806" class="Symbol">∀</a> <a id="18808" class="Symbol">(</a><a id="18809" href="/PLFA-zh/Lists/#18809" class="Bound">n</a> <a id="18811" class="Symbol">:</a> <a id="18813" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="18814" class="Symbol">)</a>
    <a id="18820" class="Symbol">→</a> <a id="18822" href="/PLFA-zh/Lists/#16882" class="Function">sum</a> <a id="18826" class="Symbol">(</a><a id="18827" href="/PLFA-zh/Lists/#18513" class="Function">downFrom</a> <a id="18836" href="/PLFA-zh/Lists/#18809" class="Bound">n</a><a id="18837" class="Symbol">)</a> <a id="18839" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="18841" class="Number">2</a> <a id="18843" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="18845" href="/PLFA-zh/Lists/#18809" class="Bound">n</a> <a id="18847" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="18849" class="Symbol">(</a><a id="18850" href="/PLFA-zh/Lists/#18809" class="Bound">n</a> <a id="18852" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#320" class="Primitive Operator">∸</a> <a id="18854" class="Number">1</a><a id="18855" class="Symbol">)</a></pre>

<h2 id="monoids">Monoids</h2>

<p>Typically when we use a fold the operator is associative and the
value is a left and right identity for the value, meaning that the
operator and the value form a <em>monoid</em>.</p>

<p>We can define a monoid as a suitable record type:</p>
<pre class="Agda"><a id="19118" class="Keyword">record</a> <a id="IsMonoid"></a><a id="19125" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="19134" class="Symbol">{</a><a id="19135" href="/PLFA-zh/Lists/#19135" class="Bound">A</a> <a id="19137" class="Symbol">:</a> <a id="19139" class="PrimitiveType">Set</a><a id="19142" class="Symbol">}</a> <a id="19144" class="Symbol">(</a><a id="19145" href="/PLFA-zh/Lists/#19145" class="Bound Operator">_⊗_</a> <a id="19149" class="Symbol">:</a> <a id="19151" href="/PLFA-zh/Lists/#19135" class="Bound">A</a> <a id="19153" class="Symbol">→</a> <a id="19155" href="/PLFA-zh/Lists/#19135" class="Bound">A</a> <a id="19157" class="Symbol">→</a> <a id="19159" href="/PLFA-zh/Lists/#19135" class="Bound">A</a><a id="19160" class="Symbol">)</a> <a id="19162" class="Symbol">(</a><a id="19163" href="/PLFA-zh/Lists/#19163" class="Bound">e</a> <a id="19165" class="Symbol">:</a> <a id="19167" href="/PLFA-zh/Lists/#19135" class="Bound">A</a><a id="19168" class="Symbol">)</a> <a id="19170" class="Symbol">:</a> <a id="19172" class="PrimitiveType">Set</a> <a id="19176" class="Keyword">where</a>
  <a id="19184" class="Keyword">field</a>
    <a id="IsMonoid.assoc"></a><a id="19194" href="/PLFA-zh/Lists/#19194" class="Field">assoc</a> <a id="19200" class="Symbol">:</a> <a id="19202" class="Symbol">∀</a> <a id="19204" class="Symbol">(</a><a id="19205" href="/PLFA-zh/Lists/#19205" class="Bound">x</a> <a id="19207" href="/PLFA-zh/Lists/#19207" class="Bound">y</a> <a id="19209" href="/PLFA-zh/Lists/#19209" class="Bound">z</a> <a id="19211" class="Symbol">:</a> <a id="19213" href="/PLFA-zh/Lists/#19135" class="Bound">A</a><a id="19214" class="Symbol">)</a> <a id="19216" class="Symbol">→</a> <a id="19218" class="Symbol">(</a><a id="19219" href="/PLFA-zh/Lists/#19205" class="Bound">x</a> <a id="19221" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19223" href="/PLFA-zh/Lists/#19207" class="Bound">y</a><a id="19224" class="Symbol">)</a> <a id="19226" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19228" href="/PLFA-zh/Lists/#19209" class="Bound">z</a> <a id="19230" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19232" href="/PLFA-zh/Lists/#19205" class="Bound">x</a> <a id="19234" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19236" class="Symbol">(</a><a id="19237" href="/PLFA-zh/Lists/#19207" class="Bound">y</a> <a id="19239" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19241" href="/PLFA-zh/Lists/#19209" class="Bound">z</a><a id="19242" class="Symbol">)</a>
    <a id="IsMonoid.identityˡ"></a><a id="19248" href="/PLFA-zh/Lists/#19248" class="Field">identityˡ</a> <a id="19258" class="Symbol">:</a> <a id="19260" class="Symbol">∀</a> <a id="19262" class="Symbol">(</a><a id="19263" href="/PLFA-zh/Lists/#19263" class="Bound">x</a> <a id="19265" class="Symbol">:</a> <a id="19267" href="/PLFA-zh/Lists/#19135" class="Bound">A</a><a id="19268" class="Symbol">)</a> <a id="19270" class="Symbol">→</a> <a id="19272" href="/PLFA-zh/Lists/#19163" class="Bound">e</a> <a id="19274" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19276" href="/PLFA-zh/Lists/#19263" class="Bound">x</a> <a id="19278" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19280" href="/PLFA-zh/Lists/#19263" class="Bound">x</a>
    <a id="IsMonoid.identityʳ"></a><a id="19286" href="/PLFA-zh/Lists/#19286" class="Field">identityʳ</a> <a id="19296" class="Symbol">:</a> <a id="19298" class="Symbol">∀</a> <a id="19300" class="Symbol">(</a><a id="19301" href="/PLFA-zh/Lists/#19301" class="Bound">x</a> <a id="19303" class="Symbol">:</a> <a id="19305" href="/PLFA-zh/Lists/#19135" class="Bound">A</a><a id="19306" class="Symbol">)</a> <a id="19308" class="Symbol">→</a> <a id="19310" href="/PLFA-zh/Lists/#19301" class="Bound">x</a> <a id="19312" href="/PLFA-zh/Lists/#19145" class="Bound Operator">⊗</a> <a id="19314" href="/PLFA-zh/Lists/#19163" class="Bound">e</a> <a id="19316" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19318" href="/PLFA-zh/Lists/#19301" class="Bound">x</a>

<a id="19321" class="Keyword">open</a> <a id="19326" href="/PLFA-zh/Lists/#19125" class="Module">IsMonoid</a></pre>

<p>As examples, sum and zero, multiplication and one, and append and the empty
list, are all examples of monoids:</p>
<pre class="Agda"><a id="+-monoid"></a><a id="19471" href="/PLFA-zh/Lists/#19471" class="Function">+-monoid</a> <a id="19480" class="Symbol">:</a> <a id="19482" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="19491" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a> <a id="19495" class="Number">0</a>
<a id="19497" href="/PLFA-zh/Lists/#19471" class="Function">+-monoid</a> <a id="19506" class="Symbol">=</a>
  <a id="19510" class="Keyword">record</a>
    <a id="19521" class="Symbol">{</a> <a id="19523" class="Field">assoc</a> <a id="19529" class="Symbol">=</a> <a id="19531" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9375" class="Function">+-assoc</a>
    <a id="19543" class="Symbol">;</a> <a id="19545" class="Field">identityˡ</a> <a id="19555" class="Symbol">=</a> <a id="19557" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9476" class="Function">+-identityˡ</a>
    <a id="19573" class="Symbol">;</a> <a id="19575" class="Field">identityʳ</a> <a id="19585" class="Symbol">=</a> <a id="19587" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9531" class="Function">+-identityʳ</a>
    <a id="19603" class="Symbol">}</a>

<a id="*-monoid"></a><a id="19606" href="/PLFA-zh/Lists/#19606" class="Function">*-monoid</a> <a id="19615" class="Symbol">:</a> <a id="19617" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="19626" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a> <a id="19630" class="Number">1</a>
<a id="19632" href="/PLFA-zh/Lists/#19606" class="Function">*-monoid</a> <a id="19641" class="Symbol">=</a>
  <a id="19645" class="Keyword">record</a>
    <a id="19656" class="Symbol">{</a> <a id="19658" class="Field">assoc</a> <a id="19664" class="Symbol">=</a> <a id="19666" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#15493" class="Function">*-assoc</a>
    <a id="19678" class="Symbol">;</a> <a id="19680" class="Field">identityˡ</a> <a id="19690" class="Symbol">=</a> <a id="19692" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#14397" class="Function">*-identityˡ</a>
    <a id="19708" class="Symbol">;</a> <a id="19710" class="Field">identityʳ</a> <a id="19720" class="Symbol">=</a> <a id="19722" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#14461" class="Function">*-identityʳ</a>
    <a id="19738" class="Symbol">}</a>

<a id="++-monoid"></a><a id="19741" href="/PLFA-zh/Lists/#19741" class="Function">++-monoid</a> <a id="19751" class="Symbol">:</a> <a id="19753" class="Symbol">∀</a> <a id="19755" class="Symbol">{</a><a id="19756" href="/PLFA-zh/Lists/#19756" class="Bound">A</a> <a id="19758" class="Symbol">:</a> <a id="19760" class="PrimitiveType">Set</a><a id="19763" class="Symbol">}</a> <a id="19765" class="Symbol">→</a> <a id="19767" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="19776" class="Symbol">{</a><a id="19777" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="19782" href="/PLFA-zh/Lists/#19756" class="Bound">A</a><a id="19783" class="Symbol">}</a> <a id="19785" href="/PLFA-zh/Lists/#3576" class="Function Operator">_++_</a> <a id="19790" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
<a id="19793" href="/PLFA-zh/Lists/#19741" class="Function">++-monoid</a> <a id="19803" class="Symbol">=</a>
  <a id="19807" class="Keyword">record</a>
    <a id="19818" class="Symbol">{</a> <a id="19820" class="Field">assoc</a> <a id="19826" class="Symbol">=</a> <a id="19828" href="/PLFA-zh/Lists/#4672" class="Function">++-assoc</a>
    <a id="19841" class="Symbol">;</a> <a id="19843" class="Field">identityˡ</a> <a id="19853" class="Symbol">=</a> <a id="19855" href="/PLFA-zh/Lists/#5884" class="Function">++-identityˡ</a>
    <a id="19872" class="Symbol">;</a> <a id="19874" class="Field">identityʳ</a> <a id="19884" class="Symbol">=</a> <a id="19886" href="/PLFA-zh/Lists/#6078" class="Function">++-identityʳ</a>
    <a id="19903" class="Symbol">}</a></pre>

<p>If <code class="highlighter-rouge">_⊗_</code> and <code class="highlighter-rouge">e</code> form a monoid, then we can re-express fold on the
same operator and an arbitrary value:</p>
<pre class="Agda"><a id="foldr-monoid"></a><a id="20035" href="/PLFA-zh/Lists/#20035" class="Function">foldr-monoid</a> <a id="20048" class="Symbol">:</a> <a id="20050" class="Symbol">∀</a> <a id="20052" class="Symbol">{</a><a id="20053" href="/PLFA-zh/Lists/#20053" class="Bound">A</a> <a id="20055" class="Symbol">:</a> <a id="20057" class="PrimitiveType">Set</a><a id="20060" class="Symbol">}</a> <a id="20062" class="Symbol">(</a><a id="20063" href="/PLFA-zh/Lists/#20063" class="Bound Operator">_⊗_</a> <a id="20067" class="Symbol">:</a> <a id="20069" href="/PLFA-zh/Lists/#20053" class="Bound">A</a> <a id="20071" class="Symbol">→</a> <a id="20073" href="/PLFA-zh/Lists/#20053" class="Bound">A</a> <a id="20075" class="Symbol">→</a> <a id="20077" href="/PLFA-zh/Lists/#20053" class="Bound">A</a><a id="20078" class="Symbol">)</a> <a id="20080" class="Symbol">(</a><a id="20081" href="/PLFA-zh/Lists/#20081" class="Bound">e</a> <a id="20083" class="Symbol">:</a> <a id="20085" href="/PLFA-zh/Lists/#20053" class="Bound">A</a><a id="20086" class="Symbol">)</a> <a id="20088" class="Symbol">→</a> <a id="20090" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="20099" href="/PLFA-zh/Lists/#20063" class="Bound Operator">_⊗_</a> <a id="20103" href="/PLFA-zh/Lists/#20081" class="Bound">e</a> <a id="20105" class="Symbol">→</a>
  <a id="20109" class="Symbol">∀</a> <a id="20111" class="Symbol">(</a><a id="20112" href="/PLFA-zh/Lists/#20112" class="Bound">xs</a> <a id="20115" class="Symbol">:</a> <a id="20117" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="20122" href="/PLFA-zh/Lists/#20053" class="Bound">A</a><a id="20123" class="Symbol">)</a> <a id="20125" class="Symbol">(</a><a id="20126" href="/PLFA-zh/Lists/#20126" class="Bound">y</a> <a id="20128" class="Symbol">:</a> <a id="20130" href="/PLFA-zh/Lists/#20053" class="Bound">A</a><a id="20131" class="Symbol">)</a> <a id="20133" class="Symbol">→</a> <a id="20135" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20141" href="/PLFA-zh/Lists/#20063" class="Bound Operator">_⊗_</a> <a id="20145" href="/PLFA-zh/Lists/#20126" class="Bound">y</a> <a id="20147" href="/PLFA-zh/Lists/#20112" class="Bound">xs</a> <a id="20150" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20152" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20158" href="/PLFA-zh/Lists/#20063" class="Bound Operator">_⊗_</a> <a id="20162" href="/PLFA-zh/Lists/#20081" class="Bound">e</a> <a id="20164" href="/PLFA-zh/Lists/#20112" class="Bound">xs</a> <a id="20167" href="/PLFA-zh/Lists/#20063" class="Bound Operator">⊗</a> <a id="20169" href="/PLFA-zh/Lists/#20126" class="Bound">y</a>
<a id="20171" href="/PLFA-zh/Lists/#20035" class="Function">foldr-monoid</a> <a id="20184" href="/PLFA-zh/Lists/#20184" class="Bound Operator">_⊗_</a> <a id="20188" href="/PLFA-zh/Lists/#20188" class="Bound">e</a> <a id="20190" href="/PLFA-zh/Lists/#20190" class="Bound">⊗-monoid</a> <a id="20199" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="20202" href="/PLFA-zh/Lists/#20202" class="Bound">y</a> <a id="20204" class="Symbol">=</a>
  <a id="20208" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="20218" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20224" href="/PLFA-zh/Lists/#20184" class="Bound Operator">_⊗_</a> <a id="20228" href="/PLFA-zh/Lists/#20202" class="Bound">y</a> <a id="20230" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="20235" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="20243" href="/PLFA-zh/Lists/#20202" class="Bound">y</a>
  <a id="20247" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="20250" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="20254" class="Symbol">(</a><a id="20255" href="/PLFA-zh/Lists/#19248" class="Field">identityˡ</a> <a id="20265" href="/PLFA-zh/Lists/#20190" class="Bound">⊗-monoid</a> <a id="20274" href="/PLFA-zh/Lists/#20202" class="Bound">y</a><a id="20275" class="Symbol">)</a> <a id="20277" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="20283" class="Symbol">(</a><a id="20284" href="/PLFA-zh/Lists/#20188" class="Bound">e</a> <a id="20286" href="/PLFA-zh/Lists/#20184" class="Bound Operator">⊗</a> <a id="20288" href="/PLFA-zh/Lists/#20202" class="Bound">y</a><a id="20289" class="Symbol">)</a>
  <a id="20293" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="20301" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20307" href="/PLFA-zh/Lists/#20184" class="Bound Operator">_⊗_</a> <a id="20311" href="/PLFA-zh/Lists/#20188" class="Bound">e</a> <a id="20313" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="20316" href="/PLFA-zh/Lists/#20184" class="Bound Operator">⊗</a> <a id="20318" href="/PLFA-zh/Lists/#20202" class="Bound">y</a>
  <a id="20322" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a>
<a id="20324" href="/PLFA-zh/Lists/#20035" class="Function">foldr-monoid</a> <a id="20337" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20341" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20343" href="/PLFA-zh/Lists/#20343" class="Bound">⊗-monoid</a> <a id="20352" class="Symbol">(</a><a id="20353" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20355" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="20357" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20359" class="Symbol">)</a> <a id="20361" href="/PLFA-zh/Lists/#20361" class="Bound">y</a> <a id="20363" class="Symbol">=</a>
  <a id="20367" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="20377" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20383" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20387" href="/PLFA-zh/Lists/#20361" class="Bound">y</a> <a id="20389" class="Symbol">(</a><a id="20390" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20392" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="20394" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20396" class="Symbol">)</a>
  <a id="20400" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="20408" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20410" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20412" class="Symbol">(</a><a id="20413" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20419" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20423" href="/PLFA-zh/Lists/#20361" class="Bound">y</a> <a id="20425" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20427" class="Symbol">)</a>
  <a id="20431" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="20434" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="20439" class="Symbol">(</a><a id="20440" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20442" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗_</a><a id="20444" class="Symbol">)</a> <a id="20446" class="Symbol">(</a><a id="20447" href="/PLFA-zh/Lists/#20035" class="Function">foldr-monoid</a> <a id="20460" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20464" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20466" href="/PLFA-zh/Lists/#20343" class="Bound">⊗-monoid</a> <a id="20475" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a> <a id="20478" href="/PLFA-zh/Lists/#20361" class="Bound">y</a><a id="20479" class="Symbol">)</a> <a id="20481" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="20487" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20489" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20491" class="Symbol">(</a><a id="20492" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20498" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20502" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20504" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a> <a id="20507" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20509" href="/PLFA-zh/Lists/#20361" class="Bound">y</a><a id="20510" class="Symbol">)</a>
  <a id="20514" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="20517" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a> <a id="20521" class="Symbol">(</a><a id="20522" href="/PLFA-zh/Lists/#19194" class="Field">assoc</a> <a id="20528" href="/PLFA-zh/Lists/#20343" class="Bound">⊗-monoid</a> <a id="20537" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20539" class="Symbol">(</a><a id="20540" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20546" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20550" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20552" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20554" class="Symbol">)</a> <a id="20556" href="/PLFA-zh/Lists/#20361" class="Bound">y</a><a id="20557" class="Symbol">)</a> <a id="20559" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="20565" class="Symbol">(</a><a id="20566" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20568" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20570" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20576" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20580" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20582" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20584" class="Symbol">)</a> <a id="20586" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20588" href="/PLFA-zh/Lists/#20361" class="Bound">y</a>
  <a id="20592" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4134" class="Function Operator">≡⟨⟩</a>
    <a id="20600" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20606" href="/PLFA-zh/Lists/#20337" class="Bound Operator">_⊗_</a> <a id="20610" href="/PLFA-zh/Lists/#20341" class="Bound">e</a> <a id="20612" class="Symbol">(</a><a id="20613" href="/PLFA-zh/Lists/#20353" class="Bound">x</a> <a id="20615" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="20617" href="/PLFA-zh/Lists/#20357" class="Bound">xs</a><a id="20619" class="Symbol">)</a> <a id="20621" href="/PLFA-zh/Lists/#20337" class="Bound Operator">⊗</a> <a id="20623" href="/PLFA-zh/Lists/#20361" class="Bound">y</a>
  <a id="20627" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<p>As a consequence, using a previous exercise, we have the following:</p>
<pre class="Agda"><a id="foldr-monoid-++"></a><a id="20722" href="/PLFA-zh/Lists/#20722" class="Function">foldr-monoid-++</a> <a id="20738" class="Symbol">:</a> <a id="20740" class="Symbol">∀</a> <a id="20742" class="Symbol">{</a><a id="20743" href="/PLFA-zh/Lists/#20743" class="Bound">A</a> <a id="20745" class="Symbol">:</a> <a id="20747" class="PrimitiveType">Set</a><a id="20750" class="Symbol">}</a> <a id="20752" class="Symbol">(</a><a id="20753" href="/PLFA-zh/Lists/#20753" class="Bound Operator">_⊗_</a> <a id="20757" class="Symbol">:</a> <a id="20759" href="/PLFA-zh/Lists/#20743" class="Bound">A</a> <a id="20761" class="Symbol">→</a> <a id="20763" href="/PLFA-zh/Lists/#20743" class="Bound">A</a> <a id="20765" class="Symbol">→</a> <a id="20767" href="/PLFA-zh/Lists/#20743" class="Bound">A</a><a id="20768" class="Symbol">)</a> <a id="20770" class="Symbol">(</a><a id="20771" href="/PLFA-zh/Lists/#20771" class="Bound">e</a> <a id="20773" class="Symbol">:</a> <a id="20775" href="/PLFA-zh/Lists/#20743" class="Bound">A</a><a id="20776" class="Symbol">)</a> <a id="20778" class="Symbol">→</a> <a id="20780" href="/PLFA-zh/Lists/#19125" class="Record">IsMonoid</a> <a id="20789" href="/PLFA-zh/Lists/#20753" class="Bound Operator">_⊗_</a> <a id="20793" href="/PLFA-zh/Lists/#20771" class="Bound">e</a> <a id="20795" class="Symbol">→</a>
  <a id="20799" class="Symbol">∀</a> <a id="20801" class="Symbol">(</a><a id="20802" href="/PLFA-zh/Lists/#20802" class="Bound">xs</a> <a id="20805" href="/PLFA-zh/Lists/#20805" class="Bound">ys</a> <a id="20808" class="Symbol">:</a> <a id="20810" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="20815" href="/PLFA-zh/Lists/#20743" class="Bound">A</a><a id="20816" class="Symbol">)</a> <a id="20818" class="Symbol">→</a> <a id="20820" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20826" href="/PLFA-zh/Lists/#20753" class="Bound Operator">_⊗_</a> <a id="20830" href="/PLFA-zh/Lists/#20771" class="Bound">e</a> <a id="20832" class="Symbol">(</a><a id="20833" href="/PLFA-zh/Lists/#20802" class="Bound">xs</a> <a id="20836" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="20839" href="/PLFA-zh/Lists/#20805" class="Bound">ys</a><a id="20841" class="Symbol">)</a> <a id="20843" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20845" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20851" href="/PLFA-zh/Lists/#20753" class="Bound Operator">_⊗_</a> <a id="20855" href="/PLFA-zh/Lists/#20771" class="Bound">e</a> <a id="20857" href="/PLFA-zh/Lists/#20802" class="Bound">xs</a> <a id="20860" href="/PLFA-zh/Lists/#20753" class="Bound Operator">⊗</a> <a id="20862" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20868" href="/PLFA-zh/Lists/#20753" class="Bound Operator">_⊗_</a> <a id="20872" href="/PLFA-zh/Lists/#20771" class="Bound">e</a> <a id="20874" href="/PLFA-zh/Lists/#20805" class="Bound">ys</a>
<a id="20877" href="/PLFA-zh/Lists/#20722" class="Function">foldr-monoid-++</a> <a id="20893" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="20897" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="20899" href="/PLFA-zh/Lists/#20899" class="Bound">monoid-⊗</a> <a id="20908" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a> <a id="20911" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a> <a id="20914" class="Symbol">=</a>
  <a id="20918" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4076" class="Function Operator">begin</a>
    <a id="20928" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20934" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="20938" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="20940" class="Symbol">(</a><a id="20941" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a> <a id="20944" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="20947" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a><a id="20949" class="Symbol">)</a>
  <a id="20953" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="20956" href="/PLFA-zh/Lists/#17645" class="Postulate">foldr-++</a> <a id="20965" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="20969" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="20971" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a> <a id="20974" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a> <a id="20977" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="20983" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="20989" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="20993" class="Symbol">(</a><a id="20994" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="21000" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="21004" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="21006" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a><a id="21008" class="Symbol">)</a> <a id="21010" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a>
  <a id="21015" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">≡⟨</a> <a id="21018" href="/PLFA-zh/Lists/#20035" class="Function">foldr-monoid</a> <a id="21031" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="21035" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="21037" href="/PLFA-zh/Lists/#20899" class="Bound">monoid-⊗</a> <a id="21046" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a> <a id="21049" class="Symbol">(</a><a id="21050" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="21056" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="21060" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="21062" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a><a id="21064" class="Symbol">)</a> <a id="21066" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4193" class="Function Operator">⟩</a>
    <a id="21072" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="21078" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="21082" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="21084" href="/PLFA-zh/Lists/#20908" class="Bound">xs</a> <a id="21087" href="/PLFA-zh/Lists/#20893" class="Bound Operator">⊗</a> <a id="21089" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="21095" href="/PLFA-zh/Lists/#20893" class="Bound Operator">_⊗_</a> <a id="21099" href="/PLFA-zh/Lists/#20897" class="Bound">e</a> <a id="21101" href="/PLFA-zh/Lists/#20911" class="Bound">ys</a>
  <a id="21106" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#4374" class="Function Operator">∎</a></pre>

<h4 id="exercise-foldl">Exercise <code class="highlighter-rouge">foldl</code></h4>

<p>Define a function <code class="highlighter-rouge">foldl</code> which is analogous to <code class="highlighter-rouge">foldr</code>, but where
operations associate to the left rather than the right.  For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z
</code></pre></div></div>

<pre class="Agda"><a id="21399" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-foldr-monoid-foldl">Exercise <code class="highlighter-rouge">foldr-monoid-foldl</code></h4>

<p>Show that if <code class="highlighter-rouge">_⊗_</code> and <code class="highlighter-rouge">e</code> form a monoid, then <code class="highlighter-rouge">foldr _⊗_ e</code> and
<code class="highlighter-rouge">foldl _⊗_ e</code> always compute the same result.</p>

<pre class="Agda"><a id="21596" class="Comment">-- Your code goes here</a></pre>

<h2 id="All">All</h2>

<p>We can also define predicates over lists. Two of the most important
are <code class="highlighter-rouge">All</code> and <code class="highlighter-rouge">Any</code>.</p>

<p>Predicate <code class="highlighter-rouge">All P</code> holds if predicate <code class="highlighter-rouge">P</code> is satisfied by every element of a list:</p>
<pre class="Agda"><a id="21832" class="Keyword">data</a> <a id="All"></a><a id="21837" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="21841" class="Symbol">{</a><a id="21842" href="/PLFA-zh/Lists/#21842" class="Bound">A</a> <a id="21844" class="Symbol">:</a> <a id="21846" class="PrimitiveType">Set</a><a id="21849" class="Symbol">}</a> <a id="21851" class="Symbol">(</a><a id="21852" href="/PLFA-zh/Lists/#21852" class="Bound">P</a> <a id="21854" class="Symbol">:</a> <a id="21856" href="/PLFA-zh/Lists/#21842" class="Bound">A</a> <a id="21858" class="Symbol">→</a> <a id="21860" class="PrimitiveType">Set</a><a id="21863" class="Symbol">)</a> <a id="21865" class="Symbol">:</a> <a id="21867" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="21872" href="/PLFA-zh/Lists/#21842" class="Bound">A</a> <a id="21874" class="Symbol">→</a> <a id="21876" class="PrimitiveType">Set</a> <a id="21880" class="Keyword">where</a>
  <a id="All.[]"></a><a id="21888" href="/PLFA-zh/Lists/#21888" class="InductiveConstructor">[]</a>  <a id="21892" class="Symbol">:</a> <a id="21894" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="21898" href="/PLFA-zh/Lists/#21852" class="Bound">P</a> <a id="21900" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>
  <a id="All._∷_"></a><a id="21905" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">_∷_</a> <a id="21909" class="Symbol">:</a> <a id="21911" class="Symbol">∀</a> <a id="21913" class="Symbol">{</a><a id="21914" href="/PLFA-zh/Lists/#21914" class="Bound">x</a> <a id="21916" class="Symbol">:</a> <a id="21918" href="/PLFA-zh/Lists/#21842" class="Bound">A</a><a id="21919" class="Symbol">}</a> <a id="21921" class="Symbol">{</a><a id="21922" href="/PLFA-zh/Lists/#21922" class="Bound">xs</a> <a id="21925" class="Symbol">:</a> <a id="21927" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="21932" href="/PLFA-zh/Lists/#21842" class="Bound">A</a><a id="21933" class="Symbol">}</a> <a id="21935" class="Symbol">→</a> <a id="21937" href="/PLFA-zh/Lists/#21852" class="Bound">P</a> <a id="21939" href="/PLFA-zh/Lists/#21914" class="Bound">x</a> <a id="21941" class="Symbol">→</a> <a id="21943" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="21947" href="/PLFA-zh/Lists/#21852" class="Bound">P</a> <a id="21949" href="/PLFA-zh/Lists/#21922" class="Bound">xs</a> <a id="21952" class="Symbol">→</a> <a id="21954" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="21958" href="/PLFA-zh/Lists/#21852" class="Bound">P</a> <a id="21960" class="Symbol">(</a><a id="21961" href="/PLFA-zh/Lists/#21914" class="Bound">x</a> <a id="21963" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="21965" href="/PLFA-zh/Lists/#21922" class="Bound">xs</a><a id="21967" class="Symbol">)</a></pre>
<p>The type has two constructors, reusing the names of the same constructors for lists.
The first asserts that <code class="highlighter-rouge">P</code> holds for every element of the empty list.
The second asserts that if <code class="highlighter-rouge">P</code> holds of the head of a list and for every
element of the tail of a list, then <code class="highlighter-rouge">P</code> holds for every element of the list.
Agda uses types to disambiguate whether the constructor is building
a list or evidence that <code class="highlighter-rouge">All P</code> holds.</p>

<p>For example, <code class="highlighter-rouge">All (_≤ 2)</code> holds of a list where every element is less
than or equal to two.  Recall that <code class="highlighter-rouge">z≤n</code> proves <code class="highlighter-rouge">zero ≤ n</code> for any
<code class="highlighter-rouge">n</code>, and that if <code class="highlighter-rouge">m≤n</code> proves <code class="highlighter-rouge">m ≤ n</code> then <code class="highlighter-rouge">s≤s m≤n</code> proves <code class="highlighter-rouge">suc m ≤
suc n</code>, for any <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>:</p>
<pre class="Agda"><a id="22641" href="/PLFA-zh/Lists/#22641" class="Function">_</a> <a id="22643" class="Symbol">:</a> <a id="22645" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="22649" class="Symbol">(</a><a id="22650" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#845" class="Datatype Operator">_≤</a> <a id="22653" class="Number">2</a><a id="22654" class="Symbol">)</a> <a id="22656" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">[</a> <a id="22658" class="Number">0</a> <a id="22660" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="22662" class="Number">1</a> <a id="22664" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">,</a> <a id="22666" class="Number">2</a> <a id="22668" href="/PLFA-zh/Lists/#2974" class="InductiveConstructor Operator">]</a>
<a id="22670" class="Symbol">_</a> <a id="22672" class="Symbol">=</a> <a id="22674" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a> <a id="22678" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="22680" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="22684" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a> <a id="22688" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="22690" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="22694" class="Symbol">(</a><a id="22695" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#910" class="InductiveConstructor">s≤s</a> <a id="22699" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#868" class="InductiveConstructor">z≤n</a><a id="22702" class="Symbol">)</a> <a id="22704" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="22706" href="/PLFA-zh/Lists/#21888" class="InductiveConstructor">[]</a></pre>
<p>Here <code class="highlighter-rouge">_∷_</code> and <code class="highlighter-rouge">[]</code> are the constructors of <code class="highlighter-rouge">All P</code> rather than of <code class="highlighter-rouge">List A</code>.
The three items are proofs of <code class="highlighter-rouge">0 ≤ 2</code>, <code class="highlighter-rouge">1 ≤ 2</code>, and <code class="highlighter-rouge">2 ≤ 2</code>, respectively.</p>

<p>(One might wonder whether a pattern such as <code class="highlighter-rouge">[_,_,_]</code> can be used to
construct values of type <code class="highlighter-rouge">All</code> as well as type <code class="highlighter-rouge">List</code>, since both use
the same constructors. Indeed it can, so long as both types are in
scope when the pattern is declared.  That’s not the case here, since
<code class="highlighter-rouge">List</code> is defined before <code class="highlighter-rouge">[_,_,_]</code>, but <code class="highlighter-rouge">All</code> is defined later.)</p>

<h2 id="any">Any</h2>

<p>Predicate <code class="highlighter-rouge">Any P</code> holds if predicate <code class="highlighter-rouge">P</code> is satisfied by some element of a list:</p>
<pre class="Agda"><a id="23317" class="Keyword">data</a> <a id="Any"></a><a id="23322" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="23326" class="Symbol">{</a><a id="23327" href="/PLFA-zh/Lists/#23327" class="Bound">A</a> <a id="23329" class="Symbol">:</a> <a id="23331" class="PrimitiveType">Set</a><a id="23334" class="Symbol">}</a> <a id="23336" class="Symbol">(</a><a id="23337" href="/PLFA-zh/Lists/#23337" class="Bound">P</a> <a id="23339" class="Symbol">:</a> <a id="23341" href="/PLFA-zh/Lists/#23327" class="Bound">A</a> <a id="23343" class="Symbol">→</a> <a id="23345" class="PrimitiveType">Set</a><a id="23348" class="Symbol">)</a> <a id="23350" class="Symbol">:</a> <a id="23352" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="23357" href="/PLFA-zh/Lists/#23327" class="Bound">A</a> <a id="23359" class="Symbol">→</a> <a id="23361" class="PrimitiveType">Set</a> <a id="23365" class="Keyword">where</a>
  <a id="Any.here"></a><a id="23373" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a>  <a id="23379" class="Symbol">:</a> <a id="23381" class="Symbol">∀</a> <a id="23383" class="Symbol">{</a><a id="23384" href="/PLFA-zh/Lists/#23384" class="Bound">x</a> <a id="23386" class="Symbol">:</a> <a id="23388" href="/PLFA-zh/Lists/#23327" class="Bound">A</a><a id="23389" class="Symbol">}</a> <a id="23391" class="Symbol">{</a><a id="23392" href="/PLFA-zh/Lists/#23392" class="Bound">xs</a> <a id="23395" class="Symbol">:</a> <a id="23397" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="23402" href="/PLFA-zh/Lists/#23327" class="Bound">A</a><a id="23403" class="Symbol">}</a> <a id="23405" class="Symbol">→</a> <a id="23407" href="/PLFA-zh/Lists/#23337" class="Bound">P</a> <a id="23409" href="/PLFA-zh/Lists/#23384" class="Bound">x</a> <a id="23411" class="Symbol">→</a> <a id="23413" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="23417" href="/PLFA-zh/Lists/#23337" class="Bound">P</a> <a id="23419" class="Symbol">(</a><a id="23420" href="/PLFA-zh/Lists/#23384" class="Bound">x</a> <a id="23422" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="23424" href="/PLFA-zh/Lists/#23392" class="Bound">xs</a><a id="23426" class="Symbol">)</a>
  <a id="Any.there"></a><a id="23430" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="23436" class="Symbol">:</a> <a id="23438" class="Symbol">∀</a> <a id="23440" class="Symbol">{</a><a id="23441" href="/PLFA-zh/Lists/#23441" class="Bound">x</a> <a id="23443" class="Symbol">:</a> <a id="23445" href="/PLFA-zh/Lists/#23327" class="Bound">A</a><a id="23446" class="Symbol">}</a> <a id="23448" class="Symbol">{</a><a id="23449" href="/PLFA-zh/Lists/#23449" class="Bound">xs</a> <a id="23452" class="Symbol">:</a> <a id="23454" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="23459" href="/PLFA-zh/Lists/#23327" class="Bound">A</a><a id="23460" class="Symbol">}</a> <a id="23462" class="Symbol">→</a> <a id="23464" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="23468" href="/PLFA-zh/Lists/#23337" class="Bound">P</a> <a id="23470" href="/PLFA-zh/Lists/#23449" class="Bound">xs</a> <a id="23473" class="Symbol">→</a> <a id="23475" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="23479" href="/PLFA-zh/Lists/#23337" class="Bound">P</a> <a id="23481" class="Symbol">(</a><a id="23482" href="/PLFA-zh/Lists/#23441" class="Bound">x</a> <a id="23484" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="23486" href="/PLFA-zh/Lists/#23449" class="Bound">xs</a><a id="23488" class="Symbol">)</a></pre>
<p>The first constructor provides evidence that the head of the list
satisfies <code class="highlighter-rouge">P</code>, while the second provides evidence that some element of
the tail of the list satisfies <code class="highlighter-rouge">P</code>.  For example, we can define list
membership as follows:</p>
<pre class="Agda"><a id="23743" class="Keyword">infix</a> <a id="23749" class="Number">4</a> <a id="23751" href="/PLFA-zh/Lists/#23760" class="Function Operator">_∈_</a> <a id="23755" href="/PLFA-zh/Lists/#23830" class="Function Operator">_∉_</a>

<a id="_∈_"></a><a id="23760" href="/PLFA-zh/Lists/#23760" class="Function Operator">_∈_</a> <a id="23764" class="Symbol">:</a> <a id="23766" class="Symbol">∀</a> <a id="23768" class="Symbol">{</a><a id="23769" href="/PLFA-zh/Lists/#23769" class="Bound">A</a> <a id="23771" class="Symbol">:</a> <a id="23773" class="PrimitiveType">Set</a><a id="23776" class="Symbol">}</a> <a id="23778" class="Symbol">(</a><a id="23779" href="/PLFA-zh/Lists/#23779" class="Bound">x</a> <a id="23781" class="Symbol">:</a> <a id="23783" href="/PLFA-zh/Lists/#23769" class="Bound">A</a><a id="23784" class="Symbol">)</a> <a id="23786" class="Symbol">(</a><a id="23787" href="/PLFA-zh/Lists/#23787" class="Bound">xs</a> <a id="23790" class="Symbol">:</a> <a id="23792" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="23797" href="/PLFA-zh/Lists/#23769" class="Bound">A</a><a id="23798" class="Symbol">)</a> <a id="23800" class="Symbol">→</a> <a id="23802" class="PrimitiveType">Set</a>
<a id="23806" href="/PLFA-zh/Lists/#23806" class="Bound">x</a> <a id="23808" href="/PLFA-zh/Lists/#23760" class="Function Operator">∈</a> <a id="23810" href="/PLFA-zh/Lists/#23810" class="Bound">xs</a> <a id="23813" class="Symbol">=</a> <a id="23815" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="23819" class="Symbol">(</a><a id="23820" href="/PLFA-zh/Lists/#23806" class="Bound">x</a> <a id="23822" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡_</a><a id="23824" class="Symbol">)</a> <a id="23826" href="/PLFA-zh/Lists/#23810" class="Bound">xs</a>

<a id="_∉_"></a><a id="23830" href="/PLFA-zh/Lists/#23830" class="Function Operator">_∉_</a> <a id="23834" class="Symbol">:</a> <a id="23836" class="Symbol">∀</a> <a id="23838" class="Symbol">{</a><a id="23839" href="/PLFA-zh/Lists/#23839" class="Bound">A</a> <a id="23841" class="Symbol">:</a> <a id="23843" class="PrimitiveType">Set</a><a id="23846" class="Symbol">}</a> <a id="23848" class="Symbol">(</a><a id="23849" href="/PLFA-zh/Lists/#23849" class="Bound">x</a> <a id="23851" class="Symbol">:</a> <a id="23853" href="/PLFA-zh/Lists/#23839" class="Bound">A</a><a id="23854" class="Symbol">)</a> <a id="23856" class="Symbol">(</a><a id="23857" href="/PLFA-zh/Lists/#23857" class="Bound">xs</a> <a id="23860" class="Symbol">:</a> <a id="23862" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="23867" href="/PLFA-zh/Lists/#23839" class="Bound">A</a><a id="23868" class="Symbol">)</a> <a id="23870" class="Symbol">→</a> <a id="23872" class="PrimitiveType">Set</a>
<a id="23876" href="/PLFA-zh/Lists/#23876" class="Bound">x</a> <a id="23878" href="/PLFA-zh/Lists/#23830" class="Function Operator">∉</a> <a id="23880" href="/PLFA-zh/Lists/#23880" class="Bound">xs</a> <a id="23883" class="Symbol">=</a> <a id="23885" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="23887" class="Symbol">(</a><a id="23888" href="/PLFA-zh/Lists/#23876" class="Bound">x</a> <a id="23890" href="/PLFA-zh/Lists/#23760" class="Function Operator">∈</a> <a id="23892" href="/PLFA-zh/Lists/#23880" class="Bound">xs</a><a id="23894" class="Symbol">)</a></pre>
<p>For example, zero is an element of the list <code class="highlighter-rouge">[ 0 , 1 , 0 , 2 ]</code>.  Indeed, we can demonstrate
this fact in two different ways, corresponding to the two different
occurrences of zero in the list, as the first element and as the third element:</p>
<pre class="Agda"><a id="24161" href="/PLFA-zh/Lists/#24161" class="Function">_</a> <a id="24163" class="Symbol">:</a> <a id="24165" class="Number">0</a> <a id="24167" href="/PLFA-zh/Lists/#23760" class="Function Operator">∈</a> <a id="24169" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="24171" class="Number">0</a> <a id="24173" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24175" class="Number">1</a> <a id="24177" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24179" class="Number">0</a> <a id="24181" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24183" class="Number">2</a> <a id="24185" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a>
<a id="24187" class="Symbol">_</a> <a id="24189" class="Symbol">=</a> <a id="24191" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24196" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="24202" href="/PLFA-zh/Lists/#24202" class="Function">_</a> <a id="24204" class="Symbol">:</a> <a id="24206" class="Number">0</a> <a id="24208" href="/PLFA-zh/Lists/#23760" class="Function Operator">∈</a> <a id="24210" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="24212" class="Number">0</a> <a id="24214" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24216" class="Number">1</a> <a id="24218" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24220" class="Number">0</a> <a id="24222" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24224" class="Number">2</a> <a id="24226" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a>
<a id="24228" class="Symbol">_</a> <a id="24230" class="Symbol">=</a> <a id="24232" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24238" class="Symbol">(</a><a id="24239" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24245" class="Symbol">(</a><a id="24246" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24251" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="24255" class="Symbol">))</a></pre>
<p>Further, we can demonstrate that three is not in the list, because
any possible proof that it is in the list leads to contradiction:</p>
<pre class="Agda"><a id="not-in"></a><a id="24415" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24422" class="Symbol">:</a> <a id="24424" class="Number">3</a> <a id="24426" href="/PLFA-zh/Lists/#23830" class="Function Operator">∉</a> <a id="24428" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">[</a> <a id="24430" class="Number">0</a> <a id="24432" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24434" class="Number">1</a> <a id="24436" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24438" class="Number">0</a> <a id="24440" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">,</a> <a id="24442" class="Number">2</a> <a id="24444" href="/PLFA-zh/Lists/#3013" class="InductiveConstructor Operator">]</a>
<a id="24446" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24453" class="Symbol">(</a><a id="24454" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24459" class="Symbol">())</a>
<a id="24463" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24470" class="Symbol">(</a><a id="24471" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24477" class="Symbol">(</a><a id="24478" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24483" class="Symbol">()))</a>
<a id="24488" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24495" class="Symbol">(</a><a id="24496" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24502" class="Symbol">(</a><a id="24503" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24509" class="Symbol">(</a><a id="24510" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24515" class="Symbol">())))</a>
<a id="24521" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24528" class="Symbol">(</a><a id="24529" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24535" class="Symbol">(</a><a id="24536" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24542" class="Symbol">(</a><a id="24543" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24549" class="Symbol">(</a><a id="24550" href="/PLFA-zh/Lists/#23373" class="InductiveConstructor">here</a> <a id="24555" class="Symbol">()))))</a>
<a id="24562" href="/PLFA-zh/Lists/#24415" class="Function">not-in</a> <a id="24569" class="Symbol">(</a><a id="24570" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24576" class="Symbol">(</a><a id="24577" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24583" class="Symbol">(</a><a id="24584" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24590" class="Symbol">(</a><a id="24591" href="/PLFA-zh/Lists/#23430" class="InductiveConstructor">there</a> <a id="24597" class="Symbol">()))))</a></pre>
<p>The five occurrences of <code class="highlighter-rouge">()</code> attest to the fact that there is no
possible evidence for <code class="highlighter-rouge">3 ≡ 0</code>, <code class="highlighter-rouge">3 ≡ 1</code>, <code class="highlighter-rouge">3 ≡ 0</code>, <code class="highlighter-rouge">3 ≡ 2</code>, and
<code class="highlighter-rouge">3 ∈ []</code>, respectively.</p>

<h2 id="all-and-append">All and append</h2>

<p>A predicate holds for every element of one list appended to another if and
only if it holds for every element of each list:</p>
<pre class="Agda"><a id="All-++-⇔"></a><a id="24923" href="/PLFA-zh/Lists/#24923" class="Function">All-++-⇔</a> <a id="24932" class="Symbol">:</a> <a id="24934" class="Symbol">∀</a> <a id="24936" class="Symbol">{</a><a id="24937" href="/PLFA-zh/Lists/#24937" class="Bound">A</a> <a id="24939" class="Symbol">:</a> <a id="24941" class="PrimitiveType">Set</a><a id="24944" class="Symbol">}</a> <a id="24946" class="Symbol">{</a><a id="24947" href="/PLFA-zh/Lists/#24947" class="Bound">P</a> <a id="24949" class="Symbol">:</a> <a id="24951" href="/PLFA-zh/Lists/#24937" class="Bound">A</a> <a id="24953" class="Symbol">→</a> <a id="24955" class="PrimitiveType">Set</a><a id="24958" class="Symbol">}</a> <a id="24960" class="Symbol">(</a><a id="24961" href="/PLFA-zh/Lists/#24961" class="Bound">xs</a> <a id="24964" href="/PLFA-zh/Lists/#24964" class="Bound">ys</a> <a id="24967" class="Symbol">:</a> <a id="24969" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="24974" href="/PLFA-zh/Lists/#24937" class="Bound">A</a><a id="24975" class="Symbol">)</a> <a id="24977" class="Symbol">→</a>
  <a id="24981" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="24985" href="/PLFA-zh/Lists/#24947" class="Bound">P</a> <a id="24987" class="Symbol">(</a><a id="24988" href="/PLFA-zh/Lists/#24961" class="Bound">xs</a> <a id="24991" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="24994" href="/PLFA-zh/Lists/#24964" class="Bound">ys</a><a id="24996" class="Symbol">)</a> <a id="24998" href="/PLFA-zh/Isomorphism/#15055" class="Record Operator">⇔</a> <a id="25000" class="Symbol">(</a><a id="25001" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25005" href="/PLFA-zh/Lists/#24947" class="Bound">P</a> <a id="25007" href="/PLFA-zh/Lists/#24961" class="Bound">xs</a> <a id="25010" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="25012" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25016" href="/PLFA-zh/Lists/#24947" class="Bound">P</a> <a id="25018" href="/PLFA-zh/Lists/#24964" class="Bound">ys</a><a id="25020" class="Symbol">)</a>
<a id="25022" href="/PLFA-zh/Lists/#24923" class="Function">All-++-⇔</a> <a id="25031" href="/PLFA-zh/Lists/#25031" class="Bound">xs</a> <a id="25034" href="/PLFA-zh/Lists/#25034" class="Bound">ys</a> <a id="25037" class="Symbol">=</a>
  <a id="25041" class="Keyword">record</a>
    <a id="25052" class="Symbol">{</a> <a id="25054" class="Field">to</a>       <a id="25063" class="Symbol">=</a>  <a id="25066" href="/PLFA-zh/Lists/#25121" class="Function">to</a> <a id="25069" href="/PLFA-zh/Lists/#25031" class="Bound">xs</a> <a id="25072" href="/PLFA-zh/Lists/#25034" class="Bound">ys</a>
    <a id="25079" class="Symbol">;</a> <a id="25081" class="Field">from</a>     <a id="25090" class="Symbol">=</a>  <a id="25093" href="/PLFA-zh/Lists/#25346" class="Function">from</a> <a id="25098" href="/PLFA-zh/Lists/#25031" class="Bound">xs</a> <a id="25101" href="/PLFA-zh/Lists/#25034" class="Bound">ys</a>
    <a id="25108" class="Symbol">}</a>
  <a id="25112" class="Keyword">where</a>

  <a id="25121" href="/PLFA-zh/Lists/#25121" class="Function">to</a> <a id="25124" class="Symbol">:</a> <a id="25126" class="Symbol">∀</a> <a id="25128" class="Symbol">{</a><a id="25129" href="/PLFA-zh/Lists/#25129" class="Bound">A</a> <a id="25131" class="Symbol">:</a> <a id="25133" class="PrimitiveType">Set</a><a id="25136" class="Symbol">}</a> <a id="25138" class="Symbol">{</a><a id="25139" href="/PLFA-zh/Lists/#25139" class="Bound">P</a> <a id="25141" class="Symbol">:</a> <a id="25143" href="/PLFA-zh/Lists/#25129" class="Bound">A</a> <a id="25145" class="Symbol">→</a> <a id="25147" class="PrimitiveType">Set</a><a id="25150" class="Symbol">}</a> <a id="25152" class="Symbol">(</a><a id="25153" href="/PLFA-zh/Lists/#25153" class="Bound">xs</a> <a id="25156" href="/PLFA-zh/Lists/#25156" class="Bound">ys</a> <a id="25159" class="Symbol">:</a> <a id="25161" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="25166" href="/PLFA-zh/Lists/#25129" class="Bound">A</a><a id="25167" class="Symbol">)</a> <a id="25169" class="Symbol">→</a>
    <a id="25175" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25179" href="/PLFA-zh/Lists/#25139" class="Bound">P</a> <a id="25181" class="Symbol">(</a><a id="25182" href="/PLFA-zh/Lists/#25153" class="Bound">xs</a> <a id="25185" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="25188" href="/PLFA-zh/Lists/#25156" class="Bound">ys</a><a id="25190" class="Symbol">)</a> <a id="25192" class="Symbol">→</a> <a id="25194" class="Symbol">(</a><a id="25195" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25199" href="/PLFA-zh/Lists/#25139" class="Bound">P</a> <a id="25201" href="/PLFA-zh/Lists/#25153" class="Bound">xs</a> <a id="25204" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="25206" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25210" href="/PLFA-zh/Lists/#25139" class="Bound">P</a> <a id="25212" href="/PLFA-zh/Lists/#25156" class="Bound">ys</a><a id="25214" class="Symbol">)</a>
  <a id="25218" href="/PLFA-zh/Lists/#25121" class="Function">to</a> <a id="25221" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="25224" href="/PLFA-zh/Lists/#25224" class="Bound">ys</a> <a id="25227" href="/PLFA-zh/Lists/#25227" class="Bound">Pys</a> <a id="25231" class="Symbol">=</a> <a id="25233" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25235" href="/PLFA-zh/Lists/#21888" class="InductiveConstructor">[]</a> <a id="25238" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25240" href="/PLFA-zh/Lists/#25227" class="Bound">Pys</a> <a id="25244" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
  <a id="25248" href="/PLFA-zh/Lists/#25121" class="Function">to</a> <a id="25251" class="Symbol">(</a><a id="25252" href="/PLFA-zh/Lists/#25252" class="Bound">x</a> <a id="25254" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="25256" href="/PLFA-zh/Lists/#25256" class="Bound">xs</a><a id="25258" class="Symbol">)</a> <a id="25260" href="/PLFA-zh/Lists/#25260" class="Bound">ys</a> <a id="25263" class="Symbol">(</a><a id="25264" href="/PLFA-zh/Lists/#25264" class="Bound">Px</a> <a id="25267" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="25269" href="/PLFA-zh/Lists/#25269" class="Bound">Pxs++ys</a><a id="25276" class="Symbol">)</a> <a id="25278" class="Keyword">with</a> <a id="25283" href="/PLFA-zh/Lists/#25121" class="Function">to</a> <a id="25286" href="/PLFA-zh/Lists/#25256" class="Bound">xs</a> <a id="25289" href="/PLFA-zh/Lists/#25260" class="Bound">ys</a> <a id="25292" href="/PLFA-zh/Lists/#25269" class="Bound">Pxs++ys</a>
  <a id="25302" class="Symbol">...</a> <a id="25306" class="Symbol">|</a> <a id="25308" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25310" href="/PLFA-zh/Lists/#25310" class="Bound">Pxs</a> <a id="25314" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25316" href="/PLFA-zh/Lists/#25316" class="Bound">Pys</a> <a id="25320" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="25322" class="Symbol">=</a> <a id="25324" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25326" class="Bound">Px</a> <a id="25329" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="25331" href="/PLFA-zh/Lists/#25310" class="Bound">Pxs</a> <a id="25335" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25337" href="/PLFA-zh/Lists/#25316" class="Bound">Pys</a> <a id="25341" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>

  <a id="25346" href="/PLFA-zh/Lists/#25346" class="Function">from</a> <a id="25351" class="Symbol">:</a> <a id="25353" class="Symbol">∀</a> <a id="25355" class="Symbol">{</a> <a id="25357" href="/PLFA-zh/Lists/#25357" class="Bound">A</a> <a id="25359" class="Symbol">:</a> <a id="25361" class="PrimitiveType">Set</a><a id="25364" class="Symbol">}</a> <a id="25366" class="Symbol">{</a><a id="25367" href="/PLFA-zh/Lists/#25367" class="Bound">P</a> <a id="25369" class="Symbol">:</a> <a id="25371" href="/PLFA-zh/Lists/#25357" class="Bound">A</a> <a id="25373" class="Symbol">→</a> <a id="25375" class="PrimitiveType">Set</a><a id="25378" class="Symbol">}</a> <a id="25380" class="Symbol">(</a><a id="25381" href="/PLFA-zh/Lists/#25381" class="Bound">xs</a> <a id="25384" href="/PLFA-zh/Lists/#25384" class="Bound">ys</a> <a id="25387" class="Symbol">:</a> <a id="25389" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="25394" href="/PLFA-zh/Lists/#25357" class="Bound">A</a><a id="25395" class="Symbol">)</a> <a id="25397" class="Symbol">→</a>
    <a id="25403" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25407" href="/PLFA-zh/Lists/#25367" class="Bound">P</a> <a id="25409" href="/PLFA-zh/Lists/#25381" class="Bound">xs</a> <a id="25412" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="25414" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25418" href="/PLFA-zh/Lists/#25367" class="Bound">P</a> <a id="25420" href="/PLFA-zh/Lists/#25384" class="Bound">ys</a> <a id="25423" class="Symbol">→</a> <a id="25425" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="25429" href="/PLFA-zh/Lists/#25367" class="Bound">P</a> <a id="25431" class="Symbol">(</a><a id="25432" href="/PLFA-zh/Lists/#25381" class="Bound">xs</a> <a id="25435" href="/PLFA-zh/Lists/#3576" class="Function Operator">++</a> <a id="25438" href="/PLFA-zh/Lists/#25384" class="Bound">ys</a><a id="25440" class="Symbol">)</a>
  <a id="25444" href="/PLFA-zh/Lists/#25346" class="Function">from</a> <a id="25449" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a> <a id="25452" href="/PLFA-zh/Lists/#25452" class="Bound">ys</a> <a id="25455" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25457" href="/PLFA-zh/Lists/#21888" class="InductiveConstructor">[]</a> <a id="25460" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25462" href="/PLFA-zh/Lists/#25462" class="Bound">Pys</a> <a id="25466" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="25468" class="Symbol">=</a> <a id="25470" href="/PLFA-zh/Lists/#25462" class="Bound">Pys</a>
  <a id="25476" href="/PLFA-zh/Lists/#25346" class="Function">from</a> <a id="25481" class="Symbol">(</a><a id="25482" href="/PLFA-zh/Lists/#25482" class="Bound">x</a> <a id="25484" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="25486" href="/PLFA-zh/Lists/#25486" class="Bound">xs</a><a id="25488" class="Symbol">)</a> <a id="25490" href="/PLFA-zh/Lists/#25490" class="Bound">ys</a> <a id="25493" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25495" href="/PLFA-zh/Lists/#25495" class="Bound">Px</a> <a id="25498" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="25500" href="/PLFA-zh/Lists/#25500" class="Bound">Pxs</a> <a id="25504" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25506" href="/PLFA-zh/Lists/#25506" class="Bound">Pys</a> <a id="25510" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="25512" class="Symbol">=</a>  <a id="25515" href="/PLFA-zh/Lists/#25495" class="Bound">Px</a> <a id="25518" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="25520" href="/PLFA-zh/Lists/#25346" class="Function">from</a> <a id="25525" href="/PLFA-zh/Lists/#25486" class="Bound">xs</a> <a id="25528" href="/PLFA-zh/Lists/#25490" class="Bound">ys</a> <a id="25531" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="25533" href="/PLFA-zh/Lists/#25500" class="Bound">Pxs</a> <a id="25537" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="25539" href="/PLFA-zh/Lists/#25506" class="Bound">Pys</a> <a id="25543" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<h4 id="exercise-any---recommended">Exercise <code class="highlighter-rouge">Any-++-⇔</code> (recommended)</h4>

<p>Prove a result similar to <code class="highlighter-rouge">All-++-↔</code>, but with <code class="highlighter-rouge">Any</code> in place of <code class="highlighter-rouge">All</code>, and a suitable
replacement for <code class="highlighter-rouge">_×_</code>.  As a consequence, demonstrate an equivalence relating
<code class="highlighter-rouge">_∈_</code> and <code class="highlighter-rouge">_++_</code>.</p>

<pre class="Agda"><a id="25794" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-all---stretch">Exercise <code class="highlighter-rouge">All-++-≃</code> (stretch)</h4>

<p>Show that the equivalence <code class="highlighter-rouge">All-++-⇔</code> can be extended to an isomorphism.</p>

<pre class="Agda"><a id="25951" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-anyall-stretch">Exercise <code class="highlighter-rouge">¬Any≃All¬</code> (stretch)</h4>

<p>First generalise composition to arbitrary levels, using
<a href="/PLFA-zh/Equality/#unipoly">universe polymorphism</a>:</p>
<pre class="Agda"><a id="_∘′_"></a><a id="26140" href="/PLFA-zh/Lists/#26140" class="Function Operator">_∘′_</a> <a id="26145" class="Symbol">:</a> <a id="26147" class="Symbol">∀</a> <a id="26149" class="Symbol">{</a><a id="26150" href="/PLFA-zh/Lists/#26150" class="Bound">ℓ₁</a> <a id="26153" href="/PLFA-zh/Lists/#26153" class="Bound">ℓ₂</a> <a id="26156" href="/PLFA-zh/Lists/#26156" class="Bound">ℓ₃</a> <a id="26159" class="Symbol">:</a> <a id="26161" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#408" class="Postulate">Level</a><a id="26166" class="Symbol">}</a> <a id="26168" class="Symbol">{</a><a id="26169" href="/PLFA-zh/Lists/#26169" class="Bound">A</a> <a id="26171" class="Symbol">:</a> <a id="26173" class="PrimitiveType">Set</a> <a id="26177" href="/PLFA-zh/Lists/#26150" class="Bound">ℓ₁</a><a id="26179" class="Symbol">}</a> <a id="26181" class="Symbol">{</a><a id="26182" href="/PLFA-zh/Lists/#26182" class="Bound">B</a> <a id="26184" class="Symbol">:</a> <a id="26186" class="PrimitiveType">Set</a> <a id="26190" href="/PLFA-zh/Lists/#26153" class="Bound">ℓ₂</a><a id="26192" class="Symbol">}</a> <a id="26194" class="Symbol">{</a><a id="26195" href="/PLFA-zh/Lists/#26195" class="Bound">C</a> <a id="26197" class="Symbol">:</a> <a id="26199" class="PrimitiveType">Set</a> <a id="26203" href="/PLFA-zh/Lists/#26156" class="Bound">ℓ₃</a><a id="26205" class="Symbol">}</a>
  <a id="26209" class="Symbol">→</a> <a id="26211" class="Symbol">(</a><a id="26212" href="/PLFA-zh/Lists/#26182" class="Bound">B</a> <a id="26214" class="Symbol">→</a> <a id="26216" href="/PLFA-zh/Lists/#26195" class="Bound">C</a><a id="26217" class="Symbol">)</a> <a id="26219" class="Symbol">→</a> <a id="26221" class="Symbol">(</a><a id="26222" href="/PLFA-zh/Lists/#26169" class="Bound">A</a> <a id="26224" class="Symbol">→</a> <a id="26226" href="/PLFA-zh/Lists/#26182" class="Bound">B</a><a id="26227" class="Symbol">)</a> <a id="26229" class="Symbol">→</a> <a id="26231" href="/PLFA-zh/Lists/#26169" class="Bound">A</a> <a id="26233" class="Symbol">→</a> <a id="26235" href="/PLFA-zh/Lists/#26195" class="Bound">C</a>
<a id="26237" class="Symbol">(</a><a id="26238" href="/PLFA-zh/Lists/#26238" class="Bound">g</a> <a id="26240" href="/PLFA-zh/Lists/#26140" class="Function Operator">∘′</a> <a id="26243" href="/PLFA-zh/Lists/#26243" class="Bound">f</a><a id="26244" class="Symbol">)</a> <a id="26246" href="/PLFA-zh/Lists/#26246" class="Bound">x</a>  <a id="26249" class="Symbol">=</a>  <a id="26252" href="/PLFA-zh/Lists/#26238" class="Bound">g</a> <a id="26254" class="Symbol">(</a><a id="26255" href="/PLFA-zh/Lists/#26243" class="Bound">f</a> <a id="26257" href="/PLFA-zh/Lists/#26246" class="Bound">x</a><a id="26258" class="Symbol">)</a></pre>

<pre class="Agda"><a id="26285" class="Comment">-- Your code goes here</a></pre>

<p>Show that <code class="highlighter-rouge">Any</code> and <code class="highlighter-rouge">All</code> satisfy a version of De Morgan’s Law:</p>
<pre class="Agda"><a id="26397" class="Keyword">postulate</a>
  <a id="¬Any≃All¬"></a><a id="26409" href="/PLFA-zh/Lists/#26409" class="Postulate">¬Any≃All¬</a> <a id="26419" class="Symbol">:</a> <a id="26421" class="Symbol">∀</a> <a id="26423" class="Symbol">{</a><a id="26424" href="/PLFA-zh/Lists/#26424" class="Bound">A</a> <a id="26426" class="Symbol">:</a> <a id="26428" class="PrimitiveType">Set</a><a id="26431" class="Symbol">}</a> <a id="26433" class="Symbol">(</a><a id="26434" href="/PLFA-zh/Lists/#26434" class="Bound">P</a> <a id="26436" class="Symbol">:</a> <a id="26438" href="/PLFA-zh/Lists/#26424" class="Bound">A</a> <a id="26440" class="Symbol">→</a> <a id="26442" class="PrimitiveType">Set</a><a id="26445" class="Symbol">)</a> <a id="26447" class="Symbol">(</a><a id="26448" href="/PLFA-zh/Lists/#26448" class="Bound">xs</a> <a id="26451" class="Symbol">:</a> <a id="26453" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="26458" href="/PLFA-zh/Lists/#26424" class="Bound">A</a><a id="26459" class="Symbol">)</a>
    <a id="26465" class="Symbol">→</a> <a id="26467" class="Symbol">(</a><a id="26468" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="26471" href="/PLFA-zh/Lists/#26140" class="Function Operator">∘′</a> <a id="26474" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="26478" href="/PLFA-zh/Lists/#26434" class="Bound">P</a><a id="26479" class="Symbol">)</a> <a id="26481" href="/PLFA-zh/Lists/#26448" class="Bound">xs</a> <a id="26484" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="26486" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="26490" class="Symbol">(</a><a id="26491" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="26494" href="/PLFA-zh/Lists/#26140" class="Function Operator">∘′</a> <a id="26497" href="/PLFA-zh/Lists/#26434" class="Bound">P</a><a id="26498" class="Symbol">)</a> <a id="26500" href="/PLFA-zh/Lists/#26448" class="Bound">xs</a></pre>

<p>Do we also have the following?</p>
<pre class="Agda"><a id="26559" class="Keyword">postulate</a>
  <a id="¬All≃Any¬"></a><a id="26571" href="/PLFA-zh/Lists/#26571" class="Postulate">¬All≃Any¬</a> <a id="26581" class="Symbol">:</a> <a id="26583" class="Symbol">∀</a> <a id="26585" class="Symbol">{</a><a id="26586" href="/PLFA-zh/Lists/#26586" class="Bound">A</a> <a id="26588" class="Symbol">:</a> <a id="26590" class="PrimitiveType">Set</a><a id="26593" class="Symbol">}</a> <a id="26595" class="Symbol">(</a><a id="26596" href="/PLFA-zh/Lists/#26596" class="Bound">P</a> <a id="26598" class="Symbol">:</a> <a id="26600" href="/PLFA-zh/Lists/#26586" class="Bound">A</a> <a id="26602" class="Symbol">→</a> <a id="26604" class="PrimitiveType">Set</a><a id="26607" class="Symbol">)</a> <a id="26609" class="Symbol">(</a><a id="26610" href="/PLFA-zh/Lists/#26610" class="Bound">xs</a> <a id="26613" class="Symbol">:</a> <a id="26615" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="26620" href="/PLFA-zh/Lists/#26586" class="Bound">A</a><a id="26621" class="Symbol">)</a>
    <a id="26627" class="Symbol">→</a> <a id="26629" class="Symbol">(</a><a id="26630" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="26633" href="/PLFA-zh/Lists/#26140" class="Function Operator">∘′</a> <a id="26636" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="26640" href="/PLFA-zh/Lists/#26596" class="Bound">P</a><a id="26641" class="Symbol">)</a> <a id="26643" href="/PLFA-zh/Lists/#26610" class="Bound">xs</a> <a id="26646" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="26648" href="/PLFA-zh/Lists/#23322" class="Datatype">Any</a> <a id="26652" class="Symbol">(</a><a id="26653" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a> <a id="26656" href="/PLFA-zh/Lists/#26140" class="Function Operator">∘′</a> <a id="26659" href="/PLFA-zh/Lists/#26596" class="Bound">P</a><a id="26660" class="Symbol">)</a> <a id="26662" href="/PLFA-zh/Lists/#26610" class="Bound">xs</a></pre>
<p>If so, prove; if not, explain why.</p>

<h2 id="decidability-of-all">Decidability of All</h2>

<p>If we consider a predicate as a function that yields a boolean,
it is easy to define an analogue of <code class="highlighter-rouge">All</code>, which returns true if
a given predicate returns true for every element of a list:</p>
<pre class="Agda"><a id="all"></a><a id="26939" href="/PLFA-zh/Lists/#26939" class="Function">all</a> <a id="26943" class="Symbol">:</a> <a id="26945" class="Symbol">∀</a> <a id="26947" class="Symbol">{</a><a id="26948" href="/PLFA-zh/Lists/#26948" class="Bound">A</a> <a id="26950" class="Symbol">:</a> <a id="26952" class="PrimitiveType">Set</a><a id="26955" class="Symbol">}</a> <a id="26957" class="Symbol">→</a> <a id="26959" class="Symbol">(</a><a id="26960" href="/PLFA-zh/Lists/#26948" class="Bound">A</a> <a id="26962" class="Symbol">→</a> <a id="26964" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a><a id="26968" class="Symbol">)</a> <a id="26970" class="Symbol">→</a> <a id="26972" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="26977" href="/PLFA-zh/Lists/#26948" class="Bound">A</a> <a id="26979" class="Symbol">→</a> <a id="26981" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#67" class="Datatype">Bool</a>
<a id="26986" href="/PLFA-zh/Lists/#26939" class="Function">all</a> <a id="26990" href="/PLFA-zh/Lists/#26990" class="Bound">p</a>  <a id="26993" class="Symbol">=</a>  <a id="26996" href="/PLFA-zh/Lists/#15955" class="Function">foldr</a> <a id="27002" href="https://agda.github.io/agda-stdlib/Data.Bool.Base.html#1012" class="Function Operator">_∧_</a> <a id="27006" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Bool.html#92" class="InductiveConstructor">true</a> <a id="27011" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="27013" href="/PLFA-zh/Lists/#13374" class="Function">map</a> <a id="27017" href="/PLFA-zh/Lists/#26990" class="Bound">p</a></pre>
<p>The function can be written in a particularly compact style by
using the higher-order functions <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">foldr</code>.</p>

<p>As one would hope, if we replace booleans by decidables there is again
an analogue of <code class="highlighter-rouge">All</code>.  First, return to the notion of a predicate <code class="highlighter-rouge">P</code> as
a function of type <code class="highlighter-rouge">A → Set</code>, taking a value <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code> into evidence
<code class="highlighter-rouge">P x</code> that a property holds for <code class="highlighter-rouge">x</code>.  Say that a predicate <code class="highlighter-rouge">P</code> is <em>decidable</em>
if we have a function that for a given <code class="highlighter-rouge">x</code> can decide <code class="highlighter-rouge">P x</code>:</p>
<pre class="Agda"><a id="Decidable"></a><a id="27517" href="/PLFA-zh/Lists/#27517" class="Function">Decidable</a> <a id="27527" class="Symbol">:</a> <a id="27529" class="Symbol">∀</a> <a id="27531" class="Symbol">{</a><a id="27532" href="/PLFA-zh/Lists/#27532" class="Bound">A</a> <a id="27534" class="Symbol">:</a> <a id="27536" class="PrimitiveType">Set</a><a id="27539" class="Symbol">}</a> <a id="27541" class="Symbol">→</a> <a id="27543" class="Symbol">(</a><a id="27544" href="/PLFA-zh/Lists/#27532" class="Bound">A</a> <a id="27546" class="Symbol">→</a> <a id="27548" class="PrimitiveType">Set</a><a id="27551" class="Symbol">)</a> <a id="27553" class="Symbol">→</a> <a id="27555" class="PrimitiveType">Set</a>
<a id="27559" href="/PLFA-zh/Lists/#27517" class="Function">Decidable</a> <a id="27569" class="Symbol">{</a><a id="27570" href="/PLFA-zh/Lists/#27570" class="Bound">A</a><a id="27571" class="Symbol">}</a> <a id="27573" href="/PLFA-zh/Lists/#27573" class="Bound">P</a>  <a id="27576" class="Symbol">=</a>  <a id="27579" class="Symbol">∀</a> <a id="27581" class="Symbol">(</a><a id="27582" href="/PLFA-zh/Lists/#27582" class="Bound">x</a> <a id="27584" class="Symbol">:</a> <a id="27586" href="/PLFA-zh/Lists/#27570" class="Bound">A</a><a id="27587" class="Symbol">)</a> <a id="27589" class="Symbol">→</a> <a id="27591" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="27595" class="Symbol">(</a><a id="27596" href="/PLFA-zh/Lists/#27573" class="Bound">P</a> <a id="27598" href="/PLFA-zh/Lists/#27582" class="Bound">x</a><a id="27599" class="Symbol">)</a></pre>
<p>Then if predicate <code class="highlighter-rouge">P</code> is decidable, it is also decidable whether every
element of a list satisfies the predicate:</p>
<pre class="Agda"><a id="All?"></a><a id="27739" href="/PLFA-zh/Lists/#27739" class="Function">All?</a> <a id="27744" class="Symbol">:</a> <a id="27746" class="Symbol">∀</a> <a id="27748" class="Symbol">{</a><a id="27749" href="/PLFA-zh/Lists/#27749" class="Bound">A</a> <a id="27751" class="Symbol">:</a> <a id="27753" class="PrimitiveType">Set</a><a id="27756" class="Symbol">}</a> <a id="27758" class="Symbol">{</a><a id="27759" href="/PLFA-zh/Lists/#27759" class="Bound">P</a> <a id="27761" class="Symbol">:</a> <a id="27763" href="/PLFA-zh/Lists/#27749" class="Bound">A</a> <a id="27765" class="Symbol">→</a> <a id="27767" class="PrimitiveType">Set</a><a id="27770" class="Symbol">}</a> <a id="27772" class="Symbol">→</a> <a id="27774" href="/PLFA-zh/Lists/#27517" class="Function">Decidable</a> <a id="27784" href="/PLFA-zh/Lists/#27759" class="Bound">P</a> <a id="27786" class="Symbol">→</a> <a id="27788" href="/PLFA-zh/Lists/#27517" class="Function">Decidable</a> <a id="27798" class="Symbol">(</a><a id="27799" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="27803" href="/PLFA-zh/Lists/#27759" class="Bound">P</a><a id="27804" class="Symbol">)</a>
<a id="27806" href="/PLFA-zh/Lists/#27739" class="Function">All?</a> <a id="27811" href="/PLFA-zh/Lists/#27811" class="Bound">P?</a> <a id="27814" href="/PLFA-zh/Lists/#1125" class="InductiveConstructor">[]</a>                                 <a id="27849" class="Symbol">=</a>  <a id="27852" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27856" href="/PLFA-zh/Lists/#21888" class="InductiveConstructor">[]</a>
<a id="27859" href="/PLFA-zh/Lists/#27739" class="Function">All?</a> <a id="27864" href="/PLFA-zh/Lists/#27864" class="Bound">P?</a> <a id="27867" class="Symbol">(</a><a id="27868" href="/PLFA-zh/Lists/#27868" class="Bound">x</a> <a id="27870" href="/PLFA-zh/Lists/#1140" class="InductiveConstructor Operator">∷</a> <a id="27872" href="/PLFA-zh/Lists/#27872" class="Bound">xs</a><a id="27874" class="Symbol">)</a> <a id="27876" class="Keyword">with</a> <a id="27881" href="/PLFA-zh/Lists/#27864" class="Bound">P?</a> <a id="27884" href="/PLFA-zh/Lists/#27868" class="Bound">x</a>   <a id="27888" class="Symbol">|</a> <a id="27890" href="/PLFA-zh/Lists/#27739" class="Function">All?</a> <a id="27895" href="/PLFA-zh/Lists/#27864" class="Bound">P?</a> <a id="27898" href="/PLFA-zh/Lists/#27872" class="Bound">xs</a>
<a id="27901" class="Symbol">...</a>                 <a id="27921" class="Symbol">|</a> <a id="27923" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27927" href="/PLFA-zh/Lists/#27927" class="Bound">Px</a> <a id="27930" class="Symbol">|</a> <a id="27932" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27936" href="/PLFA-zh/Lists/#27936" class="Bound">Pxs</a>     <a id="27944" class="Symbol">=</a>  <a id="27947" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27951" class="Symbol">(</a><a id="27952" href="/PLFA-zh/Lists/#27927" class="Bound">Px</a> <a id="27955" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="27957" href="/PLFA-zh/Lists/#27936" class="Bound">Pxs</a><a id="27960" class="Symbol">)</a>
<a id="27962" class="Symbol">...</a>                 <a id="27982" class="Symbol">|</a> <a id="27984" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="27987" href="/PLFA-zh/Lists/#27987" class="Bound">¬Px</a> <a id="27991" class="Symbol">|</a> <a id="27993" class="Symbol">_</a>           <a id="28005" class="Symbol">=</a>  <a id="28008" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="28011" class="Symbol">λ{</a> <a id="28014" class="Symbol">(</a><a id="28015" href="/PLFA-zh/Lists/#28015" class="Bound">Px</a> <a id="28018" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="28020" href="/PLFA-zh/Lists/#28020" class="Bound">Pxs</a><a id="28023" class="Symbol">)</a> <a id="28025" class="Symbol">→</a> <a id="28027" href="/PLFA-zh/Lists/#27987" class="Bound">¬Px</a> <a id="28031" href="/PLFA-zh/Lists/#28015" class="Bound">Px</a>   <a id="28036" class="Symbol">}</a>
<a id="28038" class="CatchallClause Symbol">...</a><a id="28041" class="CatchallClause">                 </a><a id="28058" class="CatchallClause Symbol">|</a><a id="28059" class="CatchallClause"> </a><a id="28060" class="CatchallClause Symbol">_</a><a id="28061" class="CatchallClause">      </a><a id="28067" class="CatchallClause Symbol">|</a><a id="28068" class="CatchallClause"> </a><a id="28069" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="CatchallClause InductiveConstructor">no</a><a id="28071" class="CatchallClause"> </a><a id="28072" href="/PLFA-zh/Lists/#28072" class="CatchallClause Bound">¬Pxs</a>     <a id="28081" class="Symbol">=</a>  <a id="28084" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="28087" class="Symbol">λ{</a> <a id="28090" class="Symbol">(</a><a id="28091" href="/PLFA-zh/Lists/#28091" class="Bound">Px</a> <a id="28094" href="/PLFA-zh/Lists/#21905" class="InductiveConstructor Operator">∷</a> <a id="28096" href="/PLFA-zh/Lists/#28096" class="Bound">Pxs</a><a id="28099" class="Symbol">)</a> <a id="28101" class="Symbol">→</a> <a id="28103" href="/PLFA-zh/Lists/#28072" class="Bound">¬Pxs</a> <a id="28108" href="/PLFA-zh/Lists/#28096" class="Bound">Pxs</a> <a id="28112" class="Symbol">}</a></pre>
<p>If the list is empty, then trivially <code class="highlighter-rouge">P</code> holds for every element of
the list.  Otherwise, the structure of the proof is similar to that
showing that the conjunction of two decidable propositions is itself
decidable, using <code class="highlighter-rouge">_∷_</code> rather than <code class="highlighter-rouge">⟨_,_⟩</code> to combine the evidence for
the head and tail of the list.</p>

<h4 id="exercise-any-stretch">Exercise <code class="highlighter-rouge">any?</code> (stretch)</h4>

<p>Just as <code class="highlighter-rouge">All</code> has analogues <code class="highlighter-rouge">all</code> and <code class="highlighter-rouge">all?</code> which determine whether a
predicate holds for every element of a list, so does <code class="highlighter-rouge">Any</code> have
analogues <code class="highlighter-rouge">any</code> and <code class="highlighter-rouge">any?</code> which determine whether a predicates holds
for some element of a list.  Give their definitions.</p>

<pre class="Agda"><a id="28738" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-filter-stretch">Exercise <code class="highlighter-rouge">filter?</code> (stretch)</h4>

<p>Define the following variant of the traditional <code class="highlighter-rouge">filter</code> function on lists,
which given a list and a decidable predicate returns all elements of the
list satisfying the predicate:</p>
<pre class="Agda"><a id="29002" class="Keyword">postulate</a>
  <a id="filter?"></a><a id="29014" href="/PLFA-zh/Lists/#29014" class="Postulate">filter?</a> <a id="29022" class="Symbol">:</a> <a id="29024" class="Symbol">∀</a> <a id="29026" class="Symbol">{</a><a id="29027" href="/PLFA-zh/Lists/#29027" class="Bound">A</a> <a id="29029" class="Symbol">:</a> <a id="29031" class="PrimitiveType">Set</a><a id="29034" class="Symbol">}</a> <a id="29036" class="Symbol">{</a><a id="29037" href="/PLFA-zh/Lists/#29037" class="Bound">P</a> <a id="29039" class="Symbol">:</a> <a id="29041" href="/PLFA-zh/Lists/#29027" class="Bound">A</a> <a id="29043" class="Symbol">→</a> <a id="29045" class="PrimitiveType">Set</a><a id="29048" class="Symbol">}</a>
    <a id="29054" class="Symbol">→</a> <a id="29056" class="Symbol">(</a><a id="29057" href="/PLFA-zh/Lists/#29057" class="Bound">P?</a> <a id="29060" class="Symbol">:</a> <a id="29062" href="/PLFA-zh/Lists/#27517" class="Function">Decidable</a> <a id="29072" href="/PLFA-zh/Lists/#29037" class="Bound">P</a><a id="29073" class="Symbol">)</a> <a id="29075" class="Symbol">→</a> <a id="29077" href="/PLFA-zh/Lists/#1096" class="Datatype">List</a> <a id="29082" href="/PLFA-zh/Lists/#29027" class="Bound">A</a> <a id="29084" class="Symbol">→</a> <a id="29086" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="29089" href="/PLFA-zh/Lists/#29089" class="Bound">ys</a> <a id="29092" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="29093" class="Symbol">(</a> <a id="29095" href="/PLFA-zh/Lists/#21837" class="Datatype">All</a> <a id="29099" href="/PLFA-zh/Lists/#29037" class="Bound">P</a> <a id="29101" href="/PLFA-zh/Lists/#29089" class="Bound">ys</a> <a id="29104" class="Symbol">)</a></pre>

<h2 id="standard-library">Standard Library</h2>

<p>Definitions similar to those in this chapter can be found in the standard library:</p>
<pre class="Agda"><a id="29236" class="Keyword">import</a> <a id="29243" href="https://agda.github.io/agda-stdlib/Data.List.html" class="Module">Data.List</a> <a id="29253" class="Keyword">using</a> <a id="29259" class="Symbol">(</a><a id="29260" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#80" class="Datatype">List</a><a id="29264" class="Symbol">;</a> <a id="29266" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1454" class="Function Operator">_++_</a><a id="29270" class="Symbol">;</a> <a id="29272" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#4008" class="Function">length</a><a id="29278" class="Symbol">;</a> <a id="29280" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#8504" class="Function">reverse</a><a id="29287" class="Symbol">;</a> <a id="29289" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1120" class="Function">map</a><a id="29292" class="Symbol">;</a> <a id="29294" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#3142" class="Function">foldr</a><a id="29299" class="Symbol">;</a> <a id="29301" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#5708" class="Function">downFrom</a><a id="29309" class="Symbol">)</a>
<a id="29311" class="Keyword">import</a> <a id="29318" href="https://agda.github.io/agda-stdlib/Data.List.All.html" class="Module">Data.List.All</a> <a id="29332" class="Keyword">using</a> <a id="29338" class="Symbol">(</a><a id="29339" href="https://agda.github.io/agda-stdlib/Data.List.All.html#826" class="Datatype">All</a><a id="29342" class="Symbol">;</a> <a id="29344" href="https://agda.github.io/agda-stdlib/Data.List.All.html#904" class="InductiveConstructor">[]</a><a id="29346" class="Symbol">;</a> <a id="29348" href="https://agda.github.io/agda-stdlib/Data.List.All.html#921" class="InductiveConstructor Operator">_∷_</a><a id="29351" class="Symbol">)</a>
<a id="29353" class="Keyword">import</a> <a id="29360" href="https://agda.github.io/agda-stdlib/Data.List.Any.html" class="Module">Data.List.Any</a> <a id="29374" class="Keyword">using</a> <a id="29380" class="Symbol">(</a><a id="29381" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#856" class="Datatype">Any</a><a id="29384" class="Symbol">;</a> <a id="29386" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#911" class="InductiveConstructor">here</a><a id="29390" class="Symbol">;</a> <a id="29392" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#964" class="InductiveConstructor">there</a><a id="29397" class="Symbol">)</a>
<a id="29399" class="Keyword">import</a> <a id="29406" href="https://agda.github.io/agda-stdlib/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="29441" class="Keyword">using</a> <a id="29447" class="Symbol">(</a><a id="29448" href="https://agda.github.io/agda-stdlib/Data.List.Membership.Setoid.html#709" class="Function Operator">_∈_</a><a id="29451" class="Symbol">)</a>
<a id="29453" class="Keyword">import</a> <a id="29460" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="29483" class="Keyword">using</a> <a id="29489" class="Symbol">(</a><a id="29490" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#23846" class="Function">reverse-++-commute</a><a id="29508" class="Symbol">;</a> <a id="29510" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#2896" class="Function">map-compose</a><a id="29521" class="Symbol">;</a> <a id="29523" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#2117" class="Function">map-++-commute</a><a id="29537" class="Symbol">;</a> <a id="29539" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#15132" class="Function">foldr-++</a><a id="29547" class="Symbol">)</a>
  <a id="29551" class="Keyword">renaming</a> <a id="29560" class="Symbol">(</a><a id="29561" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#31352" class="Function">mapIsFold</a> <a id="29571" class="Symbol">to</a> <a id="29574" href="https://agda.github.io/agda-stdlib/Data.List.Properties.html#31352" class="Function">map-is-foldr</a><a id="29586" class="Symbol">)</a>
<a id="29588" class="Keyword">import</a> <a id="29595" href="https://agda.github.io/agda-stdlib/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="29614" class="Keyword">using</a> <a id="29620" class="Symbol">(</a><a id="29621" href="https://agda.github.io/agda-stdlib/Algebra.Structures.html#1339" class="Record">IsMonoid</a><a id="29629" class="Symbol">)</a>
<a id="29631" class="Keyword">import</a> <a id="29638" href="https://agda.github.io/agda-stdlib/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="29653" class="Keyword">using</a> <a id="29659" class="Symbol">(</a><a id="29660" href="https://agda.github.io/agda-stdlib/Relation.Unary.html#3313" class="Function">Decidable</a><a id="29669" class="Symbol">)</a>
<a id="29671" class="Keyword">import</a> <a id="29678" href="https://agda.github.io/agda-stdlib/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="29694" class="Keyword">using</a> <a id="29700" class="Symbol">(</a><a id="29701" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4499" class="Function">Decidable</a><a id="29710" class="Symbol">)</a></pre>
<p>The standard library version of <code class="highlighter-rouge">IsMonoid</code> differs from the
one given here, in that it is also parameterised on an equivalence relation.</p>

<p>Both <code class="highlighter-rouge">Relation.Unary</code> and <code class="highlighter-rouge">Relation.Binary</code> define a version of <code class="highlighter-rouge">Decidable</code>,
one for unary relations (as used in this chapter where <code class="highlighter-rouge">P</code> ranges over
unary predicates) and one for binary relations (as used earlier, where <code class="highlighter-rouge">_≤_</code>
ranges over a binary relation).</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Decidable/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Lists.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Lambda/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
