<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Inference: Bidirectional type inference | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Inference: Bidirectional type inference" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://roger-uw.github.io/PLFA-zh/Inference/" />
<meta property="og:url" content="https://roger-uw.github.io/PLFA-zh/Inference/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://roger-uw.github.io/PLFA-zh/Inference/","headline":"Inference: Bidirectional type inference","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">目录</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Inference: Bidirectional type inference</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Bisimulation/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Inference.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Untyped/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="167" class="Keyword">module</a> <a id="174" href="/PLFA-zh/Inference/" class="Module">plfa.Inference</a> <a id="189" class="Keyword">where</a></pre>

<p>So far in our development, type derivations for the corresponding
term have been provided by fiat.<br />
In Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>
type derivations were given separately from the term, while
in Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>
the type derivation was inherently part of the term.</p>

<p>In practice, one often writes down a term with a few decorations and
applies an algorithm to <em>infer</em> the corresponding type derivation.
Indeed, this is exactly what happens in Agda: we specify the types for
top-level function declarations, and type information for everything
else is inferred from what has been given.  The style of inference
used is based on a technique called <em>bidirectional</em> type
inference, which will be presented in this chapter.</p>

<p>This chapter ties our previous developments together. We begin with
a term with some type annotations, quite close to the raw terms of
Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>,
and from it we compute a term with inherent types, in the style of
Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>.</p>

<h2 id="algorithms">Introduction: Inference rules as algorithms</h2>

<p>In the calculus we have considered so far, a term may have more than
one type.  For example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ x ⇒ x) ⦂ (A ⇒ A)
</code></pre></div></div>

<p>holds for <em>every</em> type <code class="highlighter-rouge">A</code>.  We start by considering a small language for
lambda terms where every term has a unique type.  All we need do
is decorate each abstraction term with the type of its argument.
This gives us the grammar:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L, M, N ::=                         decorated terms
  x                                   variable
  ƛ x ⦂ A ⇒ N                         abstraction (decorated)
  L · M                               application
</code></pre></div></div>

<p>Each of the associated type rules can be read as an algorithm for
type checking.  For each typing judgment, we label each position
as either an <em>input</em> or an <em>output</em>.</p>

<p>For the judgment</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ∋ x ⦂ A
</code></pre></div></div>

<p>we take the context <code class="highlighter-rouge">Γ</code> and the variable <code class="highlighter-rouge">x</code> as inputs, and the
type <code class="highlighter-rouge">A</code> as output.  Consider the rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------------- Z
Γ , x ⦂ A ∋ x ⦂ A

Γ ∋ x ⦂ A
----------------- S
Γ , y ⦂ B ∋ x ⦂ A
</code></pre></div></div>

<p>From the inputs we can determine which rule applies: if the last
variable in the context matches the given variable then the first
rule applies, else the second.  (For de Bruijn indices, it is even
easier: zero matches the first rule and successor the second.)
For the first rule, the output type can be read off as the last
type in the input context. For the second rule, the inputs of the
conclusion determine the inputs of the hypothesis, and the output
of the hypothesis determines the output of the conclusion.</p>

<p>For the judgment</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M ⦂ A
</code></pre></div></div>

<p>we take the context <code class="highlighter-rouge">Γ</code> and term <code class="highlighter-rouge">M</code> as inputs, and the type <code class="highlighter-rouge">A</code>
as output. Consider the rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ∋ x ⦂ A
-----------
Γ ⊢ ` x ⦂ A

Γ , x ⦂ A ⊢ N ⦂ B
--------------------------- 
Γ ⊢ (ƛ x ⦂ A ⇒ N) ⦂ (A ⇒ B)

Γ ⊢ L ⦂ A ⇒ B
Γ ⊢ M ⦂ A′
A ≡ A′
-------------
Γ ⊢ L · M ⦂ B
</code></pre></div></div>

<p>The input term determines which rule applies: variables use the first
rule, abstractions the second, and applications the third.  We say
such rules are <em>syntax directed</em>.  For the variable rule, the inputs
of the conclusion determine the inputs of the hypothesis, and the
output of the hypothesis determines the output of the conclusion.
Same for the abstraction rule — the bound variable and argument are
carried from the term of the conclusion into the context of the
hypothesis; this works because we added the argument type to the
abstraction.  For the application rule, we add a third hypothesis to
check whether the domain of the function matches the type of the
argument; this judgment is decidable when both types are given as
inputs. The inputs of the conclusion determine the inputs of the first
two hypotheses, the outputs of the first two hypotheses determine the
inputs of the third hypothesis, and the output of the first hypothesis
determines the output of the conclusion.</p>

<p>Converting the above to an algorithm is straightforward, as is adding
naturals and fixpoint.  We omit the details.  Instead, we consider a
detailed description of an approach that requires less obtrusive
decoration.  The idea is to break the normal typing judgment into two
judgments, one that produces the type as an output (as above), and
another that takes it as an input.</p>

<h2 id="synthesising-and-inheriting-types">Synthesising and inheriting types</h2>

<p>In addition to the lookup judgment for variables, which will remain
as before, we now have two judgments for the type of the term:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M ↑ A
Γ ⊢ M ↓ A
</code></pre></div></div>

<p>The first of these <em>synthesises</em> the type of a term, as before,
while the second <em>inherits</em> the type.  In the first, the context
and term are inputs and the type is an output; while in the
second, all three of the context, term, and type are inputs.</p>

<p>Which terms use synthesis and which inheritance?  Our approach will be
that the main term in a <em>deconstructor</em> is typed via synthesis while
<em>constructors</em> are typed via inheritance.  For instance, the function in
an application is typed via synthesis, but an abstraction is typed via
inheritance.  The inherited type in an abstraction term serves the
same purpose as the argument type decoration of the previous section.</p>

<p>Terms that deconstruct a value of a type always have a main term
(supplying an argument of the required type) and often have
side-terms.  For application, the main term supplies the function and
the side term supplies the argument.  For case terms, the main term
supplies a natural and the side terms are the two branches.  In a
deconstructor, the main term will be typed using synthesis but the
side terms will be typed using inheritance.  As we will see, this
leads naturally to an application as a whole being typed by synthesis,
while a case term as a whole will be typed by inheritance.
Variables are naturally typed by synthesis, since we can look up
the type in the input context.  Fixed points will be naturally
typed by inheritance.</p>

<p>In order to get a syntax-directed type system we break terms into two
kinds, <code class="highlighter-rouge">Term⁺</code> and <code class="highlighter-rouge">Term⁻</code>, which are typed by synthesis and
inheritance, respectively.  A subterm that is typed
by synthesis may appear in a context where it is typed by inheritance,
or vice-versa, and this gives rise to two new term forms.</p>

<p>For instance, we said above that the argument of an application is
typed by inheritance and that variables are typed by synthesis, giving
a mismatch if the argument of an application is a variable.  Hence, we
need a way to treat a synthesized term as if it is inherited.  We
introduce a new term form, <code class="highlighter-rouge">M ↑</code> for this purpose.  The typing judgment
checks that the inherited and synthesised types match.</p>

<p>Similarly, we said above that the function of an application is typed
by synthesis and that abstractions are typed by inheritance, giving a
mismatch if the function of an application is a variable.  Hence, we
need a way to treat an inherited term as if it is synthesised.  We
introduce a new term form <code class="highlighter-rouge">M ↓ A</code> for this purpose.  The typing
judgment returns <code class="highlighter-rouge">A</code> as the synthesized type of the term as a whole,
as well as using it as the inherited type for <code class="highlighter-rouge">M</code>.</p>

<p>The term form <code class="highlighter-rouge">M ↓ A</code> represents the only place terms need to be
decorated with types.  It only appears when switching from synthesis
to inheritance, that is, when a term that <em>deconstructs</em> a value of a
type contains as its main term a term that <em>constructs</em> a value of a
type, in other words, a place where a <code class="highlighter-rouge">β</code>-reduction will occur.
Typically, we will find that decorations are only required on top
level declarations.</p>

<p>We can extract the grammar for terms from the above:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L⁺, M⁺, N⁺ ::=                      terms with synthesized type
  x                                   variable
  L⁺ · M⁻                             application
  M⁻ ↓ A                              switch to inherited

L⁻, M⁻, N⁻ ::=                      terms with inherited type
  ƛ x ⇒ N                             abstraction
  `zero                               zero
  `suc M⁻                             successor
  case L⁺ [zero⇒ M⁻ |suc x ⇒ N⁻ ]     case
  μ x ⇒ N                             fixpoint
  M ↑                                 switch to synthesized
</code></pre></div></div>

<p>We will formalise the above shortly.</p>

<h2 id="soundness-and-completeness">Soundness and completeness</h2>

<p>What we intend to show is that the typing judgments are
<em>decidable</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>synthesize : ∀ (Γ : Context) (M : Term⁺)
    -----------------------
  → Dec (∃[ A ](Γ ⊢ M ↑ A))

inherit : ∀ (Γ : Context) (M : Term⁻) (A : Type)
    ---------------
  → Dec (Γ ⊢ M ↓ A)
</code></pre></div></div>

<p>Given context <code class="highlighter-rouge">Γ</code> and synthesised term <code class="highlighter-rouge">M</code>, we must decide whether
there exists a type <code class="highlighter-rouge">A</code> such that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> holds, or its negation.
Similarly, given context <code class="highlighter-rouge">Γ</code>, inherited term <code class="highlighter-rouge">M</code>, and type <code class="highlighter-rouge">A</code>, we
must decide whether <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> holds, or its negation.</p>

<p>Our proof is constructive. In the synthesised case, it will either
deliver a pair of a type <code class="highlighter-rouge">A</code> and evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code>, or a function
that given such a pair produces evidence of a contradiction. In the inherited
case, it will either deliver evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code>, or a function
that given such evidence produces evidence of a contradiction.
The positive case is referred to as <em>soundness</em> — synthesis and inheritance
succeed only if the corresponding relation holds.  The negative case is
referred to as <em>completeness</em> — synthesis and inheritance fail only when
they cannot possibly succeed.</p>

<p>Another approach might be to return a derivation if synthesis or
inheritance succeeds, and an error message otherwise — for instance,
see the section of the Agda user manual discussing
<a href="https://agda.readthedocs.io/en/latest/language/syntactic-sugar.html#example">syntactic sugar</a>.
Such an approach demonstrates soundness, but not completeness.  If it
returns a derivation, we know it is correct; but there is nothing to
prevent us from writing a function that <em>always</em> returns an error,
even when there exists a correct derivation.  Demonstrating both
soundness and completeness is significantly stronger than
demonstrating soundness alone.  The negative proof can be thought of
as a semantically verified error message, although in practice it
may be less readable than a well-crafted error message.</p>

<p>We are now ready to begin the formal development.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="10491" class="Keyword">import</a> <a id="10498" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="10536" class="Symbol">as</a> <a id="10539" class="Module">Eq</a>
<a id="10542" class="Keyword">open</a> <a id="10547" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="10550" class="Keyword">using</a> <a id="10556" class="Symbol">(</a><a id="10557" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="10560" class="Symbol">;</a> <a id="10562" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="10566" class="Symbol">;</a> <a id="10568" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="10571" class="Symbol">;</a> <a id="10573" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a><a id="10578" class="Symbol">;</a> <a id="10580" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="10584" class="Symbol">;</a> <a id="10586" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a><a id="10591" class="Symbol">;</a> <a id="10593" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">_≢_</a><a id="10596" class="Symbol">)</a>
<a id="10598" class="Keyword">open</a> <a id="10603" class="Keyword">import</a> <a id="10610" href="https://agda.github.io/agda-stdlib/Data.Empty.html" class="Module">Data.Empty</a> <a id="10621" class="Keyword">using</a> <a id="10627" class="Symbol">(</a><a id="10628" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a><a id="10629" class="Symbol">;</a> <a id="10631" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a><a id="10637" class="Symbol">)</a>
<a id="10639" class="Keyword">open</a> <a id="10644" class="Keyword">import</a> <a id="10651" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="10660" class="Keyword">using</a> <a id="10666" class="Symbol">(</a><a id="10667" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="10668" class="Symbol">;</a> <a id="10670" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="10674" class="Symbol">;</a> <a id="10676" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="10679" class="Symbol">;</a> <a id="10681" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="10684" class="Symbol">)</a>
<a id="10686" class="Keyword">open</a> <a id="10691" class="Keyword">import</a> <a id="10698" href="https://agda.github.io/agda-stdlib/Data.String.html" class="Module">Data.String</a> <a id="10710" class="Keyword">using</a> <a id="10716" class="Symbol">(</a><a id="10717" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a><a id="10723" class="Symbol">)</a>
<a id="10725" class="Keyword">open</a> <a id="10730" class="Keyword">import</a> <a id="10737" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html" class="Module">Data.String.Unsafe</a> <a id="10756" class="Keyword">using</a> <a id="10762" class="Symbol">(</a><a id="10763" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">_≟_</a><a id="10766" class="Symbol">)</a>
<a id="10768" class="Keyword">open</a> <a id="10773" class="Keyword">import</a> <a id="10780" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="10793" class="Keyword">using</a> <a id="10799" class="Symbol">(</a><a id="10800" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">_×_</a><a id="10803" class="Symbol">;</a> <a id="10805" href="https://agda.github.io/agda-stdlib/Data.Product.html#881" class="Function">∃</a><a id="10806" class="Symbol">;</a> <a id="10808" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃-syntax</a><a id="10816" class="Symbol">)</a> <a id="10818" class="Keyword">renaming</a> <a id="10827" class="Symbol">(</a><a id="10828" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="10832" class="Symbol">to</a> <a id="10835" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="10840" class="Symbol">)</a>
<a id="10842" class="Keyword">open</a> <a id="10847" class="Keyword">import</a> <a id="10854" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="10871" class="Keyword">using</a> <a id="10877" class="Symbol">(</a><a id="10878" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="10880" class="Symbol">;</a> <a id="10882" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="10885" class="Symbol">;</a> <a id="10887" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="10890" class="Symbol">;</a> <a id="10892" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="10894" class="Symbol">)</a></pre>

<p>Once we have a type derivation, it will be easy to construct
from it the inherently typed representation.  In order that we
can compare with our previous development, we import
module <code class="highlighter-rouge">pfla.DeBruijn</code>:</p>

<pre class="Agda"><a id="11125" class="Keyword">import</a> <a id="11132" href="/PLFA-zh/DeBruijn/" class="Module">plfa.DeBruijn</a> <a id="11146" class="Symbol">as</a> <a id="11149" class="Module">DB</a></pre>

<p>The phrase <code class="highlighter-rouge">as DB</code> allows us to refer to definitions
from that module as, for instance, <code class="highlighter-rouge">DB._⊢_</code>, which is
invoked as <code class="highlighter-rouge">Γ DB.⊢ A</code>, where <code class="highlighter-rouge">Γ</code> has type
<code class="highlighter-rouge">DB.Context</code> and <code class="highlighter-rouge">A</code> has type <code class="highlighter-rouge">DB.Type</code>.  We also import
<code class="highlighter-rouge">Type</code> and its constructors directly, so the latter may
also be referred to as just <code class="highlighter-rouge">Type</code>.</p>

<h2 id="syntax">Syntax</h2>

<p>First, we get all our infix declarations out of the way.
We list separately operators for judgments and terms:</p>

<pre class="Agda"><a id="11600" class="Keyword">infix</a>   <a id="11608" class="Number">4</a>  <a id="11611" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">_∋_⦂_</a>
<a id="11617" class="Keyword">infix</a>   <a id="11625" class="Number">4</a>  <a id="11628" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">_⊢_↑_</a>
<a id="11634" class="Keyword">infix</a>   <a id="11642" class="Number">4</a>  <a id="11645" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">_⊢_↓_</a>
<a id="11651" class="Keyword">infixl</a>  <a id="11659" class="Number">5</a>  <a id="11662" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">_,_⦂_</a>

<a id="11669" class="Keyword">infixr</a>  <a id="11677" class="Number">7</a>  <a id="11680" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">_⇒_</a>

<a id="11685" class="Keyword">infix</a>   <a id="11693" class="Number">5</a>  <a id="11696" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ_⇒_</a>
<a id="11701" class="Keyword">infix</a>   <a id="11709" class="Number">5</a>  <a id="11712" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">μ_⇒_</a>
<a id="11717" class="Keyword">infix</a>   <a id="11725" class="Number">6</a>  <a id="11728" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">_↑</a>
<a id="11731" class="Keyword">infix</a>   <a id="11739" class="Number">6</a>  <a id="11742" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">_↓_</a>
<a id="11746" class="Keyword">infixl</a>  <a id="11754" class="Number">7</a>  <a id="11757" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">_·_</a>
<a id="11761" class="Keyword">infix</a>   <a id="11769" class="Number">8</a>  <a id="11772" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc_</a>
<a id="11778" class="Keyword">infix</a>   <a id="11786" class="Number">9</a>  <a id="11789" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`_</a></pre>

<p>Identifiers, types, and contexts are as before:</p>
<pre class="Agda"><a id="Id"></a><a id="11865" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="11868" class="Symbol">:</a> <a id="11870" class="PrimitiveType">Set</a>
<a id="11874" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="11877" class="Symbol">=</a> <a id="11879" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a>

<a id="11887" class="Keyword">data</a> <a id="Type"></a><a id="11892" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="11897" class="Symbol">:</a> <a id="11899" class="PrimitiveType">Set</a> <a id="11903" class="Keyword">where</a>
  <a id="Type.`ℕ"></a><a id="11911" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>    <a id="11917" class="Symbol">:</a> <a id="11919" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a>
  <a id="Type._⇒_"></a><a id="11926" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">_⇒_</a>   <a id="11932" class="Symbol">:</a> <a id="11934" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="11939" class="Symbol">→</a> <a id="11941" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="11946" class="Symbol">→</a> <a id="11948" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a>

<a id="11954" class="Keyword">data</a> <a id="Context"></a><a id="11959" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="11967" class="Symbol">:</a> <a id="11969" class="PrimitiveType">Set</a> <a id="11973" class="Keyword">where</a>
  <a id="Context.∅"></a><a id="11981" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a>     <a id="11987" class="Symbol">:</a> <a id="11989" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a>
  <a id="Context._,_⦂_"></a><a id="11999" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">_,_⦂_</a> <a id="12005" class="Symbol">:</a> <a id="12007" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="12015" class="Symbol">→</a> <a id="12017" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="12020" class="Symbol">→</a> <a id="12022" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="12027" class="Symbol">→</a> <a id="12029" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a></pre>

<p>The syntax of terms is defined by mutual recursion.
We use <code class="highlighter-rouge">Term⁺</code> and <code class="highlighter-rouge">Term⁻</code>
for terms with synthesized and inherited types, respectively.
Note the inclusion of the switching forms,
<code class="highlighter-rouge">M ↓ A</code> and <code class="highlighter-rouge">M ↑</code>:</p>
<pre class="Agda"><a id="12265" class="Keyword">data</a> <a id="Term⁺"></a><a id="12270" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="12276" class="Symbol">:</a> <a id="12278" class="PrimitiveType">Set</a>
<a id="12282" class="Keyword">data</a> <a id="Term⁻"></a><a id="12287" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12293" class="Symbol">:</a> <a id="12295" class="PrimitiveType">Set</a>

<a id="12300" class="Keyword">data</a> <a id="12305" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="12311" class="Keyword">where</a>
  <a id="Term⁺.`_"></a><a id="12319" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`_</a>                        <a id="12345" class="Symbol">:</a> <a id="12347" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="12350" class="Symbol">→</a> <a id="12352" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
  <a id="Term⁺._·_"></a><a id="12360" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">_·_</a>                       <a id="12386" class="Symbol">:</a> <a id="12388" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="12394" class="Symbol">→</a> <a id="12396" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12402" class="Symbol">→</a> <a id="12404" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
  <a id="Term⁺._↓_"></a><a id="12412" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">_↓_</a>                       <a id="12438" class="Symbol">:</a> <a id="12440" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12446" class="Symbol">→</a> <a id="12448" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="12453" class="Symbol">→</a> <a id="12455" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>

<a id="12462" class="Keyword">data</a> <a id="12467" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12473" class="Keyword">where</a>
  <a id="Term⁻.ƛ_⇒_"></a><a id="12481" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ_⇒_</a>                     <a id="12506" class="Symbol">:</a> <a id="12508" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="12511" class="Symbol">→</a> <a id="12513" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12519" class="Symbol">→</a> <a id="12521" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
  <a id="Term⁻.`zero"></a><a id="12529" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a>                    <a id="12554" class="Symbol">:</a> <a id="12556" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
  <a id="Term⁻.`suc_"></a><a id="12564" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc_</a>                    <a id="12589" class="Symbol">:</a> <a id="12591" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12597" class="Symbol">→</a> <a id="12599" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
  <a id="Term⁻.`case_[zero⇒_|suc_⇒_]"></a><a id="12607" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case_[zero⇒_|suc_⇒_]</a>    <a id="12632" class="Symbol">:</a> <a id="12634" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="12640" class="Symbol">→</a> <a id="12642" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12648" class="Symbol">→</a> <a id="12650" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="12653" class="Symbol">→</a> <a id="12655" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12661" class="Symbol">→</a> <a id="12663" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
  <a id="Term⁻.μ_⇒_"></a><a id="12671" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">μ_⇒_</a>                     <a id="12696" class="Symbol">:</a> <a id="12698" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="12701" class="Symbol">→</a> <a id="12703" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="12709" class="Symbol">→</a> <a id="12711" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
  <a id="Term⁻._↑"></a><a id="12719" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">_↑</a>                       <a id="12744" class="Symbol">:</a> <a id="12746" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="12752" class="Symbol">→</a> <a id="12754" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a></pre>
<p>The choice as to whether each term is synthesized or
inherited follows the discussion above, and can be read
off from the informal grammar presented earlier.  Main terms in
deconstructors synthesise, constructors and side terms
in deconstructors inherit.</p>

<h2 id="example-terms">Example terms</h2>

<p>We can recreate the examples from preceding chapters.
First, computing two plus two on naturals:</p>
<pre class="Agda"><a id="two"></a><a id="13155" href="/PLFA-zh/Inference/#13155" class="Function">two</a> <a id="13159" class="Symbol">:</a> <a id="13161" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
<a id="13167" href="/PLFA-zh/Inference/#13155" class="Function">two</a> <a id="13171" class="Symbol">=</a> <a id="13173" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="13178" class="Symbol">(</a><a id="13179" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="13184" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a><a id="13189" class="Symbol">)</a>

<a id="plus"></a><a id="13192" href="/PLFA-zh/Inference/#13192" class="Function">plus</a> <a id="13197" class="Symbol">:</a> <a id="13199" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
<a id="13205" href="/PLFA-zh/Inference/#13192" class="Function">plus</a> <a id="13210" class="Symbol">=</a> <a id="13212" class="Symbol">(</a><a id="13213" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">μ</a> <a id="13215" class="String">&quot;p&quot;</a> <a id="13219" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">⇒</a> <a id="13221" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13223" class="String">&quot;m&quot;</a> <a id="13227" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13229" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13231" class="String">&quot;n&quot;</a> <a id="13235" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a>
          <a id="13247" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case</a> <a id="13253" class="Symbol">(</a><a id="13254" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13256" class="String">&quot;m&quot;</a><a id="13259" class="Symbol">)</a> <a id="13261" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">[zero⇒</a> <a id="13268" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13270" class="String">&quot;n&quot;</a> <a id="13274" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a>
                        <a id="13300" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">|suc</a> <a id="13305" class="String">&quot;m&quot;</a> <a id="13309" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">⇒</a> <a id="13311" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="13316" class="Symbol">(</a><a id="13317" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13319" class="String">&quot;p&quot;</a> <a id="13323" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13325" class="Symbol">(</a><a id="13326" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13328" class="String">&quot;m&quot;</a> <a id="13332" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13333" class="Symbol">)</a> <a id="13335" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13337" class="Symbol">(</a><a id="13338" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13340" class="String">&quot;n&quot;</a> <a id="13344" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13345" class="Symbol">)</a> <a id="13347" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13348" class="Symbol">)</a> <a id="13350" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">]</a><a id="13351" class="Symbol">)</a>
            <a id="13365" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="13367" class="Symbol">(</a><a id="13368" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="13371" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13373" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="13376" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13378" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="13380" class="Symbol">)</a>

<a id="2+2"></a><a id="13383" href="/PLFA-zh/Inference/#13383" class="Function">2+2</a> <a id="13387" class="Symbol">:</a> <a id="13389" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
<a id="13395" href="/PLFA-zh/Inference/#13383" class="Function">2+2</a> <a id="13399" class="Symbol">=</a> <a id="13401" href="/PLFA-zh/Inference/#13192" class="Function">plus</a> <a id="13406" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13408" href="/PLFA-zh/Inference/#13155" class="Function">two</a> <a id="13412" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13414" href="/PLFA-zh/Inference/#13155" class="Function">two</a></pre>
<p>The only change is to decorate with down and up arrows as required.
The only type decoration required is for <code class="highlighter-rouge">plus</code>.</p>

<p>Next, computing two plus two with Church numerals:</p>
<pre class="Agda"><a id="Ch"></a><a id="13611" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a> <a id="13614" class="Symbol">:</a> <a id="13616" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a>
<a id="13621" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a> <a id="13624" class="Symbol">=</a> <a id="13626" class="Symbol">(</a><a id="13627" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="13630" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13632" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="13634" class="Symbol">)</a> <a id="13636" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13638" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="13641" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13643" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>

<a id="twoᶜ"></a><a id="13647" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="13652" class="Symbol">:</a> <a id="13654" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
<a id="13660" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="13665" class="Symbol">=</a> <a id="13667" class="Symbol">(</a><a id="13668" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13670" class="String">&quot;s&quot;</a> <a id="13674" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13676" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13678" class="String">&quot;z&quot;</a> <a id="13682" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13684" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13686" class="String">&quot;s&quot;</a> <a id="13690" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13692" class="Symbol">(</a><a id="13693" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13695" class="String">&quot;s&quot;</a> <a id="13699" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13701" class="Symbol">(</a><a id="13702" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13704" class="String">&quot;z&quot;</a> <a id="13708" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13709" class="Symbol">)</a> <a id="13711" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13712" class="Symbol">)</a> <a id="13714" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13715" class="Symbol">)</a>

<a id="plusᶜ"></a><a id="13718" href="/PLFA-zh/Inference/#13718" class="Function">plusᶜ</a> <a id="13724" class="Symbol">:</a> <a id="13726" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
<a id="13732" href="/PLFA-zh/Inference/#13718" class="Function">plusᶜ</a> <a id="13738" class="Symbol">=</a> <a id="13740" class="Symbol">(</a><a id="13741" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13743" class="String">&quot;m&quot;</a> <a id="13747" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13749" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13751" class="String">&quot;n&quot;</a> <a id="13755" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13757" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13759" class="String">&quot;s&quot;</a> <a id="13763" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13765" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13767" class="String">&quot;z&quot;</a> <a id="13771" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a>
           <a id="13784" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13786" class="String">&quot;m&quot;</a> <a id="13790" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13792" class="Symbol">(</a><a id="13793" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13795" class="String">&quot;s&quot;</a> <a id="13799" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13800" class="Symbol">)</a> <a id="13802" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13804" class="Symbol">(</a><a id="13805" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13807" class="String">&quot;n&quot;</a> <a id="13811" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13813" class="Symbol">(</a><a id="13814" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13816" class="String">&quot;s&quot;</a> <a id="13820" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13821" class="Symbol">)</a> <a id="13823" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13825" class="Symbol">(</a><a id="13826" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13828" class="String">&quot;z&quot;</a> <a id="13832" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13833" class="Symbol">)</a> <a id="13835" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13836" class="Symbol">)</a> <a id="13838" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13839" class="Symbol">)</a>
             <a id="13854" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="13856" class="Symbol">(</a><a id="13857" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a> <a id="13860" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13862" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a> <a id="13865" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="13867" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a><a id="13869" class="Symbol">)</a>

<a id="sucᶜ"></a><a id="13872" href="/PLFA-zh/Inference/#13872" class="Function">sucᶜ</a> <a id="13877" class="Symbol">:</a> <a id="13879" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a>
<a id="13885" href="/PLFA-zh/Inference/#13872" class="Function">sucᶜ</a> <a id="13890" class="Symbol">=</a> <a id="13892" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="13894" class="String">&quot;x&quot;</a> <a id="13898" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="13900" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="13905" class="Symbol">(</a><a id="13906" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="13908" class="String">&quot;x&quot;</a> <a id="13912" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="13913" class="Symbol">)</a>

<a id="2+2ᶜ"></a><a id="13916" href="/PLFA-zh/Inference/#13916" class="Function">2+2ᶜ</a> <a id="13921" class="Symbol">:</a> <a id="13923" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a>
<a id="13929" href="/PLFA-zh/Inference/#13916" class="Function">2+2ᶜ</a> <a id="13934" class="Symbol">=</a> <a id="13936" href="/PLFA-zh/Inference/#13718" class="Function">plusᶜ</a> <a id="13942" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13944" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="13949" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13951" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="13956" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13958" href="/PLFA-zh/Inference/#13872" class="Function">sucᶜ</a> <a id="13963" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="13965" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a></pre>
<p>The only type decoration required is for <code class="highlighter-rouge">plusᶜ</code>.  One is not even
required for <code class="highlighter-rouge">sucᶜ</code>, which inherits its type as an argument of <code class="highlighter-rouge">plusᶜ</code>.</p>

<h2 id="bidirectional-type-checking">Bidirectional type checking</h2>

<p>The typing rules for variables are as in
<a href="/PLFA-zh/Lambda/">Lambda</a>:</p>
<pre class="Agda"><a id="14231" class="Keyword">data</a> <a id="_∋_⦂_"></a><a id="14236" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">_∋_⦂_</a> <a id="14242" class="Symbol">:</a> <a id="14244" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="14252" class="Symbol">→</a> <a id="14254" href="/PLFA-zh/Inference/#11865" class="Function">Id</a> <a id="14257" class="Symbol">→</a> <a id="14259" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="14264" class="Symbol">→</a> <a id="14266" class="PrimitiveType">Set</a> <a id="14270" class="Keyword">where</a>

  <a id="_∋_⦂_.Z"></a><a id="14279" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="14281" class="Symbol">:</a> <a id="14283" class="Symbol">∀</a> <a id="14285" class="Symbol">{</a><a id="14286" href="/PLFA-zh/Inference/#14286" class="Bound">Γ</a> <a id="14288" href="/PLFA-zh/Inference/#14288" class="Bound">x</a> <a id="14290" href="/PLFA-zh/Inference/#14290" class="Bound">A</a><a id="14291" class="Symbol">}</a>
      <a id="14299" class="Comment">--------------------</a>
    <a id="14324" class="Symbol">→</a> <a id="14326" href="/PLFA-zh/Inference/#14286" class="Bound">Γ</a> <a id="14328" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="14330" href="/PLFA-zh/Inference/#14288" class="Bound">x</a> <a id="14332" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="14334" href="/PLFA-zh/Inference/#14290" class="Bound">A</a> <a id="14336" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="14338" href="/PLFA-zh/Inference/#14288" class="Bound">x</a> <a id="14340" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="14342" href="/PLFA-zh/Inference/#14290" class="Bound">A</a>

  <a id="_∋_⦂_.S"></a><a id="14347" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="14349" class="Symbol">:</a> <a id="14351" class="Symbol">∀</a> <a id="14353" class="Symbol">{</a><a id="14354" href="/PLFA-zh/Inference/#14354" class="Bound">Γ</a> <a id="14356" href="/PLFA-zh/Inference/#14356" class="Bound">x</a> <a id="14358" href="/PLFA-zh/Inference/#14358" class="Bound">y</a> <a id="14360" href="/PLFA-zh/Inference/#14360" class="Bound">A</a> <a id="14362" href="/PLFA-zh/Inference/#14362" class="Bound">B</a><a id="14363" class="Symbol">}</a>
    <a id="14369" class="Symbol">→</a> <a id="14371" href="/PLFA-zh/Inference/#14356" class="Bound">x</a> <a id="14373" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="14375" href="/PLFA-zh/Inference/#14358" class="Bound">y</a>
    <a id="14381" class="Symbol">→</a> <a id="14383" href="/PLFA-zh/Inference/#14354" class="Bound">Γ</a> <a id="14385" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="14387" href="/PLFA-zh/Inference/#14356" class="Bound">x</a> <a id="14389" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="14391" href="/PLFA-zh/Inference/#14360" class="Bound">A</a>
      <a id="14399" class="Comment">-----------------</a>
    <a id="14421" class="Symbol">→</a> <a id="14423" href="/PLFA-zh/Inference/#14354" class="Bound">Γ</a> <a id="14425" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="14427" href="/PLFA-zh/Inference/#14358" class="Bound">y</a> <a id="14429" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="14431" href="/PLFA-zh/Inference/#14362" class="Bound">B</a> <a id="14433" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="14435" href="/PLFA-zh/Inference/#14356" class="Bound">x</a> <a id="14437" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="14439" href="/PLFA-zh/Inference/#14360" class="Bound">A</a></pre>

<p>As with syntax, the judgments for synthesizing
and inheriting types are mutually recursive:</p>
<pre class="Agda"><a id="14558" class="Keyword">data</a> <a id="_⊢_↑_"></a><a id="14563" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">_⊢_↑_</a> <a id="14569" class="Symbol">:</a> <a id="14571" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="14579" class="Symbol">→</a> <a id="14581" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a> <a id="14587" class="Symbol">→</a> <a id="14589" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="14594" class="Symbol">→</a> <a id="14596" class="PrimitiveType">Set</a>
<a id="14600" class="Keyword">data</a> <a id="_⊢_↓_"></a><a id="14605" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">_⊢_↓_</a> <a id="14611" class="Symbol">:</a> <a id="14613" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="14621" class="Symbol">→</a> <a id="14623" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a> <a id="14629" class="Symbol">→</a> <a id="14631" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="14636" class="Symbol">→</a> <a id="14638" class="PrimitiveType">Set</a>

<a id="14643" class="Keyword">data</a> <a id="14648" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">_⊢_↑_</a> <a id="14654" class="Keyword">where</a>

  <a id="_⊢_↑_.⊢`"></a><a id="14663" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="14666" class="Symbol">:</a> <a id="14668" class="Symbol">∀</a> <a id="14670" class="Symbol">{</a><a id="14671" href="/PLFA-zh/Inference/#14671" class="Bound">Γ</a> <a id="14673" href="/PLFA-zh/Inference/#14673" class="Bound">A</a> <a id="14675" href="/PLFA-zh/Inference/#14675" class="Bound">x</a><a id="14676" class="Symbol">}</a>
    <a id="14682" class="Symbol">→</a> <a id="14684" href="/PLFA-zh/Inference/#14671" class="Bound">Γ</a> <a id="14686" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="14688" href="/PLFA-zh/Inference/#14675" class="Bound">x</a> <a id="14690" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="14692" href="/PLFA-zh/Inference/#14673" class="Bound">A</a>
      <a id="14700" class="Comment">-----------</a>
    <a id="14716" class="Symbol">→</a> <a id="14718" href="/PLFA-zh/Inference/#14671" class="Bound">Γ</a> <a id="14720" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="14722" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="14724" href="/PLFA-zh/Inference/#14675" class="Bound">x</a> <a id="14726" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="14728" href="/PLFA-zh/Inference/#14673" class="Bound">A</a>

  <a id="_⊢_↑_._·_"></a><a id="14733" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">_·_</a> <a id="14737" class="Symbol">:</a> <a id="14739" class="Symbol">∀</a> <a id="14741" class="Symbol">{</a><a id="14742" href="/PLFA-zh/Inference/#14742" class="Bound">Γ</a> <a id="14744" href="/PLFA-zh/Inference/#14744" class="Bound">L</a> <a id="14746" href="/PLFA-zh/Inference/#14746" class="Bound">M</a> <a id="14748" href="/PLFA-zh/Inference/#14748" class="Bound">A</a> <a id="14750" href="/PLFA-zh/Inference/#14750" class="Bound">B</a><a id="14751" class="Symbol">}</a>
    <a id="14757" class="Symbol">→</a> <a id="14759" href="/PLFA-zh/Inference/#14742" class="Bound">Γ</a> <a id="14761" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="14763" href="/PLFA-zh/Inference/#14744" class="Bound">L</a> <a id="14765" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="14767" href="/PLFA-zh/Inference/#14748" class="Bound">A</a> <a id="14769" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="14771" href="/PLFA-zh/Inference/#14750" class="Bound">B</a>
    <a id="14777" class="Symbol">→</a> <a id="14779" href="/PLFA-zh/Inference/#14742" class="Bound">Γ</a> <a id="14781" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="14783" href="/PLFA-zh/Inference/#14746" class="Bound">M</a> <a id="14785" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="14787" href="/PLFA-zh/Inference/#14748" class="Bound">A</a>
      <a id="14795" class="Comment">-------------</a>
    <a id="14813" class="Symbol">→</a> <a id="14815" href="/PLFA-zh/Inference/#14742" class="Bound">Γ</a> <a id="14817" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="14819" href="/PLFA-zh/Inference/#14744" class="Bound">L</a> <a id="14821" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="14823" href="/PLFA-zh/Inference/#14746" class="Bound">M</a> <a id="14825" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="14827" href="/PLFA-zh/Inference/#14750" class="Bound">B</a>

  <a id="_⊢_↑_.⊢↓"></a><a id="14832" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="14835" class="Symbol">:</a> <a id="14837" class="Symbol">∀</a> <a id="14839" class="Symbol">{</a><a id="14840" href="/PLFA-zh/Inference/#14840" class="Bound">Γ</a> <a id="14842" href="/PLFA-zh/Inference/#14842" class="Bound">M</a> <a id="14844" href="/PLFA-zh/Inference/#14844" class="Bound">A</a><a id="14845" class="Symbol">}</a>
    <a id="14851" class="Symbol">→</a> <a id="14853" href="/PLFA-zh/Inference/#14840" class="Bound">Γ</a> <a id="14855" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="14857" href="/PLFA-zh/Inference/#14842" class="Bound">M</a> <a id="14859" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="14861" href="/PLFA-zh/Inference/#14844" class="Bound">A</a>
      <a id="14869" class="Comment">---------------</a>
    <a id="14889" class="Symbol">→</a> <a id="14891" href="/PLFA-zh/Inference/#14840" class="Bound">Γ</a> <a id="14893" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="14895" class="Symbol">(</a><a id="14896" href="/PLFA-zh/Inference/#14842" class="Bound">M</a> <a id="14898" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="14900" href="/PLFA-zh/Inference/#14844" class="Bound">A</a><a id="14901" class="Symbol">)</a> <a id="14903" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="14905" href="/PLFA-zh/Inference/#14844" class="Bound">A</a>

<a id="14908" class="Keyword">data</a> <a id="14913" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">_⊢_↓_</a> <a id="14919" class="Keyword">where</a>

  <a id="_⊢_↓_.⊢ƛ"></a><a id="14928" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a> <a id="14931" class="Symbol">:</a> <a id="14933" class="Symbol">∀</a> <a id="14935" class="Symbol">{</a><a id="14936" href="/PLFA-zh/Inference/#14936" class="Bound">Γ</a> <a id="14938" href="/PLFA-zh/Inference/#14938" class="Bound">x</a> <a id="14940" href="/PLFA-zh/Inference/#14940" class="Bound">N</a> <a id="14942" href="/PLFA-zh/Inference/#14942" class="Bound">A</a> <a id="14944" href="/PLFA-zh/Inference/#14944" class="Bound">B</a><a id="14945" class="Symbol">}</a>
    <a id="14951" class="Symbol">→</a> <a id="14953" href="/PLFA-zh/Inference/#14936" class="Bound">Γ</a> <a id="14955" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="14957" href="/PLFA-zh/Inference/#14938" class="Bound">x</a> <a id="14959" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="14961" href="/PLFA-zh/Inference/#14942" class="Bound">A</a> <a id="14963" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="14965" href="/PLFA-zh/Inference/#14940" class="Bound">N</a> <a id="14967" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="14969" href="/PLFA-zh/Inference/#14944" class="Bound">B</a>
      <a id="14977" class="Comment">-------------------</a>
    <a id="15001" class="Symbol">→</a> <a id="15003" href="/PLFA-zh/Inference/#14936" class="Bound">Γ</a> <a id="15005" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15007" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="15009" href="/PLFA-zh/Inference/#14938" class="Bound">x</a> <a id="15011" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="15013" href="/PLFA-zh/Inference/#14940" class="Bound">N</a> <a id="15015" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15017" href="/PLFA-zh/Inference/#14942" class="Bound">A</a> <a id="15019" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="15021" href="/PLFA-zh/Inference/#14944" class="Bound">B</a>

  <a id="_⊢_↓_.⊢zero"></a><a id="15026" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a> <a id="15032" class="Symbol">:</a> <a id="15034" class="Symbol">∀</a> <a id="15036" class="Symbol">{</a><a id="15037" href="/PLFA-zh/Inference/#15037" class="Bound">Γ</a><a id="15038" class="Symbol">}</a>
      <a id="15046" class="Comment">--------------</a>
    <a id="15065" class="Symbol">→</a> <a id="15067" href="/PLFA-zh/Inference/#15037" class="Bound">Γ</a> <a id="15069" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15071" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="15077" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15079" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>

  <a id="_⊢_↓_.⊢suc"></a><a id="15085" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="15090" class="Symbol">:</a> <a id="15092" class="Symbol">∀</a> <a id="15094" class="Symbol">{</a><a id="15095" href="/PLFA-zh/Inference/#15095" class="Bound">Γ</a> <a id="15097" href="/PLFA-zh/Inference/#15097" class="Bound">M</a><a id="15098" class="Symbol">}</a>
    <a id="15104" class="Symbol">→</a> <a id="15106" href="/PLFA-zh/Inference/#15095" class="Bound">Γ</a> <a id="15108" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15110" href="/PLFA-zh/Inference/#15097" class="Bound">M</a> <a id="15112" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15114" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>
      <a id="15123" class="Comment">---------------</a>
    <a id="15143" class="Symbol">→</a> <a id="15145" href="/PLFA-zh/Inference/#15095" class="Bound">Γ</a> <a id="15147" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15149" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="15154" href="/PLFA-zh/Inference/#15097" class="Bound">M</a> <a id="15156" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15158" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>

  <a id="_⊢_↓_.⊢case"></a><a id="15164" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="15170" class="Symbol">:</a> <a id="15172" class="Symbol">∀</a> <a id="15174" class="Symbol">{</a><a id="15175" href="/PLFA-zh/Inference/#15175" class="Bound">Γ</a> <a id="15177" href="/PLFA-zh/Inference/#15177" class="Bound">L</a> <a id="15179" href="/PLFA-zh/Inference/#15179" class="Bound">M</a> <a id="15181" href="/PLFA-zh/Inference/#15181" class="Bound">x</a> <a id="15183" href="/PLFA-zh/Inference/#15183" class="Bound">N</a> <a id="15185" href="/PLFA-zh/Inference/#15185" class="Bound">A</a><a id="15186" class="Symbol">}</a>
    <a id="15192" class="Symbol">→</a> <a id="15194" href="/PLFA-zh/Inference/#15175" class="Bound">Γ</a> <a id="15196" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="15198" href="/PLFA-zh/Inference/#15177" class="Bound">L</a> <a id="15200" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="15202" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>
    <a id="15209" class="Symbol">→</a> <a id="15211" href="/PLFA-zh/Inference/#15175" class="Bound">Γ</a> <a id="15213" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15215" href="/PLFA-zh/Inference/#15179" class="Bound">M</a> <a id="15217" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15219" href="/PLFA-zh/Inference/#15185" class="Bound">A</a>
    <a id="15225" class="Symbol">→</a> <a id="15227" href="/PLFA-zh/Inference/#15175" class="Bound">Γ</a> <a id="15229" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="15231" href="/PLFA-zh/Inference/#15181" class="Bound">x</a> <a id="15233" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="15235" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="15238" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15240" href="/PLFA-zh/Inference/#15183" class="Bound">N</a> <a id="15242" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15244" href="/PLFA-zh/Inference/#15185" class="Bound">A</a>
      <a id="15252" class="Comment">-------------------------------------</a>
    <a id="15294" class="Symbol">→</a> <a id="15296" href="/PLFA-zh/Inference/#15175" class="Bound">Γ</a> <a id="15298" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15300" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case</a> <a id="15306" href="/PLFA-zh/Inference/#15177" class="Bound">L</a> <a id="15308" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">[zero⇒</a> <a id="15315" href="/PLFA-zh/Inference/#15179" class="Bound">M</a> <a id="15317" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">|suc</a> <a id="15322" href="/PLFA-zh/Inference/#15181" class="Bound">x</a> <a id="15324" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">⇒</a> <a id="15326" href="/PLFA-zh/Inference/#15183" class="Bound">N</a> <a id="15328" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">]</a> <a id="15330" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15332" href="/PLFA-zh/Inference/#15185" class="Bound">A</a>

  <a id="_⊢_↓_.⊢μ"></a><a id="15337" href="/PLFA-zh/Inference/#15337" class="InductiveConstructor">⊢μ</a> <a id="15340" class="Symbol">:</a> <a id="15342" class="Symbol">∀</a> <a id="15344" class="Symbol">{</a><a id="15345" href="/PLFA-zh/Inference/#15345" class="Bound">Γ</a> <a id="15347" href="/PLFA-zh/Inference/#15347" class="Bound">x</a> <a id="15349" href="/PLFA-zh/Inference/#15349" class="Bound">N</a> <a id="15351" href="/PLFA-zh/Inference/#15351" class="Bound">A</a><a id="15352" class="Symbol">}</a>
    <a id="15358" class="Symbol">→</a> <a id="15360" href="/PLFA-zh/Inference/#15345" class="Bound">Γ</a> <a id="15362" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="15364" href="/PLFA-zh/Inference/#15347" class="Bound">x</a> <a id="15366" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="15368" href="/PLFA-zh/Inference/#15351" class="Bound">A</a> <a id="15370" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15372" href="/PLFA-zh/Inference/#15349" class="Bound">N</a> <a id="15374" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15376" href="/PLFA-zh/Inference/#15351" class="Bound">A</a>
      <a id="15384" class="Comment">-----------------</a>
    <a id="15406" class="Symbol">→</a> <a id="15408" href="/PLFA-zh/Inference/#15345" class="Bound">Γ</a> <a id="15410" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15412" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">μ</a> <a id="15414" href="/PLFA-zh/Inference/#15347" class="Bound">x</a> <a id="15416" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">⇒</a> <a id="15418" href="/PLFA-zh/Inference/#15349" class="Bound">N</a> <a id="15420" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15422" href="/PLFA-zh/Inference/#15351" class="Bound">A</a>

  <a id="_⊢_↓_.⊢↑"></a><a id="15427" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="15430" class="Symbol">:</a> <a id="15432" class="Symbol">∀</a> <a id="15434" class="Symbol">{</a><a id="15435" href="/PLFA-zh/Inference/#15435" class="Bound">Γ</a> <a id="15437" href="/PLFA-zh/Inference/#15437" class="Bound">M</a> <a id="15439" href="/PLFA-zh/Inference/#15439" class="Bound">A</a> <a id="15441" href="/PLFA-zh/Inference/#15441" class="Bound">B</a><a id="15442" class="Symbol">}</a>
    <a id="15448" class="Symbol">→</a> <a id="15450" href="/PLFA-zh/Inference/#15435" class="Bound">Γ</a> <a id="15452" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="15454" href="/PLFA-zh/Inference/#15437" class="Bound">M</a> <a id="15456" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="15458" href="/PLFA-zh/Inference/#15439" class="Bound">A</a>
    <a id="15464" class="Symbol">→</a> <a id="15466" href="/PLFA-zh/Inference/#15439" class="Bound">A</a> <a id="15468" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="15470" href="/PLFA-zh/Inference/#15441" class="Bound">B</a>
      <a id="15478" class="Comment">-------------</a>
    <a id="15496" class="Symbol">→</a> <a id="15498" href="/PLFA-zh/Inference/#15435" class="Bound">Γ</a> <a id="15500" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="15502" class="Symbol">(</a><a id="15503" href="/PLFA-zh/Inference/#15437" class="Bound">M</a> <a id="15505" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="15506" class="Symbol">)</a> <a id="15508" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="15510" href="/PLFA-zh/Inference/#15441" class="Bound">B</a></pre>
<p>We follow the same convention as
Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>,
prefacing the constructor with <code class="highlighter-rouge">⊢</code> to derive the name of the
corresponding type rule.</p>

<p>The rules are similar to those in
Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>,
modified to support synthesised and inherited types.
The two new rules are those for <code class="highlighter-rouge">⊢↑</code> and <code class="highlighter-rouge">⊢↓</code>.
The former both passes the type decoration as the inherited type and returns
it as the synthesised type.  The latter takes the synthesised type and the
inherited type and confirms they are identical — it should remind you of
the equality test in the application rule in the first
<a href="/PLFA-zh/Inference/#algorithms">section</a>.</p>

<h4 id="bidirectional-mul">Exercise <code class="highlighter-rouge">bidirectional-mul</code> (recommended)</h4>

<p>Rewrite your definition of multiplication from
Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>, decorated to support inference.</p>

<pre class="Agda"><a id="16355" class="Comment">-- Your code goes here</a></pre>

<h4 id="bidirectional-products">Exercise <code class="highlighter-rouge">bidirectional-products</code> (recommended)</h4>

<p>Extend the bidirectional type rules to include products from
Chapter <a href="/PLFA-zh/More/">More</a>.</p>

<pre class="Agda"><a id="16573" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-bidirectional-rest-stretch">Exercise <code class="highlighter-rouge">bidirectional-rest</code> (stretch)</h4>

<p>Extend the bidirectional type rules to include the rest of the constructs from
Chapter <a href="/PLFA-zh/More/">More</a>.</p>

<pre class="Agda"><a id="16775" class="Comment">-- Your code goes here</a></pre>

<h2 id="prerequisites">Prerequisites</h2>

<p>The rule for <code class="highlighter-rouge">M ↑</code> requires the ability to decide whether two types
are equal.  It is straightforward to code:</p>
<pre class="Agda"><a id="_≟Tp_"></a><a id="16953" href="/PLFA-zh/Inference/#16953" class="Function Operator">_≟Tp_</a> <a id="16959" class="Symbol">:</a> <a id="16961" class="Symbol">(</a><a id="16962" href="/PLFA-zh/Inference/#16962" class="Bound">A</a> <a id="16964" href="/PLFA-zh/Inference/#16964" class="Bound">B</a> <a id="16966" class="Symbol">:</a> <a id="16968" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a><a id="16972" class="Symbol">)</a> <a id="16974" class="Symbol">→</a> <a id="16976" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="16980" class="Symbol">(</a><a id="16981" href="/PLFA-zh/Inference/#16962" class="Bound">A</a> <a id="16983" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="16985" href="/PLFA-zh/Inference/#16964" class="Bound">B</a><a id="16986" class="Symbol">)</a>
<a id="16988" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>      <a id="16996" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17000" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>              <a id="17016" class="Symbol">=</a>  <a id="17019" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="17023" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17028" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>      <a id="17036" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17040" class="Symbol">(</a><a id="17041" href="/PLFA-zh/Inference/#17041" class="Bound">A</a> <a id="17043" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17045" href="/PLFA-zh/Inference/#17045" class="Bound">B</a><a id="17046" class="Symbol">)</a>         <a id="17056" class="Symbol">=</a>  <a id="17059" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17062" class="Symbol">λ()</a>
<a id="17066" class="Symbol">(</a><a id="17067" href="/PLFA-zh/Inference/#17067" class="Bound">A</a> <a id="17069" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17071" href="/PLFA-zh/Inference/#17071" class="Bound">B</a><a id="17072" class="Symbol">)</a> <a id="17074" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17078" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>              <a id="17094" class="Symbol">=</a>  <a id="17097" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17100" class="Symbol">λ()</a>
<a id="17104" class="Symbol">(</a><a id="17105" href="/PLFA-zh/Inference/#17105" class="Bound">A</a> <a id="17107" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17109" href="/PLFA-zh/Inference/#17109" class="Bound">B</a><a id="17110" class="Symbol">)</a> <a id="17112" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17116" class="Symbol">(</a><a id="17117" href="/PLFA-zh/Inference/#17117" class="Bound">A′</a> <a id="17120" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17122" href="/PLFA-zh/Inference/#17122" class="Bound">B′</a><a id="17124" class="Symbol">)</a>
  <a id="17128" class="Keyword">with</a> <a id="17133" href="/PLFA-zh/Inference/#17105" class="Bound">A</a> <a id="17135" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17139" href="/PLFA-zh/Inference/#17117" class="Bound">A′</a> <a id="17142" class="Symbol">|</a> <a id="17144" href="/PLFA-zh/Inference/#17109" class="Bound">B</a> <a id="17146" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="17150" href="/PLFA-zh/Inference/#17122" class="Bound">B′</a>
<a id="17153" class="Symbol">...</a>  <a id="17158" class="Symbol">|</a> <a id="17160" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17163" href="/PLFA-zh/Inference/#17163" class="Bound">A≢</a>    <a id="17169" class="Symbol">|</a> <a id="17171" class="Symbol">_</a>         <a id="17181" class="Symbol">=</a>  <a id="17184" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17187" class="Symbol">λ{</a><a id="17189" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17194" class="Symbol">→</a> <a id="17196" href="/PLFA-zh/Inference/#17163" class="Bound">A≢</a> <a id="17199" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="17203" class="Symbol">}</a>
<a id="17205" class="Symbol">...</a>  <a id="17210" class="Symbol">|</a> <a id="17212" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="17216" class="Symbol">_</a>    <a id="17221" class="Symbol">|</a> <a id="17223" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17226" href="/PLFA-zh/Inference/#17226" class="Bound">B≢</a>     <a id="17233" class="Symbol">=</a>  <a id="17236" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="17239" class="Symbol">λ{</a><a id="17241" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17246" class="Symbol">→</a> <a id="17248" href="/PLFA-zh/Inference/#17226" class="Bound">B≢</a> <a id="17251" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="17255" class="Symbol">}</a>
<a id="17257" class="Symbol">...</a>  <a id="17262" class="Symbol">|</a> <a id="17264" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="17268" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17273" class="Symbol">|</a> <a id="17275" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="17279" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>  <a id="17285" class="Symbol">=</a>  <a id="17288" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="17292" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>We will also need a couple of obvious lemmas; the domain
and range of equal function types are equal:</p>
<pre class="Agda"><a id="dom≡"></a><a id="17424" href="/PLFA-zh/Inference/#17424" class="Function">dom≡</a> <a id="17429" class="Symbol">:</a> <a id="17431" class="Symbol">∀</a> <a id="17433" class="Symbol">{</a><a id="17434" href="/PLFA-zh/Inference/#17434" class="Bound">A</a> <a id="17436" href="/PLFA-zh/Inference/#17436" class="Bound">A′</a> <a id="17439" href="/PLFA-zh/Inference/#17439" class="Bound">B</a> <a id="17441" href="/PLFA-zh/Inference/#17441" class="Bound">B′</a><a id="17443" class="Symbol">}</a> <a id="17445" class="Symbol">→</a> <a id="17447" href="/PLFA-zh/Inference/#17434" class="Bound">A</a> <a id="17449" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17451" href="/PLFA-zh/Inference/#17439" class="Bound">B</a> <a id="17453" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17455" href="/PLFA-zh/Inference/#17436" class="Bound">A′</a> <a id="17458" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17460" href="/PLFA-zh/Inference/#17441" class="Bound">B′</a> <a id="17463" class="Symbol">→</a> <a id="17465" href="/PLFA-zh/Inference/#17434" class="Bound">A</a> <a id="17467" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17469" href="/PLFA-zh/Inference/#17436" class="Bound">A′</a>
<a id="17472" href="/PLFA-zh/Inference/#17424" class="Function">dom≡</a> <a id="17477" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17482" class="Symbol">=</a> <a id="17484" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="rng≡"></a><a id="17490" href="/PLFA-zh/Inference/#17490" class="Function">rng≡</a> <a id="17495" class="Symbol">:</a> <a id="17497" class="Symbol">∀</a> <a id="17499" class="Symbol">{</a><a id="17500" href="/PLFA-zh/Inference/#17500" class="Bound">A</a> <a id="17502" href="/PLFA-zh/Inference/#17502" class="Bound">A′</a> <a id="17505" href="/PLFA-zh/Inference/#17505" class="Bound">B</a> <a id="17507" href="/PLFA-zh/Inference/#17507" class="Bound">B′</a><a id="17509" class="Symbol">}</a> <a id="17511" class="Symbol">→</a> <a id="17513" href="/PLFA-zh/Inference/#17500" class="Bound">A</a> <a id="17515" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17517" href="/PLFA-zh/Inference/#17505" class="Bound">B</a> <a id="17519" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17521" href="/PLFA-zh/Inference/#17502" class="Bound">A′</a> <a id="17524" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17526" href="/PLFA-zh/Inference/#17507" class="Bound">B′</a> <a id="17529" class="Symbol">→</a> <a id="17531" href="/PLFA-zh/Inference/#17505" class="Bound">B</a> <a id="17533" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17535" href="/PLFA-zh/Inference/#17507" class="Bound">B′</a>
<a id="17538" href="/PLFA-zh/Inference/#17490" class="Function">rng≡</a> <a id="17543" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17548" class="Symbol">=</a> <a id="17550" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>We will also need to know that the types <code class="highlighter-rouge">`ℕ</code>
and <code class="highlighter-rouge">A ⇒ B</code> are not equal:</p>
<pre class="Agda"><a id="ℕ≢⇒"></a><a id="17657" href="/PLFA-zh/Inference/#17657" class="Function">ℕ≢⇒</a> <a id="17661" class="Symbol">:</a> <a id="17663" class="Symbol">∀</a> <a id="17665" class="Symbol">{</a><a id="17666" href="/PLFA-zh/Inference/#17666" class="Bound">A</a> <a id="17668" href="/PLFA-zh/Inference/#17668" class="Bound">B</a><a id="17669" class="Symbol">}</a> <a id="17671" class="Symbol">→</a> <a id="17673" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="17676" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="17678" href="/PLFA-zh/Inference/#17666" class="Bound">A</a> <a id="17680" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="17682" href="/PLFA-zh/Inference/#17668" class="Bound">B</a>
<a id="17684" href="/PLFA-zh/Inference/#17657" class="Function">ℕ≢⇒</a> <a id="17688" class="Symbol">()</a></pre>

<h2 id="unique-types">Unique types</h2>

<p>Looking up a type in the context is unique.  Given two derivations,
one showing <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> and one showing <code class="highlighter-rouge">Γ ∋ x ⦂ B</code>, it follows that
<code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> must be identical:</p>
<pre class="Agda"><a id="uniq-∋"></a><a id="17902" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="17909" class="Symbol">:</a> <a id="17911" class="Symbol">∀</a> <a id="17913" class="Symbol">{</a><a id="17914" href="/PLFA-zh/Inference/#17914" class="Bound">Γ</a> <a id="17916" href="/PLFA-zh/Inference/#17916" class="Bound">x</a> <a id="17918" href="/PLFA-zh/Inference/#17918" class="Bound">A</a> <a id="17920" href="/PLFA-zh/Inference/#17920" class="Bound">B</a><a id="17921" class="Symbol">}</a> <a id="17923" class="Symbol">→</a> <a id="17925" href="/PLFA-zh/Inference/#17914" class="Bound">Γ</a> <a id="17927" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="17929" href="/PLFA-zh/Inference/#17916" class="Bound">x</a> <a id="17931" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="17933" href="/PLFA-zh/Inference/#17918" class="Bound">A</a> <a id="17935" class="Symbol">→</a> <a id="17937" href="/PLFA-zh/Inference/#17914" class="Bound">Γ</a> <a id="17939" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="17941" href="/PLFA-zh/Inference/#17916" class="Bound">x</a> <a id="17943" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="17945" href="/PLFA-zh/Inference/#17920" class="Bound">B</a> <a id="17947" class="Symbol">→</a> <a id="17949" href="/PLFA-zh/Inference/#17918" class="Bound">A</a> <a id="17951" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17953" href="/PLFA-zh/Inference/#17920" class="Bound">B</a>
<a id="17955" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="17962" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="17964" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a>                 <a id="17982" class="Symbol">=</a>  <a id="17985" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17990" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="17997" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="17999" class="Symbol">(</a><a id="18000" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="18002" href="/PLFA-zh/Inference/#18002" class="Bound">x≢y</a> <a id="18006" class="Symbol">_)</a>         <a id="18017" class="Symbol">=</a>  <a id="18020" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="18027" class="Symbol">(</a><a id="18028" href="/PLFA-zh/Inference/#18002" class="Bound">x≢y</a> <a id="18032" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="18036" class="Symbol">)</a>
<a id="18038" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="18045" class="Symbol">(</a><a id="18046" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="18048" href="/PLFA-zh/Inference/#18048" class="Bound">x≢y</a> <a id="18052" class="Symbol">_)</a> <a id="18055" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a>         <a id="18065" class="Symbol">=</a>  <a id="18068" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="18075" class="Symbol">(</a><a id="18076" href="/PLFA-zh/Inference/#18048" class="Bound">x≢y</a> <a id="18080" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="18084" class="Symbol">)</a>
<a id="18086" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="18093" class="Symbol">(</a><a id="18094" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="18096" class="Symbol">_</a> <a id="18098" href="/PLFA-zh/Inference/#18098" class="Bound">∋x</a><a id="18100" class="Symbol">)</a> <a id="18102" class="Symbol">(</a><a id="18103" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="18105" class="Symbol">_</a> <a id="18107" href="/PLFA-zh/Inference/#18107" class="Bound">∋x′</a><a id="18110" class="Symbol">)</a>  <a id="18113" class="Symbol">=</a>  <a id="18116" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="18123" href="/PLFA-zh/Inference/#18098" class="Bound">∋x</a> <a id="18126" href="/PLFA-zh/Inference/#18107" class="Bound">∋x′</a></pre>
<p>If both derivations are by rule <code class="highlighter-rouge">Z</code> then uniqueness
follows immediately, while if both derivations are
by rule <code class="highlighter-rouge">S</code> then uniqueness follows by induction.
It is a contradiction if one derivation is by
rule <code class="highlighter-rouge">Z</code> and one by rule <code class="highlighter-rouge">S</code>, since rule <code class="highlighter-rouge">Z</code>
requires the variable we are looking for is the
final one in the context, while rule <code class="highlighter-rouge">S</code> requires
it is not.</p>

<p>Synthesizing a type is also unique.  Given two derivations,
one showing <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> and one showing <code class="highlighter-rouge">Γ ⊢ M ↑ B</code>, it follows
that <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> must be identical:</p>
<pre class="Agda"><a id="uniq-↑"></a><a id="18668" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="18675" class="Symbol">:</a> <a id="18677" class="Symbol">∀</a> <a id="18679" class="Symbol">{</a><a id="18680" href="/PLFA-zh/Inference/#18680" class="Bound">Γ</a> <a id="18682" href="/PLFA-zh/Inference/#18682" class="Bound">M</a> <a id="18684" href="/PLFA-zh/Inference/#18684" class="Bound">A</a> <a id="18686" href="/PLFA-zh/Inference/#18686" class="Bound">B</a><a id="18687" class="Symbol">}</a> <a id="18689" class="Symbol">→</a> <a id="18691" href="/PLFA-zh/Inference/#18680" class="Bound">Γ</a> <a id="18693" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="18695" href="/PLFA-zh/Inference/#18682" class="Bound">M</a> <a id="18697" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="18699" href="/PLFA-zh/Inference/#18684" class="Bound">A</a> <a id="18701" class="Symbol">→</a> <a id="18703" href="/PLFA-zh/Inference/#18680" class="Bound">Γ</a> <a id="18705" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="18707" href="/PLFA-zh/Inference/#18682" class="Bound">M</a> <a id="18709" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="18711" href="/PLFA-zh/Inference/#18686" class="Bound">B</a> <a id="18713" class="Symbol">→</a> <a id="18715" href="/PLFA-zh/Inference/#18684" class="Bound">A</a> <a id="18717" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="18719" href="/PLFA-zh/Inference/#18686" class="Bound">B</a>
<a id="18721" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="18728" class="Symbol">(</a><a id="18729" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="18732" href="/PLFA-zh/Inference/#18732" class="Bound">∋x</a><a id="18734" class="Symbol">)</a> <a id="18736" class="Symbol">(</a><a id="18737" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="18740" href="/PLFA-zh/Inference/#18740" class="Bound">∋x′</a><a id="18743" class="Symbol">)</a>       <a id="18751" class="Symbol">=</a>  <a id="18754" href="/PLFA-zh/Inference/#17902" class="Function">uniq-∋</a> <a id="18761" href="/PLFA-zh/Inference/#18732" class="Bound">∋x</a> <a id="18764" href="/PLFA-zh/Inference/#18740" class="Bound">∋x′</a>
<a id="18768" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="18775" class="Symbol">(</a><a id="18776" href="/PLFA-zh/Inference/#18776" class="Bound">⊢L</a> <a id="18779" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="18781" href="/PLFA-zh/Inference/#18781" class="Bound">⊢M</a><a id="18783" class="Symbol">)</a> <a id="18785" class="Symbol">(</a><a id="18786" href="/PLFA-zh/Inference/#18786" class="Bound">⊢L′</a> <a id="18790" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="18792" href="/PLFA-zh/Inference/#18792" class="Bound">⊢M′</a><a id="18795" class="Symbol">)</a>  <a id="18798" class="Symbol">=</a>  <a id="18801" href="/PLFA-zh/Inference/#17490" class="Function">rng≡</a> <a id="18806" class="Symbol">(</a><a id="18807" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="18814" href="/PLFA-zh/Inference/#18776" class="Bound">⊢L</a> <a id="18817" href="/PLFA-zh/Inference/#18786" class="Bound">⊢L′</a><a id="18820" class="Symbol">)</a>
<a id="18822" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="18829" class="Symbol">(</a><a id="18830" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="18833" href="/PLFA-zh/Inference/#18833" class="Bound">⊢M</a><a id="18835" class="Symbol">)</a> <a id="18837" class="Symbol">(</a><a id="18838" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="18841" href="/PLFA-zh/Inference/#18841" class="Bound">⊢M′</a><a id="18844" class="Symbol">)</a>       <a id="18852" class="Symbol">=</a>  <a id="18855" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>There are three possibilities for the term. If it is a variable,
uniqueness of synthesis follows from uniqueness of lookup.
If it is an application, uniqueness follows by induction on
the function in the application, since the range of equal
types are equal.  If it is a switch expression, uniqueness
follows since both terms are decorated with the same type.</p>

<h2 id="lookup-type-of-a-variable-in-the-context">Lookup type of a variable in the context</h2>

<p>Given <code class="highlighter-rouge">Γ</code> and two distinct variables <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>, if there is no type <code class="highlighter-rouge">A</code>
such that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> holds, then there is also no type <code class="highlighter-rouge">A</code> such that
<code class="highlighter-rouge">Γ , y ⦂ B ∋ x ⦂ A</code> holds:</p>
<pre class="Agda"><a id="ext∋"></a><a id="19463" href="/PLFA-zh/Inference/#19463" class="Function">ext∋</a> <a id="19468" class="Symbol">:</a> <a id="19470" class="Symbol">∀</a> <a id="19472" class="Symbol">{</a><a id="19473" href="/PLFA-zh/Inference/#19473" class="Bound">Γ</a> <a id="19475" href="/PLFA-zh/Inference/#19475" class="Bound">B</a> <a id="19477" href="/PLFA-zh/Inference/#19477" class="Bound">x</a> <a id="19479" href="/PLFA-zh/Inference/#19479" class="Bound">y</a><a id="19480" class="Symbol">}</a>
  <a id="19484" class="Symbol">→</a> <a id="19486" href="/PLFA-zh/Inference/#19477" class="Bound">x</a> <a id="19488" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="19490" href="/PLFA-zh/Inference/#19479" class="Bound">y</a>
  <a id="19494" class="Symbol">→</a> <a id="19496" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="19498" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="19501" href="/PLFA-zh/Inference/#19501" class="Bound">A</a> <a id="19503" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="19504" class="Symbol">(</a> <a id="19506" href="/PLFA-zh/Inference/#19473" class="Bound">Γ</a> <a id="19508" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="19510" href="/PLFA-zh/Inference/#19477" class="Bound">x</a> <a id="19512" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="19514" href="/PLFA-zh/Inference/#19501" class="Bound">A</a> <a id="19516" class="Symbol">)</a>
    <a id="19522" class="Comment">-----------------------------</a>
  <a id="19554" class="Symbol">→</a> <a id="19556" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="19558" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="19561" href="/PLFA-zh/Inference/#19561" class="Bound">A</a> <a id="19563" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="19564" class="Symbol">(</a> <a id="19566" href="/PLFA-zh/Inference/#19473" class="Bound">Γ</a> <a id="19568" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="19570" href="/PLFA-zh/Inference/#19479" class="Bound">y</a> <a id="19572" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="19574" href="/PLFA-zh/Inference/#19475" class="Bound">B</a> <a id="19576" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="19578" href="/PLFA-zh/Inference/#19477" class="Bound">x</a> <a id="19580" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="19582" href="/PLFA-zh/Inference/#19561" class="Bound">A</a> <a id="19584" class="Symbol">)</a>
<a id="19586" href="/PLFA-zh/Inference/#19463" class="Function">ext∋</a> <a id="19591" href="/PLFA-zh/Inference/#19591" class="Bound">x≢y</a> <a id="19595" class="Symbol">_</a>  <a id="19598" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="19600" href="/PLFA-zh/Inference/#19600" class="Bound">A</a> <a id="19602" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="19604" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="19606" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>       <a id="19614" class="Symbol">=</a>  <a id="19617" href="/PLFA-zh/Inference/#19591" class="Bound">x≢y</a> <a id="19621" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="19626" href="/PLFA-zh/Inference/#19463" class="Function">ext∋</a> <a id="19631" class="Symbol">_</a>   <a id="19635" href="/PLFA-zh/Inference/#19635" class="Bound">¬∃</a> <a id="19638" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="19640" href="/PLFA-zh/Inference/#19640" class="Bound">A</a> <a id="19642" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="19644" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="19646" class="Symbol">_</a> <a id="19648" href="/PLFA-zh/Inference/#19648" class="Bound">⊢x</a> <a id="19651" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="19654" class="Symbol">=</a>  <a id="19657" href="/PLFA-zh/Inference/#19635" class="Bound">¬∃</a> <a id="19660" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="19662" href="/PLFA-zh/Inference/#19640" class="Bound">A</a> <a id="19664" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="19666" href="/PLFA-zh/Inference/#19648" class="Bound">⊢x</a> <a id="19669" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>
<p>Given a type <code class="highlighter-rouge">A</code> and evidence that <code class="highlighter-rouge">Γ , y ⦂ B ∋ x ⦂ A</code> holds, we must
demonstrate a contradiction.  If the judgment holds by <code class="highlighter-rouge">Z</code>, then we
must have that <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are the same, which contradicts the first
assumption. If the judgment holds by <code class="highlighter-rouge">S _ ⊢x</code> then <code class="highlighter-rouge">⊢x</code> provides
evidence that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code>, which contradicts the second assumption.</p>

<p>Given a context <code class="highlighter-rouge">Γ</code> and a variable <code class="highlighter-rouge">x</code>, we decide whether
there exists a type <code class="highlighter-rouge">A</code> such that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> holds, or its
negation:</p>
<pre class="Agda"><a id="lookup"></a><a id="20164" href="/PLFA-zh/Inference/#20164" class="Function">lookup</a> <a id="20171" class="Symbol">:</a> <a id="20173" class="Symbol">∀</a> <a id="20175" class="Symbol">(</a><a id="20176" href="/PLFA-zh/Inference/#20176" class="Bound">Γ</a> <a id="20178" class="Symbol">:</a> <a id="20180" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a><a id="20187" class="Symbol">)</a> <a id="20189" class="Symbol">(</a><a id="20190" href="/PLFA-zh/Inference/#20190" class="Bound">x</a> <a id="20192" class="Symbol">:</a> <a id="20194" href="/PLFA-zh/Inference/#11865" class="Function">Id</a><a id="20196" class="Symbol">)</a>
    <a id="20202" class="Comment">-----------------------</a>
  <a id="20228" class="Symbol">→</a> <a id="20230" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="20234" class="Symbol">(</a><a id="20235" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="20238" href="/PLFA-zh/Inference/#20238" class="Bound">A</a> <a id="20240" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="20241" class="Symbol">(</a><a id="20242" href="/PLFA-zh/Inference/#20176" class="Bound">Γ</a> <a id="20244" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="20246" href="/PLFA-zh/Inference/#20190" class="Bound">x</a> <a id="20248" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="20250" href="/PLFA-zh/Inference/#20238" class="Bound">A</a><a id="20251" class="Symbol">))</a>
<a id="20254" href="/PLFA-zh/Inference/#20164" class="Function">lookup</a> <a id="20261" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="20263" href="/PLFA-zh/Inference/#20263" class="Bound">x</a>                        <a id="20288" class="Symbol">=</a>  <a id="20291" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="20295" class="Symbol">(λ</a> <a id="20298" class="Symbol">())</a>
<a id="20302" href="/PLFA-zh/Inference/#20164" class="Function">lookup</a> <a id="20309" class="Symbol">(</a><a id="20310" href="/PLFA-zh/Inference/#20310" class="Bound">Γ</a> <a id="20312" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="20314" href="/PLFA-zh/Inference/#20314" class="Bound">y</a> <a id="20316" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="20318" href="/PLFA-zh/Inference/#20318" class="Bound">B</a><a id="20319" class="Symbol">)</a> <a id="20321" href="/PLFA-zh/Inference/#20321" class="Bound">x</a> <a id="20323" class="Keyword">with</a> <a id="20328" href="/PLFA-zh/Inference/#20321" class="Bound">x</a> <a id="20330" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="20332" href="/PLFA-zh/Inference/#20314" class="Bound">y</a>
<a id="20334" class="Symbol">...</a> <a id="20338" class="Symbol">|</a> <a id="20340" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="20344" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>                    <a id="20368" class="Symbol">=</a>  <a id="20371" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="20375" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="20377" class="Bound">B</a> <a id="20379" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="20381" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="20383" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="20385" class="Symbol">...</a> <a id="20389" class="Symbol">|</a> <a id="20391" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="20394" href="/PLFA-zh/Inference/#20394" class="Bound">x≢y</a> <a id="20398" class="Keyword">with</a> <a id="20403" href="/PLFA-zh/Inference/#20164" class="Function">lookup</a> <a id="20410" class="Bound">Γ</a> <a id="20412" class="Bound">x</a>
<a id="20414" class="Symbol">...</a>             <a id="20430" class="Symbol">|</a> <a id="20432" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="20436" href="/PLFA-zh/Inference/#20436" class="Bound">¬∃</a>          <a id="20448" class="Symbol">=</a>  <a id="20451" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="20455" class="Symbol">(</a><a id="20456" href="/PLFA-zh/Inference/#19463" class="Function">ext∋</a> <a id="20461" class="Bound">x≢y</a> <a id="20465" href="/PLFA-zh/Inference/#20436" class="Bound">¬∃</a><a id="20467" class="Symbol">)</a>
<a id="20469" class="Symbol">...</a>             <a id="20485" class="Symbol">|</a> <a id="20487" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="20491" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="20493" href="/PLFA-zh/Inference/#20493" class="Bound">A</a> <a id="20495" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="20497" href="/PLFA-zh/Inference/#20497" class="Bound">⊢x</a> <a id="20500" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="20503" class="Symbol">=</a>  <a id="20506" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="20510" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="20512" href="/PLFA-zh/Inference/#20493" class="Bound">A</a> <a id="20514" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="20516" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="20518" class="Bound">x≢y</a> <a id="20522" href="/PLFA-zh/Inference/#20497" class="Bound">⊢x</a> <a id="20525" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>
<p>Consider the context:</p>

<ul>
  <li>
    <p>If it is empty, then trivially there is no possible derivation.</p>
  </li>
  <li>
    <p>If it is non-empty, compare the given variable to the most
recent binding:</p>

    <ul>
      <li>
        <p>If they are identical, we have succeeded, with <code class="highlighter-rouge">Z</code> as
the appropriate derivation.</p>
      </li>
      <li>
        <p>If they differ, we recurse:</p>

        <ul>
          <li>
            <p>If lookup fails, we apply <code class="highlighter-rouge">ext∋</code> to conver the proof
there is no derivation from the contained context
to the extended context.</p>
          </li>
          <li>
            <p>If lookup succeeds, we extend the derivation with <code class="highlighter-rouge">S</code>.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="promoting-negations">Promoting negations</h2>

<p>For each possible term form, we need to show that if one of its
components fails to type, then the whole fails to type.  Most of
these results are easy to demonstrate inline, but we provide
auxiliary functions for a couple of the trickier cases.</p>

<p>If <code class="highlighter-rouge">Γ ⊢ L ↑ A ⇒ B</code> holds but <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> does not hold, then
there is no term <code class="highlighter-rouge">B′</code> such that <code class="highlighter-rouge">Γ ⊢ L · M ↑ B′</code> holds:</p>
<pre class="Agda"><a id="¬arg"></a><a id="21443" href="/PLFA-zh/Inference/#21443" class="Function">¬arg</a> <a id="21448" class="Symbol">:</a> <a id="21450" class="Symbol">∀</a> <a id="21452" class="Symbol">{</a><a id="21453" href="/PLFA-zh/Inference/#21453" class="Bound">Γ</a> <a id="21455" href="/PLFA-zh/Inference/#21455" class="Bound">A</a> <a id="21457" href="/PLFA-zh/Inference/#21457" class="Bound">B</a> <a id="21459" href="/PLFA-zh/Inference/#21459" class="Bound">L</a> <a id="21461" href="/PLFA-zh/Inference/#21461" class="Bound">M</a><a id="21462" class="Symbol">}</a>
  <a id="21466" class="Symbol">→</a> <a id="21468" href="/PLFA-zh/Inference/#21453" class="Bound">Γ</a> <a id="21470" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="21472" href="/PLFA-zh/Inference/#21459" class="Bound">L</a> <a id="21474" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="21476" href="/PLFA-zh/Inference/#21455" class="Bound">A</a> <a id="21478" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="21480" href="/PLFA-zh/Inference/#21457" class="Bound">B</a>
  <a id="21484" class="Symbol">→</a> <a id="21486" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="21488" href="/PLFA-zh/Inference/#21453" class="Bound">Γ</a> <a id="21490" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="21492" href="/PLFA-zh/Inference/#21461" class="Bound">M</a> <a id="21494" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="21496" href="/PLFA-zh/Inference/#21455" class="Bound">A</a>
    <a id="21502" class="Comment">-------------------------</a>
  <a id="21530" class="Symbol">→</a> <a id="21532" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="21534" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="21537" href="/PLFA-zh/Inference/#21537" class="Bound">B′</a> <a id="21540" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="21541" class="Symbol">(</a><a id="21542" href="/PLFA-zh/Inference/#21453" class="Bound">Γ</a> <a id="21544" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="21546" href="/PLFA-zh/Inference/#21459" class="Bound">L</a> <a id="21548" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="21550" href="/PLFA-zh/Inference/#21461" class="Bound">M</a> <a id="21552" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="21554" href="/PLFA-zh/Inference/#21537" class="Bound">B′</a><a id="21556" class="Symbol">)</a>
<a id="21558" href="/PLFA-zh/Inference/#21443" class="Function">¬arg</a> <a id="21563" href="/PLFA-zh/Inference/#21563" class="Bound">⊢L</a> <a id="21566" href="/PLFA-zh/Inference/#21566" class="Bound">¬⊢M</a> <a id="21570" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="21572" href="/PLFA-zh/Inference/#21572" class="Bound">B′</a> <a id="21575" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="21577" href="/PLFA-zh/Inference/#21577" class="Bound">⊢L′</a> <a id="21581" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="21583" href="/PLFA-zh/Inference/#21583" class="Bound">⊢M′</a> <a id="21587" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="21589" class="Keyword">rewrite</a> <a id="21597" href="/PLFA-zh/Inference/#17424" class="Function">dom≡</a> <a id="21602" class="Symbol">(</a><a id="21603" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="21610" href="/PLFA-zh/Inference/#21563" class="Bound">⊢L</a> <a id="21613" href="/PLFA-zh/Inference/#21577" class="Bound">⊢L′</a><a id="21616" class="Symbol">)</a> <a id="21618" class="Symbol">=</a> <a id="21620" href="/PLFA-zh/Inference/#21566" class="Bound">¬⊢M</a> <a id="21624" href="/PLFA-zh/Inference/#21583" class="Bound">⊢M′</a></pre>
<p>Let <code class="highlighter-rouge">⊢L</code> be evidence that <code class="highlighter-rouge">Γ ⊢ L ↑ A ⇒ B</code> holds and <code class="highlighter-rouge">¬⊢M</code> be evidence
that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> does not hold.  Given a type <code class="highlighter-rouge">B′</code> and evidence that
<code class="highlighter-rouge">Γ ⊢ L · M ↑ B′</code> holds, we must demonstrate a contradiction.  The
evidence must take the form <code class="highlighter-rouge">⊢L′ · ⊢M′</code>, where <code class="highlighter-rouge">⊢L′</code> is evidence that
<code class="highlighter-rouge">Γ ⊢ L ↑ A′ ⇒ B′</code> and <code class="highlighter-rouge">⊢M′</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A′</code>.  By
<code class="highlighter-rouge">uniq-↑</code> applied to <code class="highlighter-rouge">⊢L</code> and <code class="highlighter-rouge">⊢L′</code>, we know that <code class="highlighter-rouge">A ⇒ B ≡ A′ ⇒ B′</code>,
and hence that <code class="highlighter-rouge">A ≡ A′</code>, which means that <code class="highlighter-rouge">¬⊢M</code> and <code class="highlighter-rouge">⊢M′</code> yield a
contradiction.  Without the <code class="highlighter-rouge">rewrite</code> clause, Agda would not allow us
to derive a contradiction between <code class="highlighter-rouge">¬⊢M</code> and <code class="highlighter-rouge">⊢M′</code>, since one concerns
type <code class="highlighter-rouge">A</code> and the other type <code class="highlighter-rouge">A′</code>.</p>

<p>If <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> holds and <code class="highlighter-rouge">A ≢ B</code>, then <code class="highlighter-rouge">Γ ⊢ (M ↑) ↓ B</code> does not hold:</p>
<pre class="Agda"><a id="¬switch"></a><a id="22370" href="/PLFA-zh/Inference/#22370" class="Function">¬switch</a> <a id="22378" class="Symbol">:</a> <a id="22380" class="Symbol">∀</a> <a id="22382" class="Symbol">{</a><a id="22383" href="/PLFA-zh/Inference/#22383" class="Bound">Γ</a> <a id="22385" href="/PLFA-zh/Inference/#22385" class="Bound">M</a> <a id="22387" href="/PLFA-zh/Inference/#22387" class="Bound">A</a> <a id="22389" href="/PLFA-zh/Inference/#22389" class="Bound">B</a><a id="22390" class="Symbol">}</a>
  <a id="22394" class="Symbol">→</a> <a id="22396" href="/PLFA-zh/Inference/#22383" class="Bound">Γ</a> <a id="22398" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="22400" href="/PLFA-zh/Inference/#22385" class="Bound">M</a> <a id="22402" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="22404" href="/PLFA-zh/Inference/#22387" class="Bound">A</a>
  <a id="22408" class="Symbol">→</a> <a id="22410" href="/PLFA-zh/Inference/#22387" class="Bound">A</a> <a id="22412" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="22414" href="/PLFA-zh/Inference/#22389" class="Bound">B</a>
    <a id="22420" class="Comment">---------------</a>
  <a id="22438" class="Symbol">→</a> <a id="22440" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="22442" href="/PLFA-zh/Inference/#22383" class="Bound">Γ</a> <a id="22444" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="22446" class="Symbol">(</a><a id="22447" href="/PLFA-zh/Inference/#22385" class="Bound">M</a> <a id="22449" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="22450" class="Symbol">)</a> <a id="22452" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="22454" href="/PLFA-zh/Inference/#22389" class="Bound">B</a>
<a id="22456" href="/PLFA-zh/Inference/#22370" class="Function">¬switch</a> <a id="22464" href="/PLFA-zh/Inference/#22464" class="Bound">⊢M</a> <a id="22467" href="/PLFA-zh/Inference/#22467" class="Bound">A≢B</a> <a id="22471" class="Symbol">(</a><a id="22472" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="22475" href="/PLFA-zh/Inference/#22475" class="Bound">⊢M′</a> <a id="22479" href="/PLFA-zh/Inference/#22479" class="Bound">A′≡B</a><a id="22483" class="Symbol">)</a> <a id="22485" class="Keyword">rewrite</a> <a id="22493" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="22500" href="/PLFA-zh/Inference/#22464" class="Bound">⊢M</a> <a id="22503" href="/PLFA-zh/Inference/#22475" class="Bound">⊢M′</a> <a id="22507" class="Symbol">=</a> <a id="22509" href="/PLFA-zh/Inference/#22467" class="Bound">A≢B</a> <a id="22513" href="/PLFA-zh/Inference/#22479" class="Bound">A′≡B</a></pre>
<p>Let <code class="highlighter-rouge">⊢M</code> be evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> holds, and <code class="highlighter-rouge">A≢B</code> be evidence
that <code class="highlighter-rouge">A ≢ B</code>.  Given evidence that <code class="highlighter-rouge">Γ ⊢ (M ↑) ↓ B</code> holds, we must
demonstrate a contradiction.  The evidence must take the form <code class="highlighter-rouge">⊢↑ ⊢M′
A′≡B</code>, where <code class="highlighter-rouge">⊢M′</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A′</code> and <code class="highlighter-rouge">A′≡B</code> is
evidence that <code class="highlighter-rouge">A′≡B</code>.  By <code class="highlighter-rouge">uniq-↑</code> applied to <code class="highlighter-rouge">⊢M</code> and <code class="highlighter-rouge">⊢M′</code> we know
that <code class="highlighter-rouge">A ≡ A′</code>, which means that <code class="highlighter-rouge">A≢B</code> and <code class="highlighter-rouge">A′≡B</code> yield a
contradiction.  Without the <code class="highlighter-rouge">rewrite</code> clause, Agda would not allow us
to derive a contradiction between <code class="highlighter-rouge">A≢B</code> and <code class="highlighter-rouge">A′≡B</code>, since one concerns
type <code class="highlighter-rouge">A</code> and the other type <code class="highlighter-rouge">A′</code>.</p>

<h2 id="synthesize-and-inherit-types">Synthesize and inherit types</h2>

<p>The table has been set and we are ready for the main course.
We define two mutually recursive functions,
one for synthesis and one for inheritance.  Synthesis is given
a context <code class="highlighter-rouge">Γ</code> and a synthesis term <code class="highlighter-rouge">M</code> and either
returns a type <code class="highlighter-rouge">A</code> and evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code>, or its negation.
Inheritance is given a context <code class="highlighter-rouge">Γ</code>, an inheritance term <code class="highlighter-rouge">M</code>,
and a type <code class="highlighter-rouge">A</code> and either returns evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code>,
or its negation:</p>
<pre class="Agda"><a id="synthesize"></a><a id="23568" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="23579" class="Symbol">:</a> <a id="23581" class="Symbol">∀</a> <a id="23583" class="Symbol">(</a><a id="23584" href="/PLFA-zh/Inference/#23584" class="Bound">Γ</a> <a id="23586" class="Symbol">:</a> <a id="23588" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a><a id="23595" class="Symbol">)</a> <a id="23597" class="Symbol">(</a><a id="23598" href="/PLFA-zh/Inference/#23598" class="Bound">M</a> <a id="23600" class="Symbol">:</a> <a id="23602" href="/PLFA-zh/Inference/#12270" class="Datatype">Term⁺</a><a id="23607" class="Symbol">)</a>
    <a id="23613" class="Comment">-----------------------</a>
  <a id="23639" class="Symbol">→</a> <a id="23641" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="23645" class="Symbol">(</a><a id="23646" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="23649" href="/PLFA-zh/Inference/#23649" class="Bound">A</a> <a id="23651" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="23652" class="Symbol">(</a><a id="23653" href="/PLFA-zh/Inference/#23584" class="Bound">Γ</a> <a id="23655" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="23657" href="/PLFA-zh/Inference/#23598" class="Bound">M</a> <a id="23659" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="23661" href="/PLFA-zh/Inference/#23649" class="Bound">A</a><a id="23662" class="Symbol">))</a>

<a id="inherit"></a><a id="23666" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="23674" class="Symbol">:</a> <a id="23676" class="Symbol">∀</a> <a id="23678" class="Symbol">(</a><a id="23679" href="/PLFA-zh/Inference/#23679" class="Bound">Γ</a> <a id="23681" class="Symbol">:</a> <a id="23683" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a><a id="23690" class="Symbol">)</a> <a id="23692" class="Symbol">(</a><a id="23693" href="/PLFA-zh/Inference/#23693" class="Bound">M</a> <a id="23695" class="Symbol">:</a> <a id="23697" href="/PLFA-zh/Inference/#12287" class="Datatype">Term⁻</a><a id="23702" class="Symbol">)</a> <a id="23704" class="Symbol">(</a><a id="23705" href="/PLFA-zh/Inference/#23705" class="Bound">A</a> <a id="23707" class="Symbol">:</a> <a id="23709" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a><a id="23713" class="Symbol">)</a>
    <a id="23719" class="Comment">---------------</a>
  <a id="23737" class="Symbol">→</a> <a id="23739" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="23743" class="Symbol">(</a><a id="23744" href="/PLFA-zh/Inference/#23679" class="Bound">Γ</a> <a id="23746" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="23748" href="/PLFA-zh/Inference/#23693" class="Bound">M</a> <a id="23750" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="23752" href="/PLFA-zh/Inference/#23705" class="Bound">A</a><a id="23753" class="Symbol">)</a></pre>

<p>We first consider the code for synthesis:</p>
<pre class="Agda"><a id="23822" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="23833" href="/PLFA-zh/Inference/#23833" class="Bound">Γ</a> <a id="23835" class="Symbol">(</a><a id="23836" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="23838" href="/PLFA-zh/Inference/#23838" class="Bound">x</a><a id="23839" class="Symbol">)</a> <a id="23841" class="Keyword">with</a> <a id="23846" href="/PLFA-zh/Inference/#20164" class="Function">lookup</a> <a id="23853" href="/PLFA-zh/Inference/#23833" class="Bound">Γ</a> <a id="23855" href="/PLFA-zh/Inference/#23838" class="Bound">x</a>
<a id="23857" class="Symbol">...</a> <a id="23861" class="Symbol">|</a> <a id="23863" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23867" href="/PLFA-zh/Inference/#23867" class="Bound">¬∃</a>              <a id="23883" class="Symbol">=</a>  <a id="23886" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23890" class="Symbol">(λ{</a> <a id="23894" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="23896" href="/PLFA-zh/Inference/#23896" class="Bound">A</a> <a id="23898" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="23900" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="23903" href="/PLFA-zh/Inference/#23903" class="Bound">∋x</a> <a id="23906" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="23908" class="Symbol">→</a> <a id="23910" href="/PLFA-zh/Inference/#23867" class="Bound">¬∃</a> <a id="23913" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="23915" href="/PLFA-zh/Inference/#23896" class="Bound">A</a> <a id="23917" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="23919" href="/PLFA-zh/Inference/#23903" class="Bound">∋x</a> <a id="23922" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="23924" class="Symbol">})</a>
<a id="23927" class="Symbol">...</a> <a id="23931" class="Symbol">|</a> <a id="23933" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23937" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="23939" href="/PLFA-zh/Inference/#23939" class="Bound">A</a> <a id="23941" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="23943" href="/PLFA-zh/Inference/#23943" class="Bound">∋x</a> <a id="23946" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>      <a id="23953" class="Symbol">=</a>  <a id="23956" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23960" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="23962" href="/PLFA-zh/Inference/#23939" class="Bound">A</a> <a id="23964" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="23966" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="23969" href="/PLFA-zh/Inference/#23943" class="Bound">∋x</a> <a id="23972" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="23974" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="23985" href="/PLFA-zh/Inference/#23985" class="Bound">Γ</a> <a id="23987" class="Symbol">(</a><a id="23988" href="/PLFA-zh/Inference/#23988" class="Bound">L</a> <a id="23990" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="23992" href="/PLFA-zh/Inference/#23992" class="Bound">M</a><a id="23993" class="Symbol">)</a> <a id="23995" class="Keyword">with</a> <a id="24000" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="24011" href="/PLFA-zh/Inference/#23985" class="Bound">Γ</a> <a id="24013" href="/PLFA-zh/Inference/#23988" class="Bound">L</a>
<a id="24015" class="Symbol">...</a> <a id="24019" class="Symbol">|</a> <a id="24021" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24025" href="/PLFA-zh/Inference/#24025" class="Bound">¬∃</a>              <a id="24041" class="Symbol">=</a>  <a id="24044" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24048" class="Symbol">(λ{</a> <a id="24052" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24054" class="Symbol">_</a> <a id="24056" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24058" href="/PLFA-zh/Inference/#24058" class="Bound">⊢L</a>  <a id="24062" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="24064" class="Symbol">_</a>  <a id="24067" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="24070" class="Symbol">→</a>  <a id="24073" href="/PLFA-zh/Inference/#24025" class="Bound">¬∃</a> <a id="24076" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24078" class="Symbol">_</a> <a id="24080" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24082" href="/PLFA-zh/Inference/#24058" class="Bound">⊢L</a> <a id="24085" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="24087" class="Symbol">})</a>
<a id="24090" class="Symbol">...</a> <a id="24094" class="Symbol">|</a> <a id="24096" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24100" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24102" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="24105" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>    <a id="24110" href="/PLFA-zh/Inference/#24110" class="Bound">⊢L</a> <a id="24113" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="24116" class="Symbol">=</a>  <a id="24119" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24123" class="Symbol">(λ{</a> <a id="24127" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24129" class="Symbol">_</a> <a id="24131" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24133" href="/PLFA-zh/Inference/#24133" class="Bound">⊢L′</a> <a id="24137" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="24139" class="Symbol">_</a>  <a id="24142" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="24145" class="Symbol">→</a>  <a id="24148" href="/PLFA-zh/Inference/#17657" class="Function">ℕ≢⇒</a> <a id="24152" class="Symbol">(</a><a id="24153" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="24160" href="/PLFA-zh/Inference/#24110" class="Bound">⊢L</a> <a id="24163" href="/PLFA-zh/Inference/#24133" class="Bound">⊢L′</a><a id="24166" class="Symbol">)</a> <a id="24168" class="Symbol">})</a>
<a id="24171" class="Symbol">...</a> <a id="24175" class="Symbol">|</a> <a id="24177" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24181" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24183" href="/PLFA-zh/Inference/#24183" class="Bound">A</a> <a id="24185" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="24187" href="/PLFA-zh/Inference/#24187" class="Bound">B</a> <a id="24189" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24191" href="/PLFA-zh/Inference/#24191" class="Bound">⊢L</a> <a id="24194" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="24196" class="Keyword">with</a> <a id="24201" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="24209" class="Bound">Γ</a> <a id="24211" class="Bound">M</a> <a id="24213" href="/PLFA-zh/Inference/#24183" class="Bound">A</a>
<a id="24215" class="Symbol">...</a>    <a id="24222" class="Symbol">|</a> <a id="24224" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24228" href="/PLFA-zh/Inference/#24228" class="Bound">¬⊢M</a>          <a id="24241" class="Symbol">=</a>  <a id="24244" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24248" class="Symbol">(</a><a id="24249" href="/PLFA-zh/Inference/#21443" class="Function">¬arg</a> <a id="24254" class="Bound">⊢L</a> <a id="24257" href="/PLFA-zh/Inference/#24228" class="Bound">¬⊢M</a><a id="24260" class="Symbol">)</a>
<a id="24262" class="Symbol">...</a>    <a id="24269" class="Symbol">|</a> <a id="24271" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24275" href="/PLFA-zh/Inference/#24275" class="Bound">⊢M</a>           <a id="24288" class="Symbol">=</a>  <a id="24291" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24295" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24297" class="Bound">B</a> <a id="24299" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24301" class="Bound">⊢L</a> <a id="24304" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="24306" href="/PLFA-zh/Inference/#24275" class="Bound">⊢M</a> <a id="24309" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  
<a id="24313" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="24324" href="/PLFA-zh/Inference/#24324" class="Bound">Γ</a> <a id="24326" class="Symbol">(</a><a id="24327" href="/PLFA-zh/Inference/#24327" class="Bound">M</a> <a id="24329" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="24331" href="/PLFA-zh/Inference/#24331" class="Bound">A</a><a id="24332" class="Symbol">)</a> <a id="24334" class="Keyword">with</a> <a id="24339" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="24347" href="/PLFA-zh/Inference/#24324" class="Bound">Γ</a> <a id="24349" href="/PLFA-zh/Inference/#24327" class="Bound">M</a> <a id="24351" href="/PLFA-zh/Inference/#24331" class="Bound">A</a>
<a id="24353" class="Symbol">...</a> <a id="24357" class="Symbol">|</a> <a id="24359" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24363" href="/PLFA-zh/Inference/#24363" class="Bound">¬⊢M</a>             <a id="24379" class="Symbol">=</a>  <a id="24382" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24386" class="Symbol">(λ{</a> <a id="24390" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24392" class="Symbol">_</a> <a id="24394" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24396" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="24399" href="/PLFA-zh/Inference/#24399" class="Bound">⊢M</a> <a id="24402" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>  <a id="24405" class="Symbol">→</a>  <a id="24408" href="/PLFA-zh/Inference/#24363" class="Bound">¬⊢M</a> <a id="24412" href="/PLFA-zh/Inference/#24399" class="Bound">⊢M</a> <a id="24415" class="Symbol">})</a>
<a id="24418" class="Symbol">...</a> <a id="24422" class="Symbol">|</a> <a id="24424" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24428" href="/PLFA-zh/Inference/#24428" class="Bound">⊢M</a>              <a id="24444" class="Symbol">=</a>  <a id="24447" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24451" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="24453" class="Bound">A</a> <a id="24455" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="24457" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="24460" href="/PLFA-zh/Inference/#24428" class="Bound">⊢M</a> <a id="24463" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>
<p>There are three cases:</p>

<ul>
  <li>
    <p>If the term is a variable <code class="highlighter-rouge">` x</code>, we use lookup as defined above:</p>

    <ul>
      <li>
        <p>If it fails, then <code class="highlighter-rouge">¬∃</code> is evidence that there is no <code class="highlighter-rouge">A</code> such
that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> holds.  Evidence that <code class="highlighter-rouge">Γ ⊢ ` x ↑ A</code> holds must
have the form <code class="highlighter-rouge">⊢` ∋x</code>, where <code class="highlighter-rouge">∋x</code> is evidence that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code>,
which yields a contradiction.</p>
      </li>
      <li>
        <p>If it succeeds, then <code class="highlighter-rouge">∋x</code> is evidence that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code>, and
hence <code class="highlighter-rouge">⊢′ ∋x</code> is evidence that <code class="highlighter-rouge">Γ ⊢ ` x ↑ A</code>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>If the term is an application <code class="highlighter-rouge">L · M</code>, we recurse on the function <code class="highlighter-rouge">L</code>:</p>

    <ul>
      <li>
        <p>If it fails, then <code class="highlighter-rouge">¬∃</code> is evidence that there is no type such
that <code class="highlighter-rouge">Γ ⊢ L ↑ _</code> holds.  Evidence that <code class="highlighter-rouge">Γ ⊢ L · M ↑ _</code> holds
must have the form <code class="highlighter-rouge">⊢L · _</code>, where <code class="highlighter-rouge">⊢L</code> is evidence that
<code class="highlighter-rouge">Γ ⊢ L ↑ _</code>, which yields a contradiction.</p>
      </li>
      <li>
        <p>If it succeeds, there are two possibilities:</p>

        <ul>
          <li>
            <p>One is that <code class="highlighter-rouge">⊢L</code> is evidence that <code class="highlighter-rouge">Γ ⊢ L ⦂ `ℕ</code>.  Evidence
that <code class="highlighter-rouge">Γ ⊢ L · M ↑ _</code> holds must have the form <code class="highlighter-rouge">⊢L′ · _</code> where
<code class="highlighter-rouge">⊢L′</code> is evidence that <code class="highlighter-rouge">Γ ⊢ L ↑ A ⇒ B</code> for some types <code class="highlighter-rouge">A</code> and
<code class="highlighter-rouge">B</code>.  Applying <code class="highlighter-rouge">uniq-↑</code> to <code class="highlighter-rouge">⊢L</code> and <code class="highlighter-rouge">⊢L′</code> yields a
contradiction, since <code class="highlighter-rouge">`ℕ</code> cannot equal <code class="highlighter-rouge">A ⇒ B</code>.</p>
          </li>
          <li>
            <p>The other is that <code class="highlighter-rouge">⊢L</code> is evidence that <code class="highlighter-rouge">Γ ⊢ L ↑ A ⇒ B</code>, in
which case we recurse on the argument <code class="highlighter-rouge">M</code>:</p>

            <ul>
              <li>
                <p>If it fails, then <code class="highlighter-rouge">¬⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> does
not hold.  By <code class="highlighter-rouge">¬arg</code> applied to <code class="highlighter-rouge">⊢L</code> and <code class="highlighter-rouge">¬⊢M</code>, it follows
that <code class="highlighter-rouge">Γ ⊢ L · M ↑ B</code> cannot hold.</p>
              </li>
              <li>
                <p>If it succeeds, then <code class="highlighter-rouge">⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code>,
and <code class="highlighter-rouge">⊢L · ⊢M</code> provides evidence that <code class="highlighter-rouge">Γ ⊢ L · M ↑ B</code>.</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>If the term is a switch <code class="highlighter-rouge">M ↓ A</code> from synthesised to inherited,
we recurse on the subterm <code class="highlighter-rouge">M</code>, supplying type <code class="highlighter-rouge">A</code> by inheritance:</p>

    <ul>
      <li>
        <p>If it fails, then <code class="highlighter-rouge">¬⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> does not
hold.  Evidence that <code class="highlighter-rouge">Γ ⊢ (M ↓ A) ↑ A</code> holds must have the
form <code class="highlighter-rouge">⊢↓ ⊢M</code> where <code class="highlighter-rouge">⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code> holds,
which yields a contradiction.</p>
      </li>
      <li>
        <p>If it succeeds, then <code class="highlighter-rouge">⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code>,
and <code class="highlighter-rouge">⊢↓ ⊢M</code> provides evidence that <code class="highlighter-rouge">Γ ⊢ (M ↓ A) ↑ A</code>.</p>
      </li>
    </ul>
  </li>
</ul>

<p>We next consider the code for inheritance:</p>
<pre class="Agda"><a id="26579" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26587" href="/PLFA-zh/Inference/#26587" class="Bound">Γ</a> <a id="26589" class="Symbol">(</a><a id="26590" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="26592" href="/PLFA-zh/Inference/#26592" class="Bound">x</a> <a id="26594" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="26596" href="/PLFA-zh/Inference/#26596" class="Bound">N</a><a id="26597" class="Symbol">)</a> <a id="26599" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>      <a id="26607" class="Symbol">=</a>  <a id="26610" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26614" class="Symbol">(λ())</a>
<a id="26620" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26628" href="/PLFA-zh/Inference/#26628" class="Bound">Γ</a> <a id="26630" class="Symbol">(</a><a id="26631" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="26633" href="/PLFA-zh/Inference/#26633" class="Bound">x</a> <a id="26635" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="26637" href="/PLFA-zh/Inference/#26637" class="Bound">N</a><a id="26638" class="Symbol">)</a> <a id="26640" class="Symbol">(</a><a id="26641" href="/PLFA-zh/Inference/#26641" class="Bound">A</a> <a id="26643" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="26645" href="/PLFA-zh/Inference/#26645" class="Bound">B</a><a id="26646" class="Symbol">)</a> <a id="26648" class="Keyword">with</a> <a id="26653" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26661" class="Symbol">(</a><a id="26662" href="/PLFA-zh/Inference/#26628" class="Bound">Γ</a> <a id="26664" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="26666" href="/PLFA-zh/Inference/#26633" class="Bound">x</a> <a id="26668" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="26670" href="/PLFA-zh/Inference/#26641" class="Bound">A</a><a id="26671" class="Symbol">)</a> <a id="26673" href="/PLFA-zh/Inference/#26637" class="Bound">N</a> <a id="26675" href="/PLFA-zh/Inference/#26645" class="Bound">B</a>
<a id="26677" class="Symbol">...</a> <a id="26681" class="Symbol">|</a> <a id="26683" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="26686" href="/PLFA-zh/Inference/#26686" class="Bound">¬⊢N</a>                <a id="26705" class="Symbol">=</a>  <a id="26708" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26712" class="Symbol">(λ{</a> <a id="26716" class="Symbol">(</a><a id="26717" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a> <a id="26720" href="/PLFA-zh/Inference/#26720" class="Bound">⊢N</a><a id="26722" class="Symbol">)</a>  <a id="26725" class="Symbol">→</a>  <a id="26728" href="/PLFA-zh/Inference/#26686" class="Bound">¬⊢N</a> <a id="26732" href="/PLFA-zh/Inference/#26720" class="Bound">⊢N</a> <a id="26735" class="Symbol">})</a>
<a id="26738" class="Symbol">...</a> <a id="26742" class="Symbol">|</a> <a id="26744" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26748" href="/PLFA-zh/Inference/#26748" class="Bound">⊢N</a>                <a id="26766" class="Symbol">=</a>  <a id="26769" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26773" class="Symbol">(</a><a id="26774" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a> <a id="26777" href="/PLFA-zh/Inference/#26748" class="Bound">⊢N</a><a id="26779" class="Symbol">)</a>
<a id="26781" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26789" href="/PLFA-zh/Inference/#26789" class="Bound">Γ</a> <a id="26791" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="26797" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>          <a id="26809" class="Symbol">=</a>  <a id="26812" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26816" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a>
<a id="26822" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26830" href="/PLFA-zh/Inference/#26830" class="Bound">Γ</a> <a id="26832" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="26838" class="Symbol">(</a><a id="26839" href="/PLFA-zh/Inference/#26839" class="Bound">A</a> <a id="26841" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="26843" href="/PLFA-zh/Inference/#26843" class="Bound">B</a><a id="26844" class="Symbol">)</a>     <a id="26850" class="Symbol">=</a>  <a id="26853" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26857" class="Symbol">(λ())</a>
<a id="26863" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26871" href="/PLFA-zh/Inference/#26871" class="Bound">Γ</a> <a id="26873" class="Symbol">(</a><a id="26874" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="26879" href="/PLFA-zh/Inference/#26879" class="Bound">M</a><a id="26880" class="Symbol">)</a> <a id="26882" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="26885" class="Keyword">with</a> <a id="26890" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="26898" href="/PLFA-zh/Inference/#26871" class="Bound">Γ</a> <a id="26900" href="/PLFA-zh/Inference/#26879" class="Bound">M</a> <a id="26902" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>
<a id="26905" class="Symbol">...</a> <a id="26909" class="Symbol">|</a> <a id="26911" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="26914" href="/PLFA-zh/Inference/#26914" class="Bound">¬⊢M</a>                <a id="26933" class="Symbol">=</a>  <a id="26936" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26940" class="Symbol">(λ{</a> <a id="26944" class="Symbol">(</a><a id="26945" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="26950" href="/PLFA-zh/Inference/#26950" class="Bound">⊢M</a><a id="26952" class="Symbol">)</a>  <a id="26955" class="Symbol">→</a>  <a id="26958" href="/PLFA-zh/Inference/#26914" class="Bound">¬⊢M</a> <a id="26962" href="/PLFA-zh/Inference/#26950" class="Bound">⊢M</a> <a id="26965" class="Symbol">})</a>
<a id="26968" class="Symbol">...</a> <a id="26972" class="Symbol">|</a> <a id="26974" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26978" href="/PLFA-zh/Inference/#26978" class="Bound">⊢M</a>                <a id="26996" class="Symbol">=</a>  <a id="26999" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27003" class="Symbol">(</a><a id="27004" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="27009" href="/PLFA-zh/Inference/#26978" class="Bound">⊢M</a><a id="27011" class="Symbol">)</a>
<a id="27013" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27021" href="/PLFA-zh/Inference/#27021" class="Bound">Γ</a> <a id="27023" class="Symbol">(</a><a id="27024" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="27029" href="/PLFA-zh/Inference/#27029" class="Bound">M</a><a id="27030" class="Symbol">)</a> <a id="27032" class="Symbol">(</a><a id="27033" href="/PLFA-zh/Inference/#27033" class="Bound">A</a> <a id="27035" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="27037" href="/PLFA-zh/Inference/#27037" class="Bound">B</a><a id="27038" class="Symbol">)</a>  <a id="27041" class="Symbol">=</a>  <a id="27044" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27048" class="Symbol">(λ())</a>
<a id="27054" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27062" href="/PLFA-zh/Inference/#27062" class="Bound">Γ</a> <a id="27064" class="Symbol">(</a><a id="27065" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case</a> <a id="27071" href="/PLFA-zh/Inference/#27071" class="Bound">L</a> <a id="27073" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">[zero⇒</a> <a id="27080" href="/PLFA-zh/Inference/#27080" class="Bound">M</a> <a id="27082" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">|suc</a> <a id="27087" href="/PLFA-zh/Inference/#27087" class="Bound">x</a> <a id="27089" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">⇒</a> <a id="27091" href="/PLFA-zh/Inference/#27091" class="Bound">N</a> <a id="27093" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">]</a><a id="27094" class="Symbol">)</a> <a id="27096" href="/PLFA-zh/Inference/#27096" class="Bound">A</a> <a id="27098" class="Keyword">with</a> <a id="27103" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="27114" href="/PLFA-zh/Inference/#27062" class="Bound">Γ</a> <a id="27116" href="/PLFA-zh/Inference/#27071" class="Bound">L</a>
<a id="27118" class="Symbol">...</a> <a id="27122" class="Symbol">|</a> <a id="27124" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="27127" href="/PLFA-zh/Inference/#27127" class="Bound">¬∃</a>                 <a id="27146" class="Symbol">=</a>  <a id="27149" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27153" class="Symbol">(λ{</a> <a id="27157" class="Symbol">(</a><a id="27158" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="27164" href="/PLFA-zh/Inference/#27164" class="Bound">⊢L</a>  <a id="27168" class="Symbol">_</a> <a id="27170" class="Symbol">_)</a> <a id="27173" class="Symbol">→</a> <a id="27175" href="/PLFA-zh/Inference/#27127" class="Bound">¬∃</a> <a id="27178" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="27180" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="27183" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="27185" href="/PLFA-zh/Inference/#27164" class="Bound">⊢L</a> <a id="27188" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a><a id="27189" class="Symbol">})</a>
<a id="27192" class="Symbol">...</a> <a id="27196" class="Symbol">|</a> <a id="27198" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27202" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="27204" class="Symbol">_</a> <a id="27206" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="27208" class="Symbol">_</a> <a id="27210" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="27212" href="/PLFA-zh/Inference/#27212" class="Bound">⊢L</a> <a id="27215" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>    <a id="27220" class="Symbol">=</a>  <a id="27223" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27227" class="Symbol">(λ{</a> <a id="27231" class="Symbol">(</a><a id="27232" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="27238" href="/PLFA-zh/Inference/#27238" class="Bound">⊢L′</a> <a id="27242" class="Symbol">_</a> <a id="27244" class="Symbol">_)</a> <a id="27247" class="Symbol">→</a> <a id="27249" href="/PLFA-zh/Inference/#17657" class="Function">ℕ≢⇒</a> <a id="27253" class="Symbol">(</a><a id="27254" href="/PLFA-zh/Inference/#18668" class="Function">uniq-↑</a> <a id="27261" href="/PLFA-zh/Inference/#27238" class="Bound">⊢L′</a> <a id="27265" href="/PLFA-zh/Inference/#27212" class="Bound">⊢L</a><a id="27267" class="Symbol">)</a> <a id="27269" class="Symbol">})</a>   
<a id="27275" class="Symbol">...</a> <a id="27279" class="Symbol">|</a> <a id="27281" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27285" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="27287" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="27290" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>    <a id="27295" href="/PLFA-zh/Inference/#27295" class="Bound">⊢L</a> <a id="27298" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="27300" class="Keyword">with</a> <a id="27305" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27313" class="Bound">Γ</a> <a id="27315" class="Bound">M</a> <a id="27317" class="Bound">A</a>
<a id="27319" class="Symbol">...</a>    <a id="27326" class="Symbol">|</a> <a id="27328" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="27331" href="/PLFA-zh/Inference/#27331" class="Bound">¬⊢M</a>             <a id="27347" class="Symbol">=</a>  <a id="27350" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27354" class="Symbol">(λ{</a> <a id="27358" class="Symbol">(</a><a id="27359" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="27365" class="Symbol">_</a> <a id="27367" href="/PLFA-zh/Inference/#27367" class="Bound">⊢M</a> <a id="27370" class="Symbol">_)</a> <a id="27373" class="Symbol">→</a> <a id="27375" href="/PLFA-zh/Inference/#27331" class="Bound">¬⊢M</a> <a id="27379" href="/PLFA-zh/Inference/#27367" class="Bound">⊢M</a> <a id="27382" class="Symbol">})</a>
<a id="27385" class="Symbol">...</a>    <a id="27392" class="Symbol">|</a> <a id="27394" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27398" href="/PLFA-zh/Inference/#27398" class="Bound">⊢M</a> <a id="27401" class="Keyword">with</a> <a id="27406" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27414" class="Symbol">(</a><a id="27415" class="Bound">Γ</a> <a id="27417" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="27419" class="Bound">x</a> <a id="27421" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="27423" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="27425" class="Symbol">)</a> <a id="27427" class="Bound">N</a> <a id="27429" class="Bound">A</a>
<a id="27431" class="Symbol">...</a>       <a id="27441" class="Symbol">|</a> <a id="27443" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="27446" href="/PLFA-zh/Inference/#27446" class="Bound">¬⊢N</a>          <a id="27459" class="Symbol">=</a>  <a id="27462" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27466" class="Symbol">(λ{</a> <a id="27470" class="Symbol">(</a><a id="27471" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="27477" class="Symbol">_</a> <a id="27479" class="Symbol">_</a> <a id="27481" href="/PLFA-zh/Inference/#27481" class="Bound">⊢N</a><a id="27483" class="Symbol">)</a> <a id="27485" class="Symbol">→</a> <a id="27487" href="/PLFA-zh/Inference/#27446" class="Bound">¬⊢N</a> <a id="27491" href="/PLFA-zh/Inference/#27481" class="Bound">⊢N</a> <a id="27494" class="Symbol">})</a>
<a id="27497" class="Symbol">...</a>       <a id="27507" class="Symbol">|</a> <a id="27509" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27513" href="/PLFA-zh/Inference/#27513" class="Bound">⊢N</a>          <a id="27525" class="Symbol">=</a>  <a id="27528" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27532" class="Symbol">(</a><a id="27533" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="27539" class="Bound">⊢L</a> <a id="27542" class="Bound">⊢M</a> <a id="27545" href="/PLFA-zh/Inference/#27513" class="Bound">⊢N</a><a id="27547" class="Symbol">)</a>
<a id="27549" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27557" href="/PLFA-zh/Inference/#27557" class="Bound">Γ</a> <a id="27559" class="Symbol">(</a><a id="27560" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">μ</a> <a id="27562" href="/PLFA-zh/Inference/#27562" class="Bound">x</a> <a id="27564" href="/PLFA-zh/Inference/#12671" class="InductiveConstructor Operator">⇒</a> <a id="27566" href="/PLFA-zh/Inference/#27566" class="Bound">N</a><a id="27567" class="Symbol">)</a> <a id="27569" href="/PLFA-zh/Inference/#27569" class="Bound">A</a> <a id="27571" class="Keyword">with</a> <a id="27576" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27584" class="Symbol">(</a><a id="27585" href="/PLFA-zh/Inference/#27557" class="Bound">Γ</a> <a id="27587" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="27589" href="/PLFA-zh/Inference/#27562" class="Bound">x</a> <a id="27591" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="27593" href="/PLFA-zh/Inference/#27569" class="Bound">A</a><a id="27594" class="Symbol">)</a> <a id="27596" href="/PLFA-zh/Inference/#27566" class="Bound">N</a> <a id="27598" href="/PLFA-zh/Inference/#27569" class="Bound">A</a>
<a id="27600" class="Symbol">...</a> <a id="27604" class="Symbol">|</a> <a id="27606" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="27609" href="/PLFA-zh/Inference/#27609" class="Bound">¬⊢N</a>                <a id="27628" class="Symbol">=</a>  <a id="27631" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27635" class="Symbol">(λ{</a> <a id="27639" class="Symbol">(</a><a id="27640" href="/PLFA-zh/Inference/#15337" class="InductiveConstructor">⊢μ</a> <a id="27643" href="/PLFA-zh/Inference/#27643" class="Bound">⊢N</a><a id="27645" class="Symbol">)</a> <a id="27647" class="Symbol">→</a> <a id="27649" href="/PLFA-zh/Inference/#27609" class="Bound">¬⊢N</a> <a id="27653" href="/PLFA-zh/Inference/#27643" class="Bound">⊢N</a> <a id="27656" class="Symbol">})</a>
<a id="27659" class="Symbol">...</a> <a id="27663" class="Symbol">|</a> <a id="27665" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27669" href="/PLFA-zh/Inference/#27669" class="Bound">⊢N</a>                <a id="27687" class="Symbol">=</a>  <a id="27690" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27694" class="Symbol">(</a><a id="27695" href="/PLFA-zh/Inference/#15337" class="InductiveConstructor">⊢μ</a> <a id="27698" href="/PLFA-zh/Inference/#27669" class="Bound">⊢N</a><a id="27700" class="Symbol">)</a>
<a id="27702" href="/PLFA-zh/Inference/#23666" class="Function">inherit</a> <a id="27710" href="/PLFA-zh/Inference/#27710" class="Bound">Γ</a> <a id="27712" class="Symbol">(</a><a id="27713" href="/PLFA-zh/Inference/#27713" class="Bound">M</a> <a id="27715" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="27716" class="Symbol">)</a> <a id="27718" href="/PLFA-zh/Inference/#27718" class="Bound">B</a> <a id="27720" class="Keyword">with</a> <a id="27725" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="27736" href="/PLFA-zh/Inference/#27710" class="Bound">Γ</a> <a id="27738" href="/PLFA-zh/Inference/#27713" class="Bound">M</a>
<a id="27740" class="Symbol">...</a> <a id="27744" class="Symbol">|</a> <a id="27746" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27750" href="/PLFA-zh/Inference/#27750" class="Bound">¬∃</a>                <a id="27768" class="Symbol">=</a>  <a id="27771" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27775" class="Symbol">(λ{</a> <a id="27779" class="Symbol">(</a><a id="27780" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="27783" href="/PLFA-zh/Inference/#27783" class="Bound">⊢M</a> <a id="27786" class="Symbol">_)</a> <a id="27789" class="Symbol">→</a> <a id="27791" href="/PLFA-zh/Inference/#27750" class="Bound">¬∃</a> <a id="27794" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="27796" class="Symbol">_</a> <a id="27798" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="27800" href="/PLFA-zh/Inference/#27783" class="Bound">⊢M</a> <a id="27803" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="27805" class="Symbol">})</a>
<a id="27808" class="Symbol">...</a> <a id="27812" class="Symbol">|</a> <a id="27814" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27818" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="27820" href="/PLFA-zh/Inference/#27820" class="Bound">A</a> <a id="27822" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="27824" href="/PLFA-zh/Inference/#27824" class="Bound">⊢M</a> <a id="27827" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="27829" class="Keyword">with</a> <a id="27834" href="/PLFA-zh/Inference/#27820" class="Bound">A</a> <a id="27836" href="/PLFA-zh/Inference/#16953" class="Function Operator">≟Tp</a> <a id="27840" class="Bound">B</a>
<a id="27842" class="Symbol">...</a>   <a id="27848" class="Symbol">|</a> <a id="27850" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27854" href="/PLFA-zh/Inference/#27854" class="Bound">A≢B</a>             <a id="27870" class="Symbol">=</a>  <a id="27873" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27877" class="Symbol">(</a><a id="27878" href="/PLFA-zh/Inference/#22370" class="Function">¬switch</a> <a id="27886" class="Bound">⊢M</a> <a id="27889" href="/PLFA-zh/Inference/#27854" class="Bound">A≢B</a><a id="27892" class="Symbol">)</a>
<a id="27894" class="Symbol">...</a>   <a id="27900" class="Symbol">|</a> <a id="27902" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27906" href="/PLFA-zh/Inference/#27906" class="Bound">A≡B</a>             <a id="27922" class="Symbol">=</a>  <a id="27925" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27929" class="Symbol">(</a><a id="27930" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="27933" class="Bound">⊢M</a> <a id="27936" href="/PLFA-zh/Inference/#27906" class="Bound">A≡B</a><a id="27939" class="Symbol">)</a></pre>
<p>We consider only the cases for abstraction and
and for switching from inherited to synthesized:</p>

<ul>
  <li>
    <p>If the term is an abstraction <code class="highlighter-rouge">ƛ x ⇒ N</code> and the inherited type
is <code class="highlighter-rouge">`ℕ</code>, then it is trivial that <code class="highlighter-rouge">Γ ⊢ (ƛ x ⇒ N) ↓ `ℕ</code>
cannot hold.</p>
  </li>
  <li>
    <p>If the term is an abstraction <code class="highlighter-rouge">ƛ x ⇒ N</code> and the inherited type
is <code class="highlighter-rouge">A ⇒ B</code>, then we recurse with context <code class="highlighter-rouge">Γ , x ⦂ A</code> on subterm
<code class="highlighter-rouge">N</code> inheriting type <code class="highlighter-rouge">B</code>:</p>

    <ul>
      <li>
        <p>If it fails, then <code class="highlighter-rouge">¬⊢N</code> is evidence that <code class="highlighter-rouge">Γ , x ⦂ A ⊢ N ↓ B</code>
does not hold.  Evidence that <code class="highlighter-rouge">Γ ⊢ (ƛ x ⇒ N) ↓ A ⇒ B</code> holds
must have the form <code class="highlighter-rouge">⊢ƛ ⊢N</code> where <code class="highlighter-rouge">⊢N</code> is evidence that
<code class="highlighter-rouge">Γ , x ⦂ A ⊢ N ↓ B</code>, which yields a contradiction.</p>
      </li>
      <li>
        <p>If it succeeds, then <code class="highlighter-rouge">⊢N</code> is evidence that <code class="highlighter-rouge">Γ , x ⦂ A ⊢ N ↓ B</code>
holds, and <code class="highlighter-rouge">⊢ƛ ⊢N</code> provides evidence that <code class="highlighter-rouge">Γ ⊢ (ƛ x ⇒ N) ↓ A ⇒ B</code>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>If the term is a switch <code class="highlighter-rouge">M ↑</code> from inherited to synthesised,
we recurse on the subterm <code class="highlighter-rouge">M</code>:</p>

    <ul>
      <li>
        <p>If it fails, then <code class="highlighter-rouge">¬∃</code> is evidence there is no <code class="highlighter-rouge">A</code> such
that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> holds.  Evidence that <code class="highlighter-rouge">Γ ⊢ (M ↑) ↓ B</code> holds
must have the form <code class="highlighter-rouge">⊢↑ ⊢M _</code> where <code class="highlighter-rouge">⊢M</code> is evidence that
<code class="highlighter-rouge">Γ ⊢ M ↑ _</code>, which yields a contradiction.</p>
      </li>
      <li>
        <p>If it succeeds, then <code class="highlighter-rouge">⊢M</code> is evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code> holds.
We apply <code class="highlighter-rouge">_≟Tp_</code> do decide whether <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are equal:</p>

        <ul>
          <li>
            <p>If it fails, then <code class="highlighter-rouge">A≢B</code> is evidence that <code class="highlighter-rouge">A ≢ B</code>.
By <code class="highlighter-rouge">¬switch</code> applied to <code class="highlighter-rouge">⊢M</code> and <code class="highlighter-rouge">A≢B</code> it follow that
<code class="highlighter-rouge">Γ ⊢ (M ↑) ↓ B</code> cannot hold.</p>
          </li>
          <li>
            <p>If it succeeds, then <code class="highlighter-rouge">A≡B</code> is evidence that <code class="highlighter-rouge">A ≡ B</code>,
and <code class="highlighter-rouge">⊢↑ ⊢M A≡B</code> provides evidence that <code class="highlighter-rouge">Γ ⊢ (M ↑) ↓ B</code>.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The remaining cases are similar, and their code can pretty much be
read directly from the corresponding typing rules.</p>

<h2 id="testing-the-example-terms">Testing the example terms</h2>

<p>First, we copy a function introduced earlier that makes it easy to
compute the evidence that two variable names are distinct:</p>
<pre class="Agda"><a id="_≠_"></a><a id="29758" href="/PLFA-zh/Inference/#29758" class="Function Operator">_≠_</a> <a id="29762" class="Symbol">:</a> <a id="29764" class="Symbol">∀</a> <a id="29766" class="Symbol">(</a><a id="29767" href="/PLFA-zh/Inference/#29767" class="Bound">x</a> <a id="29769" href="/PLFA-zh/Inference/#29769" class="Bound">y</a> <a id="29771" class="Symbol">:</a> <a id="29773" href="/PLFA-zh/Inference/#11865" class="Function">Id</a><a id="29775" class="Symbol">)</a> <a id="29777" class="Symbol">→</a> <a id="29779" href="/PLFA-zh/Inference/#29767" class="Bound">x</a> <a id="29781" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="29783" href="/PLFA-zh/Inference/#29769" class="Bound">y</a>
<a id="29785" href="/PLFA-zh/Inference/#29785" class="Bound">x</a> <a id="29787" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="29789" href="/PLFA-zh/Inference/#29789" class="Bound">y</a>  <a id="29792" class="Keyword">with</a> <a id="29797" href="/PLFA-zh/Inference/#29785" class="Bound">x</a> <a id="29799" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="29801" href="/PLFA-zh/Inference/#29789" class="Bound">y</a>
<a id="29803" class="Symbol">...</a>       <a id="29813" class="Symbol">|</a> <a id="29815" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="29819" href="/PLFA-zh/Inference/#29819" class="Bound">x≢y</a>  <a id="29824" class="Symbol">=</a>  <a id="29827" href="/PLFA-zh/Inference/#29819" class="Bound">x≢y</a>
<a id="29831" class="Symbol">...</a>       <a id="29841" class="Symbol">|</a> <a id="29843" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="29847" class="Symbol">_</a>    <a id="29852" class="Symbol">=</a>  <a id="29855" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="29862" href="/PLFA-zh/Inference/#29891" class="Postulate">impossible</a>
  <a id="29875" class="Keyword">where</a> <a id="29881" class="Keyword">postulate</a> <a id="29891" href="/PLFA-zh/Inference/#29891" class="Postulate">impossible</a> <a id="29902" class="Symbol">:</a> <a id="29904" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a></pre>

<p>Here is the result of typing two plus two on naturals:</p>
<pre class="Agda"><a id="⊢2+2"></a><a id="29986" href="/PLFA-zh/Inference/#29986" class="Function">⊢2+2</a> <a id="29991" class="Symbol">:</a> <a id="29993" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="29995" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="29997" href="/PLFA-zh/Inference/#13383" class="Function">2+2</a> <a id="30001" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="30003" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>
<a id="30006" href="/PLFA-zh/Inference/#29986" class="Function">⊢2+2</a> <a id="30011" class="Symbol">=</a>
  <a id="30015" class="Symbol">(</a><a id="30016" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a>
   <a id="30022" class="Symbol">(</a><a id="30023" href="/PLFA-zh/Inference/#15337" class="InductiveConstructor">⊢μ</a>
    <a id="30030" class="Symbol">(</a><a id="30031" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
     <a id="30039" class="Symbol">(</a><a id="30040" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
      <a id="30049" class="Symbol">(</a><a id="30050" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="30056" class="Symbol">(</a><a id="30057" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="30060" class="Symbol">(</a><a id="30061" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="30063" class="Symbol">(</a><a id="30064" class="String">&quot;m&quot;</a> <a id="30068" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="30070" class="String">&quot;n&quot;</a><a id="30073" class="Symbol">)</a> <a id="30075" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="30076" class="Symbol">))</a> <a id="30079" class="Symbol">(</a><a id="30080" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="30083" class="Symbol">(</a><a id="30084" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="30087" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="30088" class="Symbol">)</a> <a id="30090" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="30094" class="Symbol">)</a>
       <a id="30103" class="Symbol">(</a><a id="30104" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a>
        <a id="30117" class="Symbol">(</a><a id="30118" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a>
         <a id="30130" class="Symbol">(</a><a id="30131" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a>
          <a id="30144" class="Symbol">(</a><a id="30145" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="30147" class="Symbol">(</a><a id="30148" class="String">&quot;p&quot;</a> <a id="30152" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="30154" class="String">&quot;m&quot;</a><a id="30157" class="Symbol">)</a>
           <a id="30170" class="Symbol">(</a><a id="30171" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="30173" class="Symbol">(</a><a id="30174" class="String">&quot;p&quot;</a> <a id="30178" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="30180" class="String">&quot;n&quot;</a><a id="30183" class="Symbol">)</a>
            <a id="30197" class="Symbol">(</a><a id="30198" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="30200" class="Symbol">(</a><a id="30201" class="String">&quot;p&quot;</a> <a id="30205" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="30207" class="String">&quot;m&quot;</a><a id="30210" class="Symbol">)</a> <a id="30212" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="30213" class="Symbol">)))</a>
          <a id="30227" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="30229" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="30232" class="Symbol">(</a><a id="30233" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="30236" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="30237" class="Symbol">)</a> <a id="30239" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
          <a id="30254" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="30256" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="30259" class="Symbol">(</a><a id="30260" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="30263" class="Symbol">(</a><a id="30264" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="30266" class="Symbol">(</a><a id="30267" class="String">&quot;n&quot;</a> <a id="30271" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="30273" class="String">&quot;m&quot;</a><a id="30276" class="Symbol">)</a> <a id="30278" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="30279" class="Symbol">))</a> <a id="30282" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="30286" class="Symbol">)</a>
         <a id="30297" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="30301" class="Symbol">))))))</a>
   <a id="30311" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="30313" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="30318" class="Symbol">(</a><a id="30319" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="30324" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a><a id="30329" class="Symbol">)</a>
   <a id="30334" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="30336" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="30341" class="Symbol">(</a><a id="30342" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="30347" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a><a id="30352" class="Symbol">))</a></pre>
<p>We confirm that synthesis on the relevant term returns
natural as the type and the above derivation:</p>
<pre class="Agda"><a id="30480" href="/PLFA-zh/Inference/#30480" class="Function">_</a> <a id="30482" class="Symbol">:</a> <a id="30484" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="30495" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="30497" href="/PLFA-zh/Inference/#13383" class="Function">2+2</a> <a id="30501" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="30503" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="30507" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="30509" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="30512" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="30514" href="/PLFA-zh/Inference/#29986" class="Function">⊢2+2</a> <a id="30519" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="30521" class="Symbol">_</a> <a id="30523" class="Symbol">=</a> <a id="30525" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Indeed, the above derivation was computed by evaluating the term on
the left, with minor editing of the result.  The only editing required
was to replace Agda’s representation of the evidence that two strings
are unequal (which it cannot print nor read) by equivalent calls to
<code class="highlighter-rouge">_≠_</code>.</p>

<p>Here is the result of typing two plus two with Church numerals:</p>
<pre class="Agda"><a id="⊢2+2ᶜ"></a><a id="30903" href="/PLFA-zh/Inference/#30903" class="Function">⊢2+2ᶜ</a> <a id="30909" class="Symbol">:</a> <a id="30911" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="30913" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="30915" href="/PLFA-zh/Inference/#13916" class="Function">2+2ᶜ</a> <a id="30920" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="30922" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a>
<a id="30925" href="/PLFA-zh/Inference/#30903" class="Function">⊢2+2ᶜ</a> <a id="30931" class="Symbol">=</a>
  <a id="30935" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a>
  <a id="30940" class="Symbol">(</a><a id="30941" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
   <a id="30947" class="Symbol">(</a><a id="30948" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
    <a id="30955" class="Symbol">(</a><a id="30956" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
     <a id="30964" class="Symbol">(</a><a id="30965" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
      <a id="30974" class="Symbol">(</a><a id="30975" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a>
       <a id="30985" class="Symbol">(</a><a id="30986" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a>
        <a id="30997" class="Symbol">(</a><a id="30998" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31000" class="Symbol">(</a><a id="31001" class="String">&quot;m&quot;</a> <a id="31005" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31007" class="String">&quot;z&quot;</a><a id="31010" class="Symbol">)</a>
         <a id="31021" class="Symbol">(</a><a id="31022" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31024" class="Symbol">(</a><a id="31025" class="String">&quot;m&quot;</a> <a id="31029" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31031" class="String">&quot;s&quot;</a><a id="31034" class="Symbol">)</a>
          <a id="31046" class="Symbol">(</a><a id="31047" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31049" class="Symbol">(</a><a id="31050" class="String">&quot;m&quot;</a> <a id="31054" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31056" class="String">&quot;n&quot;</a><a id="31059" class="Symbol">)</a> <a id="31061" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31062" class="Symbol">)))</a>
        <a id="31074" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31076" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31079" class="Symbol">(</a><a id="31080" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31083" class="Symbol">(</a><a id="31084" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31086" class="Symbol">(</a><a id="31087" class="String">&quot;s&quot;</a> <a id="31091" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31093" class="String">&quot;z&quot;</a><a id="31096" class="Symbol">)</a> <a id="31098" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31099" class="Symbol">))</a> <a id="31102" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
        <a id="31115" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a>
        <a id="31125" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a>
        <a id="31136" class="Symbol">(</a><a id="31137" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a>
         <a id="31149" class="Symbol">(</a><a id="31150" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31152" class="Symbol">(</a><a id="31153" class="String">&quot;n&quot;</a> <a id="31157" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31159" class="String">&quot;z&quot;</a><a id="31162" class="Symbol">)</a>
          <a id="31174" class="Symbol">(</a><a id="31175" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31177" class="Symbol">(</a><a id="31178" class="String">&quot;n&quot;</a> <a id="31182" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31184" class="String">&quot;s&quot;</a><a id="31187" class="Symbol">)</a> <a id="31189" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31190" class="Symbol">))</a>
         <a id="31202" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31204" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31207" class="Symbol">(</a><a id="31208" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31211" class="Symbol">(</a><a id="31212" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31214" class="Symbol">(</a><a id="31215" class="String">&quot;s&quot;</a> <a id="31219" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31221" class="String">&quot;z&quot;</a><a id="31224" class="Symbol">)</a> <a id="31226" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31227" class="Symbol">))</a> <a id="31230" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
         <a id="31244" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31246" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31249" class="Symbol">(</a><a id="31250" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31253" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31254" class="Symbol">)</a> <a id="31256" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31260" class="Symbol">)</a>
        <a id="31270" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31274" class="Symbol">)</a>
       <a id="31283" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31287" class="Symbol">)))))</a>
  <a id="31295" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a>
  <a id="31299" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
  <a id="31304" class="Symbol">(</a><a id="31305" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
   <a id="31311" class="Symbol">(</a><a id="31312" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a>
    <a id="31319" class="Symbol">(</a><a id="31320" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31323" class="Symbol">(</a><a id="31324" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31326" class="Symbol">(</a><a id="31327" class="String">&quot;s&quot;</a> <a id="31331" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31333" class="String">&quot;z&quot;</a><a id="31336" class="Symbol">)</a> <a id="31338" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31339" class="Symbol">)</a> <a id="31341" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a>
     <a id="31348" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31351" class="Symbol">(</a><a id="31352" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31355" class="Symbol">(</a><a id="31356" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31358" class="Symbol">(</a><a id="31359" class="String">&quot;s&quot;</a> <a id="31363" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31365" class="String">&quot;z&quot;</a><a id="31368" class="Symbol">)</a> <a id="31370" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31371" class="Symbol">)</a> <a id="31373" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31375" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31378" class="Symbol">(</a><a id="31379" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31382" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31383" class="Symbol">)</a> <a id="31385" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31389" class="Symbol">)</a>
     <a id="31396" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31400" class="Symbol">)</a>
    <a id="31406" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31410" class="Symbol">))</a>
  <a id="31415" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a>
  <a id="31419" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
  <a id="31424" class="Symbol">(</a><a id="31425" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a>
   <a id="31431" class="Symbol">(</a><a id="31432" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a>
    <a id="31439" class="Symbol">(</a><a id="31440" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31443" class="Symbol">(</a><a id="31444" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31446" class="Symbol">(</a><a id="31447" class="String">&quot;s&quot;</a> <a id="31451" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31453" class="String">&quot;z&quot;</a><a id="31456" class="Symbol">)</a> <a id="31458" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31459" class="Symbol">)</a> <a id="31461" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a>
     <a id="31468" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31471" class="Symbol">(</a><a id="31472" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31475" class="Symbol">(</a><a id="31476" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="31478" class="Symbol">(</a><a id="31479" class="String">&quot;s&quot;</a> <a id="31483" href="/PLFA-zh/Inference/#29758" class="Function Operator">≠</a> <a id="31485" class="String">&quot;z&quot;</a><a id="31488" class="Symbol">)</a> <a id="31490" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31491" class="Symbol">)</a> <a id="31493" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31495" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31498" class="Symbol">(</a><a id="31499" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31502" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31503" class="Symbol">)</a> <a id="31505" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31509" class="Symbol">)</a>
     <a id="31516" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31520" class="Symbol">)</a>
    <a id="31526" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31530" class="Symbol">))</a>
  <a id="31535" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31537" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a> <a id="31540" class="Symbol">(</a><a id="31541" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="31546" class="Symbol">(</a><a id="31547" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="31550" class="Symbol">(</a><a id="31551" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="31554" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a><a id="31555" class="Symbol">)</a> <a id="31557" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="31561" class="Symbol">))</a>
  <a id="31566" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="31568" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a></pre>
<p>We confirm that synthesis on the relevant term returns
natural as the type and the above derivation:</p>
<pre class="Agda"><a id="31699" href="/PLFA-zh/Inference/#31699" class="Function">_</a> <a id="31701" class="Symbol">:</a> <a id="31703" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="31714" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="31716" href="/PLFA-zh/Inference/#13916" class="Function">2+2ᶜ</a> <a id="31721" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="31723" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="31727" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="31729" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="31732" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="31734" href="/PLFA-zh/Inference/#30903" class="Function">⊢2+2ᶜ</a> <a id="31740" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="31742" class="Symbol">_</a> <a id="31744" class="Symbol">=</a> <a id="31746" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Again, the above derivation was computed by evaluating the
term on the left and editing.</p>

<h2 id="testing-the-error-cases">Testing the error cases</h2>

<p>It is important not just to check that code works as intended,
but also that it fails as intended.  Here are checks for
several possible errors:</p>

<p>Unbound variable:</p>
<pre class="Agda"><a id="32057" href="/PLFA-zh/Inference/#32057" class="Function">_</a> <a id="32059" class="Symbol">:</a> <a id="32061" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32072" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32074" class="Symbol">((</a><a id="32076" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="32078" class="String">&quot;x&quot;</a> <a id="32082" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="32084" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="32086" class="String">&quot;y&quot;</a> <a id="32090" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="32091" class="Symbol">)</a> <a id="32093" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32095" class="Symbol">(</a><a id="32096" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="32099" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="32101" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32103" class="Symbol">))</a> <a id="32106" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32108" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32111" class="Symbol">_</a>
<a id="32113" class="Symbol">_</a> <a id="32115" class="Symbol">=</a> <a id="32117" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Argument in application is ill-typed:</p>
<pre class="Agda"><a id="32185" href="/PLFA-zh/Inference/#32185" class="Function">_</a> <a id="32187" class="Symbol">:</a> <a id="32189" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32200" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32202" class="Symbol">(</a><a id="32203" href="/PLFA-zh/Inference/#13192" class="Function">plus</a> <a id="32208" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="32210" href="/PLFA-zh/Inference/#13872" class="Function">sucᶜ</a><a id="32214" class="Symbol">)</a> <a id="32216" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32218" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32221" class="Symbol">_</a>
<a id="32223" class="Symbol">_</a> <a id="32225" class="Symbol">=</a> <a id="32227" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Function in application is ill-typed:</p>
<pre class="Agda"><a id="32295" href="/PLFA-zh/Inference/#32295" class="Function">_</a> <a id="32297" class="Symbol">:</a> <a id="32299" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32310" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32312" class="Symbol">(</a><a id="32313" href="/PLFA-zh/Inference/#13192" class="Function">plus</a> <a id="32318" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="32320" href="/PLFA-zh/Inference/#13872" class="Function">sucᶜ</a> <a id="32325" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="32327" href="/PLFA-zh/Inference/#13155" class="Function">two</a><a id="32330" class="Symbol">)</a> <a id="32332" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32334" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32337" class="Symbol">_</a>
<a id="32339" class="Symbol">_</a> <a id="32341" class="Symbol">=</a> <a id="32343" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Function in application has type natural:</p>
<pre class="Agda"><a id="32415" href="/PLFA-zh/Inference/#32415" class="Function">_</a> <a id="32417" class="Symbol">:</a> <a id="32419" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32430" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32432" class="Symbol">((</a><a id="32434" href="/PLFA-zh/Inference/#13155" class="Function">two</a> <a id="32438" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32440" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32442" class="Symbol">)</a> <a id="32444" href="/PLFA-zh/Inference/#12360" class="InductiveConstructor Operator">·</a> <a id="32446" href="/PLFA-zh/Inference/#13155" class="Function">two</a><a id="32449" class="Symbol">)</a> <a id="32451" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32453" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32456" class="Symbol">_</a>
<a id="32458" class="Symbol">_</a> <a id="32460" class="Symbol">=</a> <a id="32462" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Abstraction inherits type natural:</p>
<pre class="Agda"><a id="32527" href="/PLFA-zh/Inference/#32527" class="Function">_</a> <a id="32529" class="Symbol">:</a> <a id="32531" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32542" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32544" class="Symbol">(</a><a id="32545" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="32550" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32552" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32554" class="Symbol">)</a> <a id="32556" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32558" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32561" class="Symbol">_</a>
<a id="32563" class="Symbol">_</a> <a id="32565" class="Symbol">=</a> <a id="32567" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Zero inherits a function type:</p>
<pre class="Agda"><a id="32628" href="/PLFA-zh/Inference/#32628" class="Function">_</a> <a id="32630" class="Symbol">:</a> <a id="32632" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32643" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32645" class="Symbol">(</a><a id="32646" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="32652" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32654" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="32657" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="32659" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32661" class="Symbol">)</a> <a id="32663" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32665" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32668" class="Symbol">_</a>
<a id="32670" class="Symbol">_</a> <a id="32672" class="Symbol">=</a> <a id="32674" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Successor inherits a function type:</p>
<pre class="Agda"><a id="32740" href="/PLFA-zh/Inference/#32740" class="Function">_</a> <a id="32742" class="Symbol">:</a> <a id="32744" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32755" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32757" class="Symbol">(</a><a id="32758" href="/PLFA-zh/Inference/#13155" class="Function">two</a> <a id="32762" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32764" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="32767" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="32769" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32771" class="Symbol">)</a> <a id="32773" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32775" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32778" class="Symbol">_</a>
<a id="32780" class="Symbol">_</a> <a id="32782" class="Symbol">=</a> <a id="32784" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Successor of an ill-typed term:</p>
<pre class="Agda"><a id="32846" href="/PLFA-zh/Inference/#32846" class="Function">_</a> <a id="32848" class="Symbol">:</a> <a id="32850" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32861" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="32863" class="Symbol">(</a><a id="32864" href="/PLFA-zh/Inference/#12564" class="InductiveConstructor Operator">`suc</a> <a id="32869" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="32874" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32876" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="32878" class="Symbol">)</a> <a id="32880" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32882" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="32885" class="Symbol">_</a>
<a id="32887" class="Symbol">_</a> <a id="32889" class="Symbol">=</a> <a id="32891" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Case of a term with a function type:</p>
<pre class="Agda"><a id="32958" href="/PLFA-zh/Inference/#32958" class="Function">_</a> <a id="32960" class="Symbol">:</a> <a id="32962" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="32973" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a>
      <a id="32981" class="Symbol">((</a><a id="32983" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case</a> <a id="32989" class="Symbol">(</a><a id="32990" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="32995" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="32997" href="/PLFA-zh/Inference/#13611" class="Function">Ch</a><a id="32999" class="Symbol">)</a> <a id="33001" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">[zero⇒</a> <a id="33008" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="33014" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">|suc</a> <a id="33019" class="String">&quot;x&quot;</a> <a id="33023" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">⇒</a> <a id="33025" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="33027" class="String">&quot;x&quot;</a> <a id="33031" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a> <a id="33033" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">]</a> <a id="33035" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="33037" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="33039" class="Symbol">)</a> <a id="33041" class="Symbol">)</a> <a id="33043" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="33045" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="33048" class="Symbol">_</a>
<a id="33050" class="Symbol">_</a> <a id="33052" class="Symbol">=</a> <a id="33054" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Case of an ill-typed term:</p>
<pre class="Agda"><a id="33111" href="/PLFA-zh/Inference/#33111" class="Function">_</a> <a id="33113" class="Symbol">:</a> <a id="33115" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="33126" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a>
      <a id="33134" class="Symbol">((</a><a id="33136" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">`case</a> <a id="33142" class="Symbol">(</a><a id="33143" href="/PLFA-zh/Inference/#13647" class="Function">twoᶜ</a> <a id="33148" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="33150" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="33152" class="Symbol">)</a> <a id="33154" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">[zero⇒</a> <a id="33161" href="/PLFA-zh/Inference/#12529" class="InductiveConstructor">`zero</a> <a id="33167" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">|suc</a> <a id="33172" class="String">&quot;x&quot;</a> <a id="33176" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">⇒</a> <a id="33178" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="33180" class="String">&quot;x&quot;</a> <a id="33184" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a> <a id="33186" href="/PLFA-zh/Inference/#12607" class="InductiveConstructor Operator">]</a> <a id="33188" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="33190" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="33192" class="Symbol">)</a> <a id="33194" class="Symbol">)</a> <a id="33196" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="33198" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="33201" class="Symbol">_</a>
<a id="33203" class="Symbol">_</a> <a id="33205" class="Symbol">=</a> <a id="33207" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Inherited and synthesised types disagree in a switch:</p>
<pre class="Agda"><a id="33291" href="/PLFA-zh/Inference/#33291" class="Function">_</a> <a id="33293" class="Symbol">:</a> <a id="33295" href="/PLFA-zh/Inference/#23568" class="Function">synthesize</a> <a id="33306" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="33308" class="Symbol">(((</a><a id="33311" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">ƛ</a> <a id="33313" class="String">&quot;x&quot;</a> <a id="33317" href="/PLFA-zh/Inference/#12481" class="InductiveConstructor Operator">⇒</a> <a id="33319" href="/PLFA-zh/Inference/#12319" class="InductiveConstructor Operator">`</a> <a id="33321" class="String">&quot;x&quot;</a> <a id="33325" href="/PLFA-zh/Inference/#12719" class="InductiveConstructor Operator">↑</a><a id="33326" class="Symbol">)</a> <a id="33328" href="/PLFA-zh/Inference/#12412" class="InductiveConstructor Operator">↓</a> <a id="33330" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="33333" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="33335" class="Symbol">(</a><a id="33336" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="33339" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="33341" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a><a id="33343" class="Symbol">)))</a> <a id="33347" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="33349" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="33352" class="Symbol">_</a>
<a id="33354" class="Symbol">_</a> <a id="33356" class="Symbol">=</a> <a id="33358" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h2 id="erasure">Erasure</h2>

<p>From the evidence that a decorated term has the correct type it is
easy to extract the corresponding inherently typed term.  We use the
name <code class="highlighter-rouge">DB</code> to refer to the code in
Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>.
It is easy to define an <em>erasure</em> function that takes evidence of a
type judgment into the corresponding inherently typed term.</p>

<p>First, we give code to erase a type:</p>
<pre class="Agda"><a id="∥_∥Tp"></a><a id="33772" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥_∥Tp</a> <a id="33778" class="Symbol">:</a> <a id="33780" href="/PLFA-zh/Inference/#11892" class="Datatype">Type</a> <a id="33785" class="Symbol">→</a> <a id="33787" href="/PLFA-zh/DeBruijn/#8174" class="Datatype">DB.Type</a>
<a id="33795" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="33797" href="/PLFA-zh/Inference/#11911" class="InductiveConstructor">`ℕ</a> <a id="33800" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a>             <a id="33816" class="Symbol">=</a>  <a id="33819" href="/PLFA-zh/DeBruijn/#8220" class="InductiveConstructor">DB.`ℕ</a>
<a id="33825" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="33827" href="/PLFA-zh/Inference/#33827" class="Bound">A</a> <a id="33829" href="/PLFA-zh/Inference/#11926" class="InductiveConstructor Operator">⇒</a> <a id="33831" href="/PLFA-zh/Inference/#33831" class="Bound">B</a> <a id="33833" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a>          <a id="33846" class="Symbol">=</a>  <a id="33849" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="33851" href="/PLFA-zh/Inference/#33827" class="Bound">A</a> <a id="33853" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a> <a id="33857" href="/PLFA-zh/DeBruijn/#8193" class="InductiveConstructor Operator">DB.⇒</a> <a id="33862" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="33864" href="/PLFA-zh/Inference/#33831" class="Bound">B</a> <a id="33866" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a></pre>
<p>It simply renames to the corresponding constructors in module <code class="highlighter-rouge">DB</code>.</p>

<p>Next, we give the code to erase a context:</p>
<pre class="Agda"><a id="∥_∥Cx"></a><a id="34006" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥_∥Cx</a> <a id="34012" class="Symbol">:</a> <a id="34014" href="/PLFA-zh/Inference/#11959" class="Datatype">Context</a> <a id="34022" class="Symbol">→</a> <a id="34024" href="/PLFA-zh/DeBruijn/#8358" class="Datatype">DB.Context</a>
<a id="34035" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34037" href="/PLFA-zh/Inference/#11981" class="InductiveConstructor">∅</a> <a id="34039" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a>              <a id="34056" class="Symbol">=</a>  <a id="34059" href="/PLFA-zh/DeBruijn/#8380" class="InductiveConstructor">DB.∅</a>
<a id="34064" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34066" href="/PLFA-zh/Inference/#34066" class="Bound">Γ</a> <a id="34068" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">,</a> <a id="34070" href="/PLFA-zh/Inference/#34070" class="Bound">x</a> <a id="34072" href="/PLFA-zh/Inference/#11999" class="InductiveConstructor Operator">⦂</a> <a id="34074" href="/PLFA-zh/Inference/#34074" class="Bound">A</a> <a id="34076" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a>      <a id="34085" class="Symbol">=</a>  <a id="34088" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34090" href="/PLFA-zh/Inference/#34066" class="Bound">Γ</a> <a id="34092" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a> <a id="34096" href="/PLFA-zh/DeBruijn/#8396" class="InductiveConstructor Operator">DB.,</a> <a id="34101" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="34103" href="/PLFA-zh/Inference/#34074" class="Bound">A</a> <a id="34105" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a></pre>
<p>It simply drops the variable names.</p>

<p>Next, we give the code to erase a lookup judgment:</p>
<pre class="Agda"><a id="∥_∥∋"></a><a id="34221" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥_∥∋</a> <a id="34226" class="Symbol">:</a> <a id="34228" class="Symbol">∀</a> <a id="34230" class="Symbol">{</a><a id="34231" href="/PLFA-zh/Inference/#34231" class="Bound">Γ</a> <a id="34233" href="/PLFA-zh/Inference/#34233" class="Bound">x</a> <a id="34235" href="/PLFA-zh/Inference/#34235" class="Bound">A</a><a id="34236" class="Symbol">}</a> <a id="34238" class="Symbol">→</a> <a id="34240" href="/PLFA-zh/Inference/#34231" class="Bound">Γ</a> <a id="34242" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">∋</a> <a id="34244" href="/PLFA-zh/Inference/#34233" class="Bound">x</a> <a id="34246" href="/PLFA-zh/Inference/#14236" class="Datatype Operator">⦂</a> <a id="34248" href="/PLFA-zh/Inference/#34235" class="Bound">A</a> <a id="34250" class="Symbol">→</a> <a id="34252" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34254" href="/PLFA-zh/Inference/#34231" class="Bound">Γ</a> <a id="34256" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a> <a id="34260" href="/PLFA-zh/DeBruijn/#9267" class="Datatype Operator">DB.∋</a> <a id="34265" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="34267" href="/PLFA-zh/Inference/#34235" class="Bound">A</a> <a id="34269" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a>
<a id="34273" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥</a> <a id="34275" href="/PLFA-zh/Inference/#14279" class="InductiveConstructor">Z</a> <a id="34277" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥∋</a>               <a id="34294" class="Symbol">=</a>  <a id="34297" href="/PLFA-zh/DeBruijn/#9303" class="InductiveConstructor">DB.Z</a>
<a id="34302" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥</a> <a id="34304" href="/PLFA-zh/Inference/#14347" class="InductiveConstructor">S</a> <a id="34306" href="/PLFA-zh/Inference/#34306" class="Bound">x≢</a> <a id="34309" href="/PLFA-zh/Inference/#34309" class="Bound">⊢x</a> <a id="34312" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥∋</a>         <a id="34323" class="Symbol">=</a>  <a id="34326" href="/PLFA-zh/DeBruijn/#9351" class="InductiveConstructor Operator">DB.S</a> <a id="34331" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥</a> <a id="34333" href="/PLFA-zh/Inference/#34309" class="Bound">⊢x</a> <a id="34336" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥∋</a></pre>
<p>It simply drops the evidence that variable names are distinct.</p>

<p>Finally, we give the code to erase a typing judgment.
Just as there are two mutually recursive typing judgments,
there are two mutually recursive erasure functions:</p>
<pre class="Agda"><a id="∥_∥⁺"></a><a id="34592" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥_∥⁺</a> <a id="34597" class="Symbol">:</a> <a id="34599" class="Symbol">∀</a> <a id="34601" class="Symbol">{</a><a id="34602" href="/PLFA-zh/Inference/#34602" class="Bound">Γ</a> <a id="34604" href="/PLFA-zh/Inference/#34604" class="Bound">M</a> <a id="34606" href="/PLFA-zh/Inference/#34606" class="Bound">A</a><a id="34607" class="Symbol">}</a> <a id="34609" class="Symbol">→</a> <a id="34611" href="/PLFA-zh/Inference/#34602" class="Bound">Γ</a> <a id="34613" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">⊢</a> <a id="34615" href="/PLFA-zh/Inference/#34604" class="Bound">M</a> <a id="34617" href="/PLFA-zh/Inference/#14563" class="Datatype Operator">↑</a> <a id="34619" href="/PLFA-zh/Inference/#34606" class="Bound">A</a> <a id="34621" class="Symbol">→</a> <a id="34623" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34625" href="/PLFA-zh/Inference/#34602" class="Bound">Γ</a> <a id="34627" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a> <a id="34631" href="/PLFA-zh/DeBruijn/#10508" class="Datatype Operator">DB.⊢</a> <a id="34636" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="34638" href="/PLFA-zh/Inference/#34606" class="Bound">A</a> <a id="34640" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a>
<a id="∥_∥⁻"></a><a id="34644" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥_∥⁻</a> <a id="34649" class="Symbol">:</a> <a id="34651" class="Symbol">∀</a> <a id="34653" class="Symbol">{</a><a id="34654" href="/PLFA-zh/Inference/#34654" class="Bound">Γ</a> <a id="34656" href="/PLFA-zh/Inference/#34656" class="Bound">M</a> <a id="34658" href="/PLFA-zh/Inference/#34658" class="Bound">A</a><a id="34659" class="Symbol">}</a> <a id="34661" class="Symbol">→</a> <a id="34663" href="/PLFA-zh/Inference/#34654" class="Bound">Γ</a> <a id="34665" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">⊢</a> <a id="34667" href="/PLFA-zh/Inference/#34656" class="Bound">M</a> <a id="34669" href="/PLFA-zh/Inference/#14605" class="Datatype Operator">↓</a> <a id="34671" href="/PLFA-zh/Inference/#34658" class="Bound">A</a> <a id="34673" class="Symbol">→</a> <a id="34675" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥</a> <a id="34677" href="/PLFA-zh/Inference/#34654" class="Bound">Γ</a> <a id="34679" href="/PLFA-zh/Inference/#34006" class="Function Operator">∥Cx</a> <a id="34683" href="/PLFA-zh/DeBruijn/#10508" class="Datatype Operator">DB.⊢</a> <a id="34688" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥</a> <a id="34690" href="/PLFA-zh/Inference/#34658" class="Bound">A</a> <a id="34692" href="/PLFA-zh/Inference/#33772" class="Function Operator">∥Tp</a>

<a id="34697" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="34699" href="/PLFA-zh/Inference/#14663" class="InductiveConstructor">⊢`</a> <a id="34702" href="/PLFA-zh/Inference/#34702" class="Bound">⊢x</a> <a id="34705" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a>           <a id="34718" class="Symbol">=</a>  <a id="34721" href="/PLFA-zh/DeBruijn/#10544" class="InductiveConstructor Operator">DB.`</a> <a id="34726" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥</a> <a id="34728" href="/PLFA-zh/Inference/#34702" class="Bound">⊢x</a> <a id="34731" href="/PLFA-zh/Inference/#34221" class="Function Operator">∥∋</a>
<a id="34734" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="34736" href="/PLFA-zh/Inference/#34736" class="Bound">⊢L</a> <a id="34739" href="/PLFA-zh/Inference/#14733" class="InductiveConstructor Operator">·</a> <a id="34741" href="/PLFA-zh/Inference/#34741" class="Bound">⊢M</a> <a id="34744" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a>         <a id="34755" class="Symbol">=</a>  <a id="34758" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="34760" href="/PLFA-zh/Inference/#34736" class="Bound">⊢L</a> <a id="34763" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a> <a id="34766" href="/PLFA-zh/DeBruijn/#10670" class="InductiveConstructor Operator">DB.·</a> <a id="34771" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34773" href="/PLFA-zh/Inference/#34741" class="Bound">⊢M</a> <a id="34776" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>
<a id="34779" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="34781" href="/PLFA-zh/Inference/#14832" class="InductiveConstructor">⊢↓</a> <a id="34784" href="/PLFA-zh/Inference/#34784" class="Bound">⊢M</a> <a id="34787" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a>           <a id="34800" class="Symbol">=</a>  <a id="34803" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34805" href="/PLFA-zh/Inference/#34784" class="Bound">⊢M</a> <a id="34808" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>

<a id="34812" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34814" href="/PLFA-zh/Inference/#14928" class="InductiveConstructor">⊢ƛ</a> <a id="34817" href="/PLFA-zh/Inference/#34817" class="Bound">⊢N</a> <a id="34820" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>           <a id="34833" class="Symbol">=</a>  <a id="34836" href="/PLFA-zh/DeBruijn/#10599" class="InductiveConstructor Operator">DB.ƛ</a> <a id="34841" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34843" href="/PLFA-zh/Inference/#34817" class="Bound">⊢N</a> <a id="34846" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>
<a id="34849" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34851" href="/PLFA-zh/Inference/#15026" class="InductiveConstructor">⊢zero</a> <a id="34857" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>           <a id="34870" class="Symbol">=</a>  <a id="34873" href="/PLFA-zh/DeBruijn/#10748" class="InductiveConstructor">DB.`zero</a>
<a id="34882" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34884" href="/PLFA-zh/Inference/#15085" class="InductiveConstructor">⊢suc</a> <a id="34889" href="/PLFA-zh/Inference/#34889" class="Bound">⊢M</a> <a id="34892" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>         <a id="34903" class="Symbol">=</a>  <a id="34906" href="/PLFA-zh/DeBruijn/#10795" class="InductiveConstructor Operator">DB.`suc</a> <a id="34914" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34916" href="/PLFA-zh/Inference/#34889" class="Bound">⊢M</a> <a id="34919" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>
<a id="34922" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34924" href="/PLFA-zh/Inference/#15164" class="InductiveConstructor">⊢case</a> <a id="34930" href="/PLFA-zh/Inference/#34930" class="Bound">⊢L</a> <a id="34933" href="/PLFA-zh/Inference/#34933" class="Bound">⊢M</a> <a id="34936" href="/PLFA-zh/Inference/#34936" class="Bound">⊢N</a> <a id="34939" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>  <a id="34943" class="Symbol">=</a>  <a id="34946" href="/PLFA-zh/DeBruijn/#10852" class="InductiveConstructor">DB.case</a> <a id="34954" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="34956" href="/PLFA-zh/Inference/#34930" class="Bound">⊢L</a> <a id="34959" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a> <a id="34962" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34964" href="/PLFA-zh/Inference/#34933" class="Bound">⊢M</a> <a id="34967" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a> <a id="34970" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34972" href="/PLFA-zh/Inference/#34936" class="Bound">⊢N</a> <a id="34975" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>
<a id="34978" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="34980" href="/PLFA-zh/Inference/#15337" class="InductiveConstructor">⊢μ</a> <a id="34983" href="/PLFA-zh/Inference/#34983" class="Bound">⊢M</a> <a id="34986" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>           <a id="34999" class="Symbol">=</a>  <a id="35002" href="/PLFA-zh/DeBruijn/#10942" class="InductiveConstructor Operator">DB.μ</a> <a id="35007" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="35009" href="/PLFA-zh/Inference/#34983" class="Bound">⊢M</a> <a id="35012" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>
<a id="35015" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥</a> <a id="35017" href="/PLFA-zh/Inference/#15427" class="InductiveConstructor">⊢↑</a> <a id="35020" href="/PLFA-zh/Inference/#35020" class="Bound">⊢M</a> <a id="35023" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="35028" href="/PLFA-zh/Inference/#34644" class="Function Operator">∥⁻</a>      <a id="35036" class="Symbol">=</a>  <a id="35039" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="35041" href="/PLFA-zh/Inference/#35020" class="Bound">⊢M</a> <a id="35044" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a></pre>
<p>Erasure replaces constructors for each typing judgment
by the corresponding term constructor from <code class="highlighter-rouge">DB</code>.  The
constructors that correspond to switching from synthesized
to inherited or vice versa are dropped.</p>

<p>We confirm that the erasure of the type derivations in
this chapter yield the corresponding inherently typed terms
from the earlier chapter:</p>
<pre class="Agda"><a id="35421" href="/PLFA-zh/Inference/#35421" class="Function">_</a> <a id="35423" class="Symbol">:</a> <a id="35425" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="35427" href="/PLFA-zh/Inference/#29986" class="Function">⊢2+2</a> <a id="35432" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a> <a id="35435" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="35437" href="/PLFA-zh/DeBruijn/#13671" class="Function">DB.2+2</a>
<a id="35444" class="Symbol">_</a> <a id="35446" class="Symbol">=</a> <a id="35448" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="35454" href="/PLFA-zh/Inference/#35454" class="Function">_</a> <a id="35456" class="Symbol">:</a> <a id="35458" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥</a> <a id="35460" href="/PLFA-zh/Inference/#30903" class="Function">⊢2+2ᶜ</a> <a id="35466" href="/PLFA-zh/Inference/#34592" class="Function Operator">∥⁺</a> <a id="35469" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="35471" href="/PLFA-zh/DeBruijn/#14300" class="Function">DB.2+2ᶜ</a>
<a id="35479" class="Symbol">_</a> <a id="35481" class="Symbol">=</a> <a id="35483" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Thus, we have confirmed that bidirectional type inference
converts decorated versions of the lambda terms from
Chapter <a href="/PLFA-zh/Lambda/">Lambda</a>
to the inherently typed terms of
Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>.</p>

<h4 id="exercise-inference-multiplication-recommended">Exercise <code class="highlighter-rouge">inference-multiplication</code> (recommended)</h4>

<p>Apply inference to your decorated definition of multiplication from
exercise <a href="/PLFA-zh/Inference/#bidirectional-mul"><code class="highlighter-rouge">bidirectional-mul</code></a>, and show that
erasure of the inferred typing yields your definition of
multiplication from Chapter <a href="/PLFA-zh/DeBruijn/">DeBruijn</a>.</p>

<pre class="Agda"><a id="36040" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-inference-products-recommended">Exercise <code class="highlighter-rouge">inference-products</code> (recommended)</h4>

<p>Using your rules from exercise
<a href="/PLFA-zh/Inference/#bidirectional-products"><code class="highlighter-rouge">bidirectional-products</code></a>, extend
bidirectional inference to include products.</p>

<pre class="Agda"><a id="36289" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-inference-rest-stretch">Exercise <code class="highlighter-rouge">inference-rest</code> (stretch)</h4>

<p>Extend the bidirectional type rules to include the rest of the constructs from
Chapter <a href="/PLFA-zh/More/">More</a>.</p>

<pre class="Agda"><a id="36486" class="Comment">-- Your code goes here</a></pre>

<h2 id="bidirectional-inference-in-agda">Bidirectional inference in Agda</h2>

<p>Agda itself uses bidirectional inference.  This explains why
constructors can be overloaded while other defined names cannot — here
by <em>overloaded</em> we mean that the same name can be used for
constructors of different types.  Constructors are typed by
inheritance, and so the name is available when resolving the
constructor, whereas variables are typed by synthesis, and so each
variable must have a unique type.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>↓  U+2193:  DOWNWARDS ARROW (\d)
↑  U+2191:  UPWARDS ARROW (\u)
∥  U+2225:  PARALLEL TO (\||)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Bisimulation/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Inference.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Untyped/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
