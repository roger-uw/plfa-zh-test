<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quantifiers: Universals and existentials | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Quantifiers: Universals and existentials" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://roger-uw.github.io/PLFA-zh/Quantifiers/" />
<meta property="og:url" content="https://roger-uw.github.io/PLFA-zh/Quantifiers/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://roger-uw.github.io/PLFA-zh/Quantifiers/","headline":"Quantifiers: Universals and existentials","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">目录</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Quantifiers: Universals and existentials</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Negation/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Quantifiers.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Decidable/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="168" class="Keyword">module</a> <a id="175" href="/PLFA-zh/Quantifiers/" class="Module">plfa.Quantifiers</a> <a id="192" class="Keyword">where</a></pre>

<p>This chapter introduces universal and existential quantification.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="302" class="Keyword">import</a> <a id="309" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="347" class="Symbol">as</a> <a id="350" class="Module">Eq</a>
<a id="353" class="Keyword">open</a> <a id="358" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="361" class="Keyword">using</a> <a id="367" class="Symbol">(</a><a id="368" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="371" class="Symbol">;</a> <a id="373" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="377" class="Symbol">;</a> <a id="379" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="382" class="Symbol">;</a> <a id="384" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#887" class="Function">trans</a><a id="389" class="Symbol">;</a> <a id="391" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="395" class="Symbol">)</a>
<a id="397" class="Keyword">open</a> <a id="402" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#3975" class="Module">Eq.≡-Reasoning</a>
<a id="417" class="Keyword">open</a> <a id="422" class="Keyword">import</a> <a id="429" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="438" class="Keyword">using</a> <a id="444" class="Symbol">(</a><a id="445" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="446" class="Symbol">;</a> <a id="448" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="452" class="Symbol">;</a> <a id="454" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="457" class="Symbol">;</a> <a id="459" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="462" class="Symbol">;</a> <a id="464" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a><a id="467" class="Symbol">)</a>
<a id="469" class="Keyword">open</a> <a id="474" class="Keyword">import</a> <a id="481" href="Data.Nat.Properties.Simple.html" class="Module">Data.Nat.Properties.Simple</a> <a id="508" class="Keyword">using</a> <a id="514" class="Symbol">(</a><a id="515" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#9272" class="Function">+-suc</a><a id="520" class="Symbol">)</a>
<a id="522" class="Keyword">open</a> <a id="527" class="Keyword">import</a> <a id="534" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="551" class="Keyword">using</a> <a id="557" class="Symbol">(</a><a id="558" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="560" class="Symbol">)</a>
<a id="562" class="Keyword">open</a> <a id="567" class="Keyword">import</a> <a id="574" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="583" class="Keyword">using</a> <a id="589" class="Symbol">(</a><a id="590" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">_∘_</a><a id="593" class="Symbol">)</a>
<a id="595" class="Keyword">open</a> <a id="600" class="Keyword">import</a> <a id="607" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="620" class="Keyword">using</a> <a id="626" class="Symbol">(</a><a id="627" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">_×_</a><a id="630" class="Symbol">;</a> <a id="632" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a><a id="637" class="Symbol">;</a> <a id="639" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a><a id="644" class="Symbol">)</a> <a id="646" class="Keyword">renaming</a> <a id="655" class="Symbol">(</a><a id="656" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="660" class="Symbol">to</a> <a id="663" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="668" class="Symbol">)</a>
<a id="670" class="Keyword">open</a> <a id="675" class="Keyword">import</a> <a id="682" href="https://agda.github.io/agda-stdlib/Data.Sum.html" class="Module">Data.Sum</a> <a id="691" class="Keyword">using</a> <a id="697" class="Symbol">(</a><a id="698" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">_⊎_</a><a id="701" class="Symbol">;</a> <a id="703" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a><a id="707" class="Symbol">;</a> <a id="709" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a><a id="713" class="Symbol">)</a>
<a id="715" class="Keyword">open</a> <a id="720" class="Keyword">import</a> <a id="727" href="/PLFA-zh/Isomorphism/" class="Module">plfa.Isomorphism</a> <a id="744" class="Keyword">using</a> <a id="750" class="Symbol">(</a><a id="751" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">_≃_</a><a id="754" class="Symbol">;</a> <a id="756" href="/PLFA-zh/Isomorphism/#9106" class="Function">≃-sym</a><a id="761" class="Symbol">;</a> <a id="763" href="/PLFA-zh/Isomorphism/#9517" class="Function">≃-trans</a><a id="770" class="Symbol">;</a> <a id="772" href="/PLFA-zh/Isomorphism/#11687" class="Record Operator">_≲_</a><a id="775" class="Symbol">;</a> <a id="777" href="/PLFA-zh/Isomorphism/#3791" class="Postulate">extensionality</a><a id="791" class="Symbol">)</a></pre>

<h2 id="universals">Universals</h2>

<p>We formalise universal quantification using the
dependent function type, which has appeared throughout this book.</p>

<p>Given a variable <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code> and a proposition <code class="highlighter-rouge">B x</code> which
contains <code class="highlighter-rouge">x</code> as a free variable, the universally quantified
proposition <code class="highlighter-rouge">∀ (x : A) → B x</code> holds if for every term <code class="highlighter-rouge">M</code> of type
<code class="highlighter-rouge">A</code> the proposition <code class="highlighter-rouge">B M</code> holds.  Here <code class="highlighter-rouge">B M</code> stands for
the proposition <code class="highlighter-rouge">B x</code> with each free occurrence of <code class="highlighter-rouge">x</code> replaced by
<code class="highlighter-rouge">M</code>.  Variable <code class="highlighter-rouge">x</code> appears free in <code class="highlighter-rouge">B x</code> but bound in
<code class="highlighter-rouge">∀ (x : A) → B x</code>.</p>

<p>Evidence that <code class="highlighter-rouge">∀ (x : A) → B x</code> holds is of the form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ (x : A) → N x
</code></pre></div></div>

<p>where <code class="highlighter-rouge">N x</code> is a term of type <code class="highlighter-rouge">B x</code>, and <code class="highlighter-rouge">N x</code> and <code class="highlighter-rouge">B x</code> both contain
a free variable <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code>.  Given a term <code class="highlighter-rouge">L</code> providing evidence
that <code class="highlighter-rouge">∀ (x : A) → B x</code> holds, and a term <code class="highlighter-rouge">M</code> of type <code class="highlighter-rouge">A</code>, the term <code class="highlighter-rouge">L
M</code> provides evidence that <code class="highlighter-rouge">B M</code> holds.  In other words, evidence that
<code class="highlighter-rouge">∀ (x : A) → B x</code> holds is a function that converts a term <code class="highlighter-rouge">M</code> of type
<code class="highlighter-rouge">A</code> into evidence that <code class="highlighter-rouge">B M</code> holds.</p>

<p>Put another way, if we know that <code class="highlighter-rouge">∀ (x : A) → B x</code> holds and that <code class="highlighter-rouge">M</code>
is a term of type <code class="highlighter-rouge">A</code> then we may conclude that <code class="highlighter-rouge">B M</code> holds:</p>
<pre class="Agda"><a id="∀-elim"></a><a id="1931" href="/PLFA-zh/Quantifiers/#1931" class="Function">∀-elim</a> <a id="1938" class="Symbol">:</a> <a id="1940" class="Symbol">∀</a> <a id="1942" class="Symbol">{</a><a id="1943" href="/PLFA-zh/Quantifiers/#1943" class="Bound">A</a> <a id="1945" class="Symbol">:</a> <a id="1947" class="PrimitiveType">Set</a><a id="1950" class="Symbol">}</a> <a id="1952" class="Symbol">{</a><a id="1953" href="/PLFA-zh/Quantifiers/#1953" class="Bound">B</a> <a id="1955" class="Symbol">:</a> <a id="1957" href="/PLFA-zh/Quantifiers/#1943" class="Bound">A</a> <a id="1959" class="Symbol">→</a> <a id="1961" class="PrimitiveType">Set</a><a id="1964" class="Symbol">}</a>
  <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="/PLFA-zh/Quantifiers/#1971" class="Bound">L</a> <a id="1973" class="Symbol">:</a> <a id="1975" class="Symbol">∀</a> <a id="1977" class="Symbol">(</a><a id="1978" href="/PLFA-zh/Quantifiers/#1978" class="Bound">x</a> <a id="1980" class="Symbol">:</a> <a id="1982" href="/PLFA-zh/Quantifiers/#1943" class="Bound">A</a><a id="1983" class="Symbol">)</a> <a id="1985" class="Symbol">→</a> <a id="1987" href="/PLFA-zh/Quantifiers/#1953" class="Bound">B</a> <a id="1989" href="/PLFA-zh/Quantifiers/#1978" class="Bound">x</a><a id="1990" class="Symbol">)</a>
  <a id="1994" class="Symbol">→</a> <a id="1996" class="Symbol">(</a><a id="1997" href="/PLFA-zh/Quantifiers/#1997" class="Bound">M</a> <a id="1999" class="Symbol">:</a> <a id="2001" href="/PLFA-zh/Quantifiers/#1943" class="Bound">A</a><a id="2002" class="Symbol">)</a>
    <a id="2008" class="Comment">-----------------</a>
  <a id="2028" class="Symbol">→</a> <a id="2030" href="/PLFA-zh/Quantifiers/#1953" class="Bound">B</a> <a id="2032" href="/PLFA-zh/Quantifiers/#1997" class="Bound">M</a>
<a id="2034" href="/PLFA-zh/Quantifiers/#1931" class="Function">∀-elim</a> <a id="2041" href="/PLFA-zh/Quantifiers/#2041" class="Bound">L</a> <a id="2043" href="/PLFA-zh/Quantifiers/#2043" class="Bound">M</a> <a id="2045" class="Symbol">=</a> <a id="2047" href="/PLFA-zh/Quantifiers/#2041" class="Bound">L</a> <a id="2049" href="/PLFA-zh/Quantifiers/#2043" class="Bound">M</a></pre>
<p>As with <code class="highlighter-rouge">→-elim</code>, the rule corresponds to function application.</p>

<p>Functions arise as a special case of dependent functions,
where the range does not depend on a variable drawn from the domain.
When a function is viewed as evidence of implication, both its
argument and result are viewed as evidence, whereas when a dependent
function is viewed as evidence of a universal, its argument is viewed
as an element of a data type and its result is viewed as evidence of
a proposition that depends on the argument. This difference is largely
a matter of interpretation, since in Agda a value of a type and
evidence of a proposition are indistinguishable.</p>

<p>Dependent function types are sometimes referred to as dependent
products, because if <code class="highlighter-rouge">A</code> is a finite type with values <code class="highlighter-rouge">x₁ , ⋯ , xₙ</code>,
and if each of the types <code class="highlighter-rouge">B x₁ , ⋯ , B xₙ</code> has <code class="highlighter-rouge">m₁ , ⋯ , mₙ</code> distinct
members, then <code class="highlighter-rouge">∀ (x : A) → B x</code> has <code class="highlighter-rouge">m₁ * ⋯ * mₙ</code> members.  Indeed,
sometimes the notation <code class="highlighter-rouge">∀ (x : A) → B x</code> is replaced by a notation
such as <code class="highlighter-rouge">Π[ x ∈ A ] (B x)</code>, where <code class="highlighter-rouge">Π</code> stands for product.  However, we
will stick with the name dependent function, because (as we will see)
dependent product is ambiguous.</p>

<h4 id="exercise--distrib--recommended">Exercise <code class="highlighter-rouge">∀-distrib-×</code> (recommended)</h4>

<p>Show that universals distribute over conjunction:</p>
<pre class="Agda"><a id="3329" class="Keyword">postulate</a>
  <a id="∀-distrib-×"></a><a id="3341" href="/PLFA-zh/Quantifiers/#3341" class="Postulate">∀-distrib-×</a> <a id="3353" class="Symbol">:</a> <a id="3355" class="Symbol">∀</a> <a id="3357" class="Symbol">{</a><a id="3358" href="/PLFA-zh/Quantifiers/#3358" class="Bound">A</a> <a id="3360" class="Symbol">:</a> <a id="3362" class="PrimitiveType">Set</a><a id="3365" class="Symbol">}</a> <a id="3367" class="Symbol">{</a><a id="3368" href="/PLFA-zh/Quantifiers/#3368" class="Bound">B</a> <a id="3370" href="/PLFA-zh/Quantifiers/#3370" class="Bound">C</a> <a id="3372" class="Symbol">:</a> <a id="3374" href="/PLFA-zh/Quantifiers/#3358" class="Bound">A</a> <a id="3376" class="Symbol">→</a> <a id="3378" class="PrimitiveType">Set</a><a id="3381" class="Symbol">}</a> <a id="3383" class="Symbol">→</a>
    <a id="3389" class="Symbol">(∀</a> <a id="3392" class="Symbol">(</a><a id="3393" href="/PLFA-zh/Quantifiers/#3393" class="Bound">x</a> <a id="3395" class="Symbol">:</a> <a id="3397" href="/PLFA-zh/Quantifiers/#3358" class="Bound">A</a><a id="3398" class="Symbol">)</a> <a id="3400" class="Symbol">→</a> <a id="3402" href="/PLFA-zh/Quantifiers/#3368" class="Bound">B</a> <a id="3404" href="/PLFA-zh/Quantifiers/#3393" class="Bound">x</a> <a id="3406" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="3408" href="/PLFA-zh/Quantifiers/#3370" class="Bound">C</a> <a id="3410" href="/PLFA-zh/Quantifiers/#3393" class="Bound">x</a><a id="3411" class="Symbol">)</a> <a id="3413" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="3415" class="Symbol">(∀</a> <a id="3418" class="Symbol">(</a><a id="3419" href="/PLFA-zh/Quantifiers/#3419" class="Bound">x</a> <a id="3421" class="Symbol">:</a> <a id="3423" href="/PLFA-zh/Quantifiers/#3358" class="Bound">A</a><a id="3424" class="Symbol">)</a> <a id="3426" class="Symbol">→</a> <a id="3428" href="/PLFA-zh/Quantifiers/#3368" class="Bound">B</a> <a id="3430" href="/PLFA-zh/Quantifiers/#3419" class="Bound">x</a><a id="3431" class="Symbol">)</a> <a id="3433" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="3435" class="Symbol">(∀</a> <a id="3438" class="Symbol">(</a><a id="3439" href="/PLFA-zh/Quantifiers/#3439" class="Bound">x</a> <a id="3441" class="Symbol">:</a> <a id="3443" href="/PLFA-zh/Quantifiers/#3358" class="Bound">A</a><a id="3444" class="Symbol">)</a> <a id="3446" class="Symbol">→</a> <a id="3448" href="/PLFA-zh/Quantifiers/#3370" class="Bound">C</a> <a id="3450" href="/PLFA-zh/Quantifiers/#3439" class="Bound">x</a><a id="3451" class="Symbol">)</a></pre>
<p>Compare this with the result (<code class="highlighter-rouge">→-distrib-×</code>) in
Chapter <a href="/PLFA-zh/Connectives/">Connectives</a>.</p>

<h4 id="exercise--implies-">Exercise <code class="highlighter-rouge">⊎∀-implies-∀⊎</code></h4>

<p>Show that a disjunction of universals implies a universal of disjunctions:</p>
<pre class="Agda"><a id="3673" class="Keyword">postulate</a>
  <a id="⊎∀-implies-∀⊎"></a><a id="3685" href="/PLFA-zh/Quantifiers/#3685" class="Postulate">⊎∀-implies-∀⊎</a> <a id="3699" class="Symbol">:</a> <a id="3701" class="Symbol">∀</a> <a id="3703" class="Symbol">{</a><a id="3704" href="/PLFA-zh/Quantifiers/#3704" class="Bound">A</a> <a id="3706" class="Symbol">:</a> <a id="3708" class="PrimitiveType">Set</a><a id="3711" class="Symbol">}</a> <a id="3713" class="Symbol">{</a><a id="3714" href="/PLFA-zh/Quantifiers/#3714" class="Bound">B</a> <a id="3716" href="/PLFA-zh/Quantifiers/#3716" class="Bound">C</a> <a id="3718" class="Symbol">:</a> <a id="3720" href="/PLFA-zh/Quantifiers/#3704" class="Bound">A</a> <a id="3722" class="Symbol">→</a> <a id="3724" class="PrimitiveType">Set</a><a id="3727" class="Symbol">}</a> <a id="3729" class="Symbol">→</a>
    <a id="3735" class="Symbol">(∀</a> <a id="3738" class="Symbol">(</a><a id="3739" href="/PLFA-zh/Quantifiers/#3739" class="Bound">x</a> <a id="3741" class="Symbol">:</a> <a id="3743" href="/PLFA-zh/Quantifiers/#3704" class="Bound">A</a><a id="3744" class="Symbol">)</a> <a id="3746" class="Symbol">→</a> <a id="3748" href="/PLFA-zh/Quantifiers/#3714" class="Bound">B</a> <a id="3750" href="/PLFA-zh/Quantifiers/#3739" class="Bound">x</a><a id="3751" class="Symbol">)</a> <a id="3753" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="3755" class="Symbol">(∀</a> <a id="3758" class="Symbol">(</a><a id="3759" href="/PLFA-zh/Quantifiers/#3759" class="Bound">x</a> <a id="3761" class="Symbol">:</a> <a id="3763" href="/PLFA-zh/Quantifiers/#3704" class="Bound">A</a><a id="3764" class="Symbol">)</a> <a id="3766" class="Symbol">→</a> <a id="3768" href="/PLFA-zh/Quantifiers/#3716" class="Bound">C</a> <a id="3770" href="/PLFA-zh/Quantifiers/#3759" class="Bound">x</a><a id="3771" class="Symbol">)</a>  <a id="3774" class="Symbol">→</a>  <a id="3777" class="Symbol">∀</a> <a id="3779" class="Symbol">(</a><a id="3780" href="/PLFA-zh/Quantifiers/#3780" class="Bound">x</a> <a id="3782" class="Symbol">:</a> <a id="3784" href="/PLFA-zh/Quantifiers/#3704" class="Bound">A</a><a id="3785" class="Symbol">)</a> <a id="3787" class="Symbol">→</a> <a id="3789" href="/PLFA-zh/Quantifiers/#3714" class="Bound">B</a> <a id="3791" href="/PLFA-zh/Quantifiers/#3780" class="Bound">x</a> <a id="3793" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="3795" href="/PLFA-zh/Quantifiers/#3716" class="Bound">C</a> <a id="3797" href="/PLFA-zh/Quantifiers/#3780" class="Bound">x</a></pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>

<h2 id="existentials">Existentials</h2>

<p>Given a variable <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code> and a proposition <code class="highlighter-rouge">B x</code> which
contains <code class="highlighter-rouge">x</code> as a free variable, the existentially quantified
proposition <code class="highlighter-rouge">Σ[ x ∈ A ] B x</code> holds if for some term <code class="highlighter-rouge">M</code> of type
<code class="highlighter-rouge">A</code> the proposition <code class="highlighter-rouge">B M</code> holds.  Here <code class="highlighter-rouge">B M</code> stands for
the proposition <code class="highlighter-rouge">B x</code> with each free occurrence of <code class="highlighter-rouge">x</code> replaced by
<code class="highlighter-rouge">M</code>.  Variable <code class="highlighter-rouge">x</code> appears free in <code class="highlighter-rouge">B x</code> but bound in
<code class="highlighter-rouge">Σ[ x ∈ A ] B x</code>.</p>

<p>We formalise existential quantification by declaring a suitable
inductive type:</p>
<pre class="Agda"><a id="4366" class="Keyword">data</a> <a id="Σ"></a><a id="4371" href="/PLFA-zh/Quantifiers/#4371" class="Datatype">Σ</a> <a id="4373" class="Symbol">(</a><a id="4374" href="/PLFA-zh/Quantifiers/#4374" class="Bound">A</a> <a id="4376" class="Symbol">:</a> <a id="4378" class="PrimitiveType">Set</a><a id="4381" class="Symbol">)</a> <a id="4383" class="Symbol">(</a><a id="4384" href="/PLFA-zh/Quantifiers/#4384" class="Bound">B</a> <a id="4386" class="Symbol">:</a> <a id="4388" href="/PLFA-zh/Quantifiers/#4374" class="Bound">A</a> <a id="4390" class="Symbol">→</a> <a id="4392" class="PrimitiveType">Set</a><a id="4395" class="Symbol">)</a> <a id="4397" class="Symbol">:</a> <a id="4399" class="PrimitiveType">Set</a> <a id="4403" class="Keyword">where</a>
  <a id="Σ.⟨_,_⟩"></a><a id="4411" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="4417" class="Symbol">:</a> <a id="4419" class="Symbol">(</a><a id="4420" href="/PLFA-zh/Quantifiers/#4420" class="Bound">x</a> <a id="4422" class="Symbol">:</a> <a id="4424" href="/PLFA-zh/Quantifiers/#4374" class="Bound">A</a><a id="4425" class="Symbol">)</a> <a id="4427" class="Symbol">→</a> <a id="4429" href="/PLFA-zh/Quantifiers/#4384" class="Bound">B</a> <a id="4431" href="/PLFA-zh/Quantifiers/#4420" class="Bound">x</a> <a id="4433" class="Symbol">→</a> <a id="4435" href="/PLFA-zh/Quantifiers/#4371" class="Datatype">Σ</a> <a id="4437" href="/PLFA-zh/Quantifiers/#4374" class="Bound">A</a> <a id="4439" href="/PLFA-zh/Quantifiers/#4384" class="Bound">B</a></pre>
<p>We define a convenient syntax for existentials as follows:</p>
<pre class="Agda"><a id="Σ-syntax"></a><a id="4524" href="/PLFA-zh/Quantifiers/#4524" class="Function">Σ-syntax</a> <a id="4533" class="Symbol">=</a> <a id="4535" href="/PLFA-zh/Quantifiers/#4371" class="Datatype">Σ</a>
<a id="4537" class="Keyword">infix</a> <a id="4543" class="Number">2</a> <a id="4545" href="/PLFA-zh/Quantifiers/#4524" class="Function">Σ-syntax</a>
<a id="4554" class="Keyword">syntax</a> <a id="4561" href="/PLFA-zh/Quantifiers/#4524" class="Function">Σ-syntax</a> A <a id="4572" class="Symbol">(λ</a> x <a id="4577" class="Symbol">→</a> B<a id="4580" class="Symbol">)</a> <a id="4582" class="Symbol">=</a> Σ[ x ∈ A ] B</pre>
<p>This is our first use of a syntax declaration, which specifies that
the term on the left may be written with the syntax on the right.
The special syntax is available only when the identifier
<code class="highlighter-rouge">Σ-syntax</code> is imported.</p>

<p>Evidence that <code class="highlighter-rouge">Σ[ x ∈ A ] B x</code> holds is of the form
<code class="highlighter-rouge">⟨ M , N ⟩</code> where <code class="highlighter-rouge">M</code> is a term of type <code class="highlighter-rouge">A</code>, and <code class="highlighter-rouge">N</code> is evidence
that <code class="highlighter-rouge">B M</code> holds.</p>

<p>Equivalently, we could also declare existentials as a record type:</p>
<pre class="Agda"><a id="5040" class="Keyword">record</a> <a id="Σ′"></a><a id="5047" href="/PLFA-zh/Quantifiers/#5047" class="Record">Σ′</a> <a id="5050" class="Symbol">(</a><a id="5051" href="/PLFA-zh/Quantifiers/#5051" class="Bound">A</a> <a id="5053" class="Symbol">:</a> <a id="5055" class="PrimitiveType">Set</a><a id="5058" class="Symbol">)</a> <a id="5060" class="Symbol">(</a><a id="5061" href="/PLFA-zh/Quantifiers/#5061" class="Bound">B</a> <a id="5063" class="Symbol">:</a> <a id="5065" href="/PLFA-zh/Quantifiers/#5051" class="Bound">A</a> <a id="5067" class="Symbol">→</a> <a id="5069" class="PrimitiveType">Set</a><a id="5072" class="Symbol">)</a> <a id="5074" class="Symbol">:</a> <a id="5076" class="PrimitiveType">Set</a> <a id="5080" class="Keyword">where</a>
  <a id="5088" class="Keyword">field</a>
    <a id="Σ′.proj₁′"></a><a id="5098" href="/PLFA-zh/Quantifiers/#5098" class="Field">proj₁′</a> <a id="5105" class="Symbol">:</a> <a id="5107" href="/PLFA-zh/Quantifiers/#5051" class="Bound">A</a>
    <a id="Σ′.proj₂′"></a><a id="5113" href="/PLFA-zh/Quantifiers/#5113" class="Field">proj₂′</a> <a id="5120" class="Symbol">:</a> <a id="5122" href="/PLFA-zh/Quantifiers/#5061" class="Bound">B</a> <a id="5124" href="/PLFA-zh/Quantifiers/#5098" class="Field">proj₁′</a></pre>
<p>Here record construction</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }
</code></pre></div></div>

<p>corresponds to the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨ M , N ⟩
</code></pre></div></div>

<p>where <code class="highlighter-rouge">M</code> is a term of type <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">N</code> is a term of type <code class="highlighter-rouge">B M</code>.</p>

<p>Products arise as a special case of existentials, where the second
component does not depend on a variable drawn from the first
component.  When a product is viewed as evidence of a conjunction,
both of its components are viewed as evidence, whereas when it is
viewed as evidence of an existential, the first component is viewed as
an element of a datatype and the second component is viewed as
evidence of a proposition that depends on the first component.  This
difference is largely a matter of interpretation, since in Agda a value
of a type and evidence of a proposition are indistinguishable.</p>

<p>Existentials are sometimes referred to as dependent sums,
because if <code class="highlighter-rouge">A</code> is a finite type with values <code class="highlighter-rouge">x₁ , ⋯ , xₙ</code>, and if
each of the types <code class="highlighter-rouge">B x₁ , ⋯ B xₙ</code> has <code class="highlighter-rouge">m₁ , ⋯ , mₙ</code> distinct members,
then <code class="highlighter-rouge">Σ[ x ∈ A ] B x</code> has <code class="highlighter-rouge">m₁ + ⋯ + mₙ</code> members, which explains the
choice of notation for existentials, since <code class="highlighter-rouge">Σ</code> stands for sum.</p>

<p>Existentials are sometimes referred to as dependent products, since
products arise as a special case.  However, that choice of names is
doubly confusing, since universals also have a claim to the name dependent
product and since existentials also have a claim to the name dependent sum.</p>

<p>A common notation for existentials is <code class="highlighter-rouge">∃</code> (analogous to <code class="highlighter-rouge">∀</code> for universals).
We follow the convention of the Agda standard library, and reserve this
notation for the case where the domain of the bound variable is left implicit:</p>
<pre class="Agda"><a id="∃"></a><a id="6787" href="/PLFA-zh/Quantifiers/#6787" class="Function">∃</a> <a id="6789" class="Symbol">:</a> <a id="6791" class="Symbol">∀</a> <a id="6793" class="Symbol">{</a><a id="6794" href="/PLFA-zh/Quantifiers/#6794" class="Bound">A</a> <a id="6796" class="Symbol">:</a> <a id="6798" class="PrimitiveType">Set</a><a id="6801" class="Symbol">}</a> <a id="6803" class="Symbol">(</a><a id="6804" href="/PLFA-zh/Quantifiers/#6804" class="Bound">B</a> <a id="6806" class="Symbol">:</a> <a id="6808" href="/PLFA-zh/Quantifiers/#6794" class="Bound">A</a> <a id="6810" class="Symbol">→</a> <a id="6812" class="PrimitiveType">Set</a><a id="6815" class="Symbol">)</a> <a id="6817" class="Symbol">→</a> <a id="6819" class="PrimitiveType">Set</a>
<a id="6823" href="/PLFA-zh/Quantifiers/#6787" class="Function">∃</a> <a id="6825" class="Symbol">{</a><a id="6826" href="/PLFA-zh/Quantifiers/#6826" class="Bound">A</a><a id="6827" class="Symbol">}</a> <a id="6829" href="/PLFA-zh/Quantifiers/#6829" class="Bound">B</a> <a id="6831" class="Symbol">=</a> <a id="6833" href="/PLFA-zh/Quantifiers/#4371" class="Datatype">Σ</a> <a id="6835" href="/PLFA-zh/Quantifiers/#6826" class="Bound">A</a> <a id="6837" href="/PLFA-zh/Quantifiers/#6829" class="Bound">B</a>

<a id="∃-syntax"></a><a id="6840" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃-syntax</a> <a id="6849" class="Symbol">=</a> <a id="6851" href="/PLFA-zh/Quantifiers/#6787" class="Function">∃</a>
<a id="6853" class="Keyword">syntax</a> <a id="6860" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃-syntax</a> <a id="6869" class="Symbol">(λ</a> x <a id="6874" class="Symbol">→</a> B<a id="6877" class="Symbol">)</a> <a id="6879" class="Symbol">=</a> ∃[ x ] B</pre>
<p>The special syntax is available only when the identifier <code class="highlighter-rouge">∃-syntax</code> is imported.
We will tend to use this syntax, since it is shorter and more familiar.</p>

<p>Given evidence that <code class="highlighter-rouge">∀ x → B x → C</code> holds, where <code class="highlighter-rouge">C</code> does not contain
<code class="highlighter-rouge">x</code> as a free variable, and given evidence that <code class="highlighter-rouge">∃[ x ] B x</code> holds, we
may conclude that <code class="highlighter-rouge">C</code> holds:</p>
<pre class="Agda"><a id="∃-elim"></a><a id="7238" href="/PLFA-zh/Quantifiers/#7238" class="Function">∃-elim</a> <a id="7245" class="Symbol">:</a> <a id="7247" class="Symbol">∀</a> <a id="7249" class="Symbol">{</a><a id="7250" href="/PLFA-zh/Quantifiers/#7250" class="Bound">A</a> <a id="7252" class="Symbol">:</a> <a id="7254" class="PrimitiveType">Set</a><a id="7257" class="Symbol">}</a> <a id="7259" class="Symbol">{</a><a id="7260" href="/PLFA-zh/Quantifiers/#7260" class="Bound">B</a> <a id="7262" class="Symbol">:</a> <a id="7264" href="/PLFA-zh/Quantifiers/#7250" class="Bound">A</a> <a id="7266" class="Symbol">→</a> <a id="7268" class="PrimitiveType">Set</a><a id="7271" class="Symbol">}</a> <a id="7273" class="Symbol">{</a><a id="7274" href="/PLFA-zh/Quantifiers/#7274" class="Bound">C</a> <a id="7276" class="Symbol">:</a> <a id="7278" class="PrimitiveType">Set</a><a id="7281" class="Symbol">}</a>
  <a id="7285" class="Symbol">→</a> <a id="7287" class="Symbol">(∀</a> <a id="7290" href="/PLFA-zh/Quantifiers/#7290" class="Bound">x</a> <a id="7292" class="Symbol">→</a> <a id="7294" href="/PLFA-zh/Quantifiers/#7260" class="Bound">B</a> <a id="7296" href="/PLFA-zh/Quantifiers/#7290" class="Bound">x</a> <a id="7298" class="Symbol">→</a> <a id="7300" href="/PLFA-zh/Quantifiers/#7274" class="Bound">C</a><a id="7301" class="Symbol">)</a>
  <a id="7305" class="Symbol">→</a> <a id="7307" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="7310" href="/PLFA-zh/Quantifiers/#7310" class="Bound">x</a> <a id="7312" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="7314" href="/PLFA-zh/Quantifiers/#7260" class="Bound">B</a> <a id="7316" href="/PLFA-zh/Quantifiers/#7310" class="Bound">x</a>
    <a id="7322" class="Comment">---------------</a>
  <a id="7340" class="Symbol">→</a> <a id="7342" href="/PLFA-zh/Quantifiers/#7274" class="Bound">C</a>
<a id="7344" href="/PLFA-zh/Quantifiers/#7238" class="Function">∃-elim</a> <a id="7351" href="/PLFA-zh/Quantifiers/#7351" class="Bound">f</a> <a id="7353" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="7355" href="/PLFA-zh/Quantifiers/#7355" class="Bound">x</a> <a id="7357" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="7359" href="/PLFA-zh/Quantifiers/#7359" class="Bound">y</a> <a id="7361" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="7363" class="Symbol">=</a> <a id="7365" href="/PLFA-zh/Quantifiers/#7351" class="Bound">f</a> <a id="7367" href="/PLFA-zh/Quantifiers/#7355" class="Bound">x</a> <a id="7369" href="/PLFA-zh/Quantifiers/#7359" class="Bound">y</a></pre>
<p>In other words, if we know for every <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code> that <code class="highlighter-rouge">B x</code>
implies <code class="highlighter-rouge">C</code>, and we know for some <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code> that <code class="highlighter-rouge">B x</code> holds,
then we may conclude that <code class="highlighter-rouge">C</code> holds.  This is because we may
instantiate that proof that <code class="highlighter-rouge">∀ x → B x → C</code> to any value <code class="highlighter-rouge">x</code> of type
<code class="highlighter-rouge">A</code> and any <code class="highlighter-rouge">y</code> of type <code class="highlighter-rouge">B x</code>, and exactly such values are provided by
the evidence for <code class="highlighter-rouge">∃[ x ] B x</code>.</p>

<p>Indeed, the converse also holds, and the two together form an isomorphism:</p>
<pre class="Agda"><a id="∀∃-currying"></a><a id="7835" href="/PLFA-zh/Quantifiers/#7835" class="Function">∀∃-currying</a> <a id="7847" class="Symbol">:</a> <a id="7849" class="Symbol">∀</a> <a id="7851" class="Symbol">{</a><a id="7852" href="/PLFA-zh/Quantifiers/#7852" class="Bound">A</a> <a id="7854" class="Symbol">:</a> <a id="7856" class="PrimitiveType">Set</a><a id="7859" class="Symbol">}</a> <a id="7861" class="Symbol">{</a><a id="7862" href="/PLFA-zh/Quantifiers/#7862" class="Bound">B</a> <a id="7864" class="Symbol">:</a> <a id="7866" href="/PLFA-zh/Quantifiers/#7852" class="Bound">A</a> <a id="7868" class="Symbol">→</a> <a id="7870" class="PrimitiveType">Set</a><a id="7873" class="Symbol">}</a> <a id="7875" class="Symbol">{</a><a id="7876" href="/PLFA-zh/Quantifiers/#7876" class="Bound">C</a> <a id="7878" class="Symbol">:</a> <a id="7880" class="PrimitiveType">Set</a><a id="7883" class="Symbol">}</a>
  <a id="7887" class="Symbol">→</a> <a id="7889" class="Symbol">(∀</a> <a id="7892" href="/PLFA-zh/Quantifiers/#7892" class="Bound">x</a> <a id="7894" class="Symbol">→</a> <a id="7896" href="/PLFA-zh/Quantifiers/#7862" class="Bound">B</a> <a id="7898" href="/PLFA-zh/Quantifiers/#7892" class="Bound">x</a> <a id="7900" class="Symbol">→</a> <a id="7902" href="/PLFA-zh/Quantifiers/#7876" class="Bound">C</a><a id="7903" class="Symbol">)</a> <a id="7905" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="7907" class="Symbol">(</a><a id="7908" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="7911" href="/PLFA-zh/Quantifiers/#7911" class="Bound">x</a> <a id="7913" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="7915" href="/PLFA-zh/Quantifiers/#7862" class="Bound">B</a> <a id="7917" href="/PLFA-zh/Quantifiers/#7911" class="Bound">x</a> <a id="7919" class="Symbol">→</a> <a id="7921" href="/PLFA-zh/Quantifiers/#7876" class="Bound">C</a><a id="7922" class="Symbol">)</a>
<a id="7924" href="/PLFA-zh/Quantifiers/#7835" class="Function">∀∃-currying</a> <a id="7936" class="Symbol">=</a>
  <a id="7940" class="Keyword">record</a>
    <a id="7951" class="Symbol">{</a> <a id="7953" class="Field">to</a>      <a id="7961" class="Symbol">=</a>  <a id="7964" class="Symbol">λ{</a> <a id="7967" href="/PLFA-zh/Quantifiers/#7967" class="Bound">f</a> <a id="7969" class="Symbol">→</a> <a id="7971" class="Symbol">λ{</a> <a id="7974" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="7976" href="/PLFA-zh/Quantifiers/#7976" class="Bound">x</a> <a id="7978" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="7980" href="/PLFA-zh/Quantifiers/#7980" class="Bound">y</a> <a id="7982" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="7984" class="Symbol">→</a> <a id="7986" href="/PLFA-zh/Quantifiers/#7967" class="Bound">f</a> <a id="7988" href="/PLFA-zh/Quantifiers/#7976" class="Bound">x</a> <a id="7990" href="/PLFA-zh/Quantifiers/#7980" class="Bound">y</a> <a id="7992" class="Symbol">}}</a>
    <a id="7999" class="Symbol">;</a> <a id="8001" class="Field">from</a>    <a id="8009" class="Symbol">=</a>  <a id="8012" class="Symbol">λ{</a> <a id="8015" href="/PLFA-zh/Quantifiers/#8015" class="Bound">g</a> <a id="8017" class="Symbol">→</a> <a id="8019" class="Symbol">λ{</a> <a id="8022" href="/PLFA-zh/Quantifiers/#8022" class="Bound">x</a> <a id="8024" class="Symbol">→</a> <a id="8026" class="Symbol">λ{</a> <a id="8029" href="/PLFA-zh/Quantifiers/#8029" class="Bound">y</a> <a id="8031" class="Symbol">→</a> <a id="8033" href="/PLFA-zh/Quantifiers/#8015" class="Bound">g</a> <a id="8035" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="8037" href="/PLFA-zh/Quantifiers/#8022" class="Bound">x</a> <a id="8039" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="8041" href="/PLFA-zh/Quantifiers/#8029" class="Bound">y</a> <a id="8043" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="8045" class="Symbol">}}}</a>
    <a id="8053" class="Symbol">;</a> <a id="8055" class="Field">from∘to</a> <a id="8063" class="Symbol">=</a>  <a id="8066" class="Symbol">λ{</a> <a id="8069" href="/PLFA-zh/Quantifiers/#8069" class="Bound">f</a> <a id="8071" class="Symbol">→</a> <a id="8073" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="8078" class="Symbol">}</a>
    <a id="8084" class="Symbol">;</a> <a id="8086" class="Field">to∘from</a> <a id="8094" class="Symbol">=</a>  <a id="8097" class="Symbol">λ{</a> <a id="8100" href="/PLFA-zh/Quantifiers/#8100" class="Bound">g</a> <a id="8102" class="Symbol">→</a> <a id="8104" href="/PLFA-zh/Isomorphism/#3791" class="Postulate">extensionality</a> <a id="8119" class="Symbol">λ{</a> <a id="8122" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="8124" href="/PLFA-zh/Quantifiers/#8124" class="Bound">x</a> <a id="8126" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="8128" href="/PLFA-zh/Quantifiers/#8128" class="Bound">y</a> <a id="8130" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="8132" class="Symbol">→</a> <a id="8134" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="8139" class="Symbol">}}</a>
    <a id="8146" class="Symbol">}</a></pre>
<p>The result can be viewed as a generalisation of currying.  Indeed, the code to
establish the isomorphism is identical to what we wrote when discussing
<a href="/PLFA-zh/Connectives/#implication">implication</a>.</p>

<h4 id="exercise--distrib--recommended-1">Exercise <code class="highlighter-rouge">∃-distrib-⊎</code> (recommended)</h4>

<p>Show that existentials distribute over disjunction:</p>
<pre class="Agda"><a id="8464" class="Keyword">postulate</a>
  <a id="∃-distrib-⊎"></a><a id="8476" href="/PLFA-zh/Quantifiers/#8476" class="Postulate">∃-distrib-⊎</a> <a id="8488" class="Symbol">:</a> <a id="8490" class="Symbol">∀</a> <a id="8492" class="Symbol">{</a><a id="8493" href="/PLFA-zh/Quantifiers/#8493" class="Bound">A</a> <a id="8495" class="Symbol">:</a> <a id="8497" class="PrimitiveType">Set</a><a id="8500" class="Symbol">}</a> <a id="8502" class="Symbol">{</a><a id="8503" href="/PLFA-zh/Quantifiers/#8503" class="Bound">B</a> <a id="8505" href="/PLFA-zh/Quantifiers/#8505" class="Bound">C</a> <a id="8507" class="Symbol">:</a> <a id="8509" href="/PLFA-zh/Quantifiers/#8493" class="Bound">A</a> <a id="8511" class="Symbol">→</a> <a id="8513" class="PrimitiveType">Set</a><a id="8516" class="Symbol">}</a> <a id="8518" class="Symbol">→</a>
    <a id="8524" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8527" href="/PLFA-zh/Quantifiers/#8527" class="Bound">x</a> <a id="8529" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8531" class="Symbol">(</a><a id="8532" href="/PLFA-zh/Quantifiers/#8503" class="Bound">B</a> <a id="8534" href="/PLFA-zh/Quantifiers/#8527" class="Bound">x</a> <a id="8536" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="8538" href="/PLFA-zh/Quantifiers/#8505" class="Bound">C</a> <a id="8540" href="/PLFA-zh/Quantifiers/#8527" class="Bound">x</a><a id="8541" class="Symbol">)</a> <a id="8543" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="8545" class="Symbol">(</a><a id="8546" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8549" href="/PLFA-zh/Quantifiers/#8549" class="Bound">x</a> <a id="8551" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8553" href="/PLFA-zh/Quantifiers/#8503" class="Bound">B</a> <a id="8555" href="/PLFA-zh/Quantifiers/#8549" class="Bound">x</a><a id="8556" class="Symbol">)</a> <a id="8558" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="8560" class="Symbol">(</a><a id="8561" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8564" href="/PLFA-zh/Quantifiers/#8564" class="Bound">x</a> <a id="8566" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8568" href="/PLFA-zh/Quantifiers/#8505" class="Bound">C</a> <a id="8570" href="/PLFA-zh/Quantifiers/#8564" class="Bound">x</a><a id="8571" class="Symbol">)</a></pre>

<h4 id="exercise--implies--1">Exercise <code class="highlighter-rouge">∃×-implies-×∃</code></h4>

<p>Show that an existential of conjunctions implies a conjunction of existentials:</p>
<pre class="Agda"><a id="8709" class="Keyword">postulate</a>
  <a id="∃×-implies-×∃"></a><a id="8721" href="/PLFA-zh/Quantifiers/#8721" class="Postulate">∃×-implies-×∃</a> <a id="8735" class="Symbol">:</a> <a id="8737" class="Symbol">∀</a> <a id="8739" class="Symbol">{</a><a id="8740" href="/PLFA-zh/Quantifiers/#8740" class="Bound">A</a> <a id="8742" class="Symbol">:</a> <a id="8744" class="PrimitiveType">Set</a><a id="8747" class="Symbol">}</a> <a id="8749" class="Symbol">{</a><a id="8750" href="/PLFA-zh/Quantifiers/#8750" class="Bound">B</a> <a id="8752" href="/PLFA-zh/Quantifiers/#8752" class="Bound">C</a> <a id="8754" class="Symbol">:</a> <a id="8756" href="/PLFA-zh/Quantifiers/#8740" class="Bound">A</a> <a id="8758" class="Symbol">→</a> <a id="8760" class="PrimitiveType">Set</a><a id="8763" class="Symbol">}</a> <a id="8765" class="Symbol">→</a>
    <a id="8771" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8774" href="/PLFA-zh/Quantifiers/#8774" class="Bound">x</a> <a id="8776" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8778" class="Symbol">(</a><a id="8779" href="/PLFA-zh/Quantifiers/#8750" class="Bound">B</a> <a id="8781" href="/PLFA-zh/Quantifiers/#8774" class="Bound">x</a> <a id="8783" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="8785" href="/PLFA-zh/Quantifiers/#8752" class="Bound">C</a> <a id="8787" href="/PLFA-zh/Quantifiers/#8774" class="Bound">x</a><a id="8788" class="Symbol">)</a> <a id="8790" class="Symbol">→</a> <a id="8792" class="Symbol">(</a><a id="8793" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8796" href="/PLFA-zh/Quantifiers/#8796" class="Bound">x</a> <a id="8798" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8800" href="/PLFA-zh/Quantifiers/#8750" class="Bound">B</a> <a id="8802" href="/PLFA-zh/Quantifiers/#8796" class="Bound">x</a><a id="8803" class="Symbol">)</a> <a id="8805" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="8807" class="Symbol">(</a><a id="8808" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="8811" href="/PLFA-zh/Quantifiers/#8811" class="Bound">x</a> <a id="8813" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="8815" href="/PLFA-zh/Quantifiers/#8752" class="Bound">C</a> <a id="8817" href="/PLFA-zh/Quantifiers/#8811" class="Bound">x</a><a id="8818" class="Symbol">)</a></pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>

<h2 id="an-existential-example">An existential example</h2>

<p>Recall the definitions of <code class="highlighter-rouge">even</code> and <code class="highlighter-rouge">odd</code> from
Chapter <a href="/PLFA-zh/Relations/">Relations</a>:</p>
<pre class="Agda"><a id="9017" class="Keyword">data</a> <a id="even"></a><a id="9022" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9027" class="Symbol">:</a> <a id="9029" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="9031" class="Symbol">→</a> <a id="9033" class="PrimitiveType">Set</a>
<a id="9037" class="Keyword">data</a> <a id="odd"></a><a id="9042" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a>  <a id="9047" class="Symbol">:</a> <a id="9049" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="9051" class="Symbol">→</a> <a id="9053" class="PrimitiveType">Set</a>

<a id="9058" class="Keyword">data</a> <a id="9063" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9068" class="Keyword">where</a>

  <a id="even.even-zero"></a><a id="9077" href="/PLFA-zh/Quantifiers/#9077" class="InductiveConstructor">even-zero</a> <a id="9087" class="Symbol">:</a> <a id="9089" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9094" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>

  <a id="even.even-suc"></a><a id="9102" href="/PLFA-zh/Quantifiers/#9102" class="InductiveConstructor">even-suc</a> <a id="9111" class="Symbol">:</a> <a id="9113" class="Symbol">∀</a> <a id="9115" class="Symbol">{</a><a id="9116" href="/PLFA-zh/Quantifiers/#9116" class="Bound">n</a> <a id="9118" class="Symbol">:</a> <a id="9120" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9121" class="Symbol">}</a>
    <a id="9127" class="Symbol">→</a> <a id="9129" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a> <a id="9133" href="/PLFA-zh/Quantifiers/#9116" class="Bound">n</a>
      <a id="9141" class="Comment">------------</a>
    <a id="9158" class="Symbol">→</a> <a id="9160" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9165" class="Symbol">(</a><a id="9166" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9170" href="/PLFA-zh/Quantifiers/#9116" class="Bound">n</a><a id="9171" class="Symbol">)</a>

<a id="9174" class="Keyword">data</a> <a id="9179" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a> <a id="9183" class="Keyword">where</a>
  <a id="odd.odd-suc"></a><a id="9191" href="/PLFA-zh/Quantifiers/#9191" class="InductiveConstructor">odd-suc</a> <a id="9199" class="Symbol">:</a> <a id="9201" class="Symbol">∀</a> <a id="9203" class="Symbol">{</a><a id="9204" href="/PLFA-zh/Quantifiers/#9204" class="Bound">n</a> <a id="9206" class="Symbol">:</a> <a id="9208" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9209" class="Symbol">}</a>
    <a id="9215" class="Symbol">→</a> <a id="9217" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9222" href="/PLFA-zh/Quantifiers/#9204" class="Bound">n</a>
      <a id="9230" class="Comment">-----------</a>
    <a id="9246" class="Symbol">→</a> <a id="9248" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a> <a id="9252" class="Symbol">(</a><a id="9253" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="9257" href="/PLFA-zh/Quantifiers/#9204" class="Bound">n</a><a id="9258" class="Symbol">)</a></pre>
<p>A number is even if it is zero or the successor of an odd number, and
odd if it is the successor of an even number.</p>

<p>We will show that a number is even if and only if it is twice some
other number, and odd if and only if it is one more than twice
some other number.  In other words, we will show:</p>

<p><code class="highlighter-rouge">even n</code>   iff   <code class="highlighter-rouge">∃[ m ] (    m * 2 ≡ n)</code></p>

<p><code class="highlighter-rouge">odd  n</code>   iff   <code class="highlighter-rouge">∃[ m ] (1 + m * 2 ≡ n)</code></p>

<p>By convention, one tends to write constant factors first and to put
the constant term in a sum last. Here we’ve reversed each of those
conventions, because doing so eases the proof.</p>

<p>Here is the proof in the forward direction:</p>
<pre class="Agda"><a id="even-∃"></a><a id="9895" href="/PLFA-zh/Quantifiers/#9895" class="Function">even-∃</a> <a id="9902" class="Symbol">:</a> <a id="9904" class="Symbol">∀</a> <a id="9906" class="Symbol">{</a><a id="9907" href="/PLFA-zh/Quantifiers/#9907" class="Bound">n</a> <a id="9909" class="Symbol">:</a> <a id="9911" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9912" class="Symbol">}</a> <a id="9914" class="Symbol">→</a> <a id="9916" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="9921" href="/PLFA-zh/Quantifiers/#9907" class="Bound">n</a> <a id="9923" class="Symbol">→</a> <a id="9925" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="9928" href="/PLFA-zh/Quantifiers/#9928" class="Bound">m</a> <a id="9930" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="9932" class="Symbol">(</a>    <a id="9937" href="/PLFA-zh/Quantifiers/#9928" class="Bound">m</a> <a id="9939" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="9941" class="Number">2</a> <a id="9943" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="9945" href="/PLFA-zh/Quantifiers/#9907" class="Bound">n</a><a id="9946" class="Symbol">)</a>
<a id="odd-∃"></a><a id="9948" href="/PLFA-zh/Quantifiers/#9948" class="Function">odd-∃</a>  <a id="9955" class="Symbol">:</a> <a id="9957" class="Symbol">∀</a> <a id="9959" class="Symbol">{</a><a id="9960" href="/PLFA-zh/Quantifiers/#9960" class="Bound">n</a> <a id="9962" class="Symbol">:</a> <a id="9964" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9965" class="Symbol">}</a> <a id="9967" class="Symbol">→</a>  <a id="9970" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a> <a id="9974" href="/PLFA-zh/Quantifiers/#9960" class="Bound">n</a> <a id="9976" class="Symbol">→</a> <a id="9978" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="9981" href="/PLFA-zh/Quantifiers/#9981" class="Bound">m</a> <a id="9983" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="9985" class="Symbol">(</a><a id="9986" class="Number">1</a> <a id="9988" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="9990" href="/PLFA-zh/Quantifiers/#9981" class="Bound">m</a> <a id="9992" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="9994" class="Number">2</a> <a id="9996" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="9998" href="/PLFA-zh/Quantifiers/#9960" class="Bound">n</a><a id="9999" class="Symbol">)</a>

<a id="10002" href="/PLFA-zh/Quantifiers/#9895" class="Function">even-∃</a> <a id="10009" href="/PLFA-zh/Quantifiers/#9077" class="InductiveConstructor">even-zero</a>                       <a id="10041" class="Symbol">=</a>  <a id="10044" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="10046" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a> <a id="10051" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="10053" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="10058" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>
<a id="10060" href="/PLFA-zh/Quantifiers/#9895" class="Function">even-∃</a> <a id="10067" class="Symbol">(</a><a id="10068" href="/PLFA-zh/Quantifiers/#9102" class="InductiveConstructor">even-suc</a> <a id="10077" href="/PLFA-zh/Quantifiers/#10077" class="Bound">o</a><a id="10078" class="Symbol">)</a> <a id="10080" class="Keyword">with</a> <a id="10085" href="/PLFA-zh/Quantifiers/#9948" class="Function">odd-∃</a> <a id="10091" href="/PLFA-zh/Quantifiers/#10077" class="Bound">o</a>
<a id="10093" class="Symbol">...</a>                    <a id="10116" class="Symbol">|</a> <a id="10118" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="10120" href="/PLFA-zh/Quantifiers/#10120" class="Bound">m</a> <a id="10122" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="10124" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="10129" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>  <a id="10132" class="Symbol">=</a>  <a id="10135" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="10137" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10141" href="/PLFA-zh/Quantifiers/#10120" class="Bound">m</a> <a id="10143" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="10145" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="10150" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>

<a id="10153" href="/PLFA-zh/Quantifiers/#9948" class="Function">odd-∃</a>  <a id="10160" class="Symbol">(</a><a id="10161" href="/PLFA-zh/Quantifiers/#9191" class="InductiveConstructor">odd-suc</a> <a id="10169" href="/PLFA-zh/Quantifiers/#10169" class="Bound">e</a><a id="10170" class="Symbol">)</a>  <a id="10173" class="Keyword">with</a> <a id="10178" href="/PLFA-zh/Quantifiers/#9895" class="Function">even-∃</a> <a id="10185" href="/PLFA-zh/Quantifiers/#10169" class="Bound">e</a>
<a id="10187" class="Symbol">...</a>                    <a id="10210" class="Symbol">|</a> <a id="10212" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="10214" href="/PLFA-zh/Quantifiers/#10214" class="Bound">m</a> <a id="10216" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="10218" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="10223" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>  <a id="10226" class="Symbol">=</a>  <a id="10229" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="10231" href="/PLFA-zh/Quantifiers/#10214" class="Bound">m</a> <a id="10233" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="10235" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="10240" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a></pre>
<p>We define two mutually recursive functions. Given
evidence that <code class="highlighter-rouge">n</code> is even or odd, we return a
number <code class="highlighter-rouge">m</code> and evidence that <code class="highlighter-rouge">m * 2 ≡ n</code> or <code class="highlighter-rouge">1 + m * 2 ≡ n</code>.
We induct over the evidence that <code class="highlighter-rouge">n</code> is even or odd:</p>

<ul>
  <li>
    <p>If the number is even because it is zero, then we return a pair
consisting of zero and the evidence that twice zero is zero.</p>
  </li>
  <li>
    <p>If the number is even because it is one more than an odd number,
then we apply the induction hypothesis to give a number <code class="highlighter-rouge">m</code> and
evidence that <code class="highlighter-rouge">1 + m * 2 ≡ n</code>. We return a pair consisting of <code class="highlighter-rouge">suc m</code>
and evidence that <code class="highlighter-rouge">suc m * 2 ≡ suc n</code>, which is immediate after
substituting for <code class="highlighter-rouge">n</code>.</p>
  </li>
  <li>
    <p>If the number is odd because it is the successor of an even number,
then we apply the induction hypothesis to give a number <code class="highlighter-rouge">m</code> and
evidence that <code class="highlighter-rouge">m * 2 ≡ n</code>. We return a pair consisting of <code class="highlighter-rouge">suc m</code> and
evidence that <code class="highlighter-rouge">1 + m * 2 ≡ suc n</code>, which is immediate after
substituting for <code class="highlighter-rouge">n</code>.</p>
  </li>
</ul>

<p>This completes the proof in the forward direction.</p>

<p>Here is the proof in the reverse direction:</p>
<pre class="Agda"><a id="∃-even"></a><a id="11276" href="/PLFA-zh/Quantifiers/#11276" class="Function">∃-even</a> <a id="11283" class="Symbol">:</a> <a id="11285" class="Symbol">∀</a> <a id="11287" class="Symbol">{</a><a id="11288" href="/PLFA-zh/Quantifiers/#11288" class="Bound">n</a> <a id="11290" class="Symbol">:</a> <a id="11292" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="11293" class="Symbol">}</a> <a id="11295" class="Symbol">→</a> <a id="11297" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="11300" href="/PLFA-zh/Quantifiers/#11300" class="Bound">m</a> <a id="11302" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="11304" class="Symbol">(</a>    <a id="11309" href="/PLFA-zh/Quantifiers/#11300" class="Bound">m</a> <a id="11311" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="11313" class="Number">2</a> <a id="11315" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="11317" href="/PLFA-zh/Quantifiers/#11288" class="Bound">n</a><a id="11318" class="Symbol">)</a> <a id="11320" class="Symbol">→</a> <a id="11322" href="/PLFA-zh/Quantifiers/#9022" class="Datatype">even</a> <a id="11327" href="/PLFA-zh/Quantifiers/#11288" class="Bound">n</a>
<a id="∃-odd"></a><a id="11329" href="/PLFA-zh/Quantifiers/#11329" class="Function">∃-odd</a>  <a id="11336" class="Symbol">:</a> <a id="11338" class="Symbol">∀</a> <a id="11340" class="Symbol">{</a><a id="11341" href="/PLFA-zh/Quantifiers/#11341" class="Bound">n</a> <a id="11343" class="Symbol">:</a> <a id="11345" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="11346" class="Symbol">}</a> <a id="11348" class="Symbol">→</a> <a id="11350" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="11353" href="/PLFA-zh/Quantifiers/#11353" class="Bound">m</a> <a id="11355" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="11357" class="Symbol">(</a><a id="11358" class="Number">1</a> <a id="11360" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="11362" href="/PLFA-zh/Quantifiers/#11353" class="Bound">m</a> <a id="11364" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">*</a> <a id="11366" class="Number">2</a> <a id="11368" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="11370" href="/PLFA-zh/Quantifiers/#11341" class="Bound">n</a><a id="11371" class="Symbol">)</a> <a id="11373" class="Symbol">→</a>  <a id="11376" href="/PLFA-zh/Quantifiers/#9042" class="Datatype">odd</a> <a id="11380" href="/PLFA-zh/Quantifiers/#11341" class="Bound">n</a>

<a id="11383" href="/PLFA-zh/Quantifiers/#11276" class="Function">∃-even</a> <a id="11390" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a>  <a id="11393" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a> <a id="11398" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="11400" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="11405" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>  <a id="11408" class="Symbol">=</a>  <a id="11411" href="/PLFA-zh/Quantifiers/#9077" class="InductiveConstructor">even-zero</a>
<a id="11421" href="/PLFA-zh/Quantifiers/#11276" class="Function">∃-even</a> <a id="11428" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="11430" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="11434" href="/PLFA-zh/Quantifiers/#11434" class="Bound">m</a> <a id="11436" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="11438" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="11443" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>  <a id="11446" class="Symbol">=</a>  <a id="11449" href="/PLFA-zh/Quantifiers/#9102" class="InductiveConstructor">even-suc</a> <a id="11458" class="Symbol">(</a><a id="11459" href="/PLFA-zh/Quantifiers/#11329" class="Function">∃-odd</a> <a id="11465" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="11467" href="/PLFA-zh/Quantifiers/#11434" class="Bound">m</a> <a id="11469" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="11471" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="11476" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a><a id="11477" class="Symbol">)</a>

<a id="11480" href="/PLFA-zh/Quantifiers/#11329" class="Function">∃-odd</a>  <a id="11487" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a>     <a id="11493" href="/PLFA-zh/Quantifiers/#11493" class="Bound">m</a> <a id="11495" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="11497" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="11502" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a>  <a id="11505" class="Symbol">=</a>  <a id="11508" href="/PLFA-zh/Quantifiers/#9191" class="InductiveConstructor">odd-suc</a> <a id="11516" class="Symbol">(</a><a id="11517" href="/PLFA-zh/Quantifiers/#11276" class="Function">∃-even</a> <a id="11524" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="11526" href="/PLFA-zh/Quantifiers/#11493" class="Bound">m</a> <a id="11528" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="11530" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="11535" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a><a id="11536" class="Symbol">)</a></pre>
<p>Given a number that is twice some other number we must show it is
even, and a number that is one more than twice some other number we
must show it is odd.  We induct over the evidence of the existential,
and in the even case consider the two possibilities for the number
that is doubled:</p>

<ul>
  <li>
    <p>In the even case for <code class="highlighter-rouge">zero</code>, we must show <code class="highlighter-rouge">zero * 2</code> is even, which
follows by <code class="highlighter-rouge">even-zero</code>.</p>
  </li>
  <li>
    <p>In the even case for <code class="highlighter-rouge">suc n</code>, we must show <code class="highlighter-rouge">suc m * 2</code> is even.  The
inductive hypothesis tells us that <code class="highlighter-rouge">1 + m * 2</code> is odd, from which the
desired result follows by <code class="highlighter-rouge">even-suc</code>.</p>
  </li>
  <li>
    <p>In the odd case, we must show <code class="highlighter-rouge">1 + m * 2</code> is odd.  The inductive
hypothesis tell us that <code class="highlighter-rouge">m * 2</code> is even, from which the desired result
follows by <code class="highlighter-rouge">odd-suc</code>.</p>
  </li>
</ul>

<p>This completes the proof in the backward direction.</p>

<h4 id="exercise--even-odd">Exercise <code class="highlighter-rouge">∃-even-odd</code></h4>

<p>How do the proofs become more difficult if we replace <code class="highlighter-rouge">m * 2</code> and <code class="highlighter-rouge">1 + m * 2</code>
by <code class="highlighter-rouge">2 * m</code> and <code class="highlighter-rouge">2 * m + 1</code>?  Rewrite the proofs of <code class="highlighter-rouge">∃-even</code> and <code class="highlighter-rouge">∃-odd</code> when
restated in this way.</p>

<pre class="Agda"><a id="12546" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise---">Exercise <code class="highlighter-rouge">∃-+-≤</code></h4>

<p>Show that <code class="highlighter-rouge">y ≤ z</code> holds if and only if there exists a <code class="highlighter-rouge">x</code> such that
<code class="highlighter-rouge">x + y ≡ z</code>.</p>

<pre class="Agda"><a id="12699" class="Comment">-- Your code goes here</a></pre>

<h2 id="existentials-universals-and-negation">Existentials, Universals, and Negation</h2>

<p>Negation of an existential is isomorphic to the universal
of a negation.  Considering that existentials are generalised
disjunction and universals are generalised conjunction, this
result is analogous to the one which tells us that negation
of a disjunction is isomorphic to a conjunction of negations:</p>
<pre class="Agda"><a id="¬∃≃∀¬"></a><a id="13094" href="/PLFA-zh/Quantifiers/#13094" class="Function">¬∃≃∀¬</a> <a id="13100" class="Symbol">:</a> <a id="13102" class="Symbol">∀</a> <a id="13104" class="Symbol">{</a><a id="13105" href="/PLFA-zh/Quantifiers/#13105" class="Bound">A</a> <a id="13107" class="Symbol">:</a> <a id="13109" class="PrimitiveType">Set</a><a id="13112" class="Symbol">}</a> <a id="13114" class="Symbol">{</a><a id="13115" href="/PLFA-zh/Quantifiers/#13115" class="Bound">B</a> <a id="13117" class="Symbol">:</a> <a id="13119" href="/PLFA-zh/Quantifiers/#13105" class="Bound">A</a> <a id="13121" class="Symbol">→</a> <a id="13123" class="PrimitiveType">Set</a><a id="13126" class="Symbol">}</a>
  <a id="13130" class="Symbol">→</a> <a id="13132" class="Symbol">(</a><a id="13133" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="13135" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="13138" href="/PLFA-zh/Quantifiers/#13138" class="Bound">x</a> <a id="13140" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="13142" href="/PLFA-zh/Quantifiers/#13115" class="Bound">B</a> <a id="13144" href="/PLFA-zh/Quantifiers/#13138" class="Bound">x</a><a id="13145" class="Symbol">)</a> <a id="13147" href="/PLFA-zh/Isomorphism/#5537" class="Record Operator">≃</a> <a id="13149" class="Symbol">∀</a> <a id="13151" href="/PLFA-zh/Quantifiers/#13151" class="Bound">x</a> <a id="13153" class="Symbol">→</a> <a id="13155" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="13157" href="/PLFA-zh/Quantifiers/#13115" class="Bound">B</a> <a id="13159" href="/PLFA-zh/Quantifiers/#13151" class="Bound">x</a>
<a id="13161" href="/PLFA-zh/Quantifiers/#13094" class="Function">¬∃≃∀¬</a> <a id="13167" class="Symbol">=</a>
  <a id="13171" class="Keyword">record</a>
    <a id="13182" class="Symbol">{</a> <a id="13184" class="Field">to</a>      <a id="13192" class="Symbol">=</a>  <a id="13195" class="Symbol">λ{</a> <a id="13198" href="/PLFA-zh/Quantifiers/#13198" class="Bound">¬∃xy</a> <a id="13203" href="/PLFA-zh/Quantifiers/#13203" class="Bound">x</a> <a id="13205" href="/PLFA-zh/Quantifiers/#13205" class="Bound">y</a> <a id="13207" class="Symbol">→</a> <a id="13209" href="/PLFA-zh/Quantifiers/#13198" class="Bound">¬∃xy</a> <a id="13214" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="13216" href="/PLFA-zh/Quantifiers/#13203" class="Bound">x</a> <a id="13218" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="13220" href="/PLFA-zh/Quantifiers/#13205" class="Bound">y</a> <a id="13222" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="13224" class="Symbol">}</a>
    <a id="13230" class="Symbol">;</a> <a id="13232" class="Field">from</a>    <a id="13240" class="Symbol">=</a>  <a id="13243" class="Symbol">λ{</a> <a id="13246" href="/PLFA-zh/Quantifiers/#13246" class="Bound">∀¬xy</a> <a id="13251" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="13253" href="/PLFA-zh/Quantifiers/#13253" class="Bound">x</a> <a id="13255" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="13257" href="/PLFA-zh/Quantifiers/#13257" class="Bound">y</a> <a id="13259" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="13261" class="Symbol">→</a> <a id="13263" href="/PLFA-zh/Quantifiers/#13246" class="Bound">∀¬xy</a> <a id="13268" href="/PLFA-zh/Quantifiers/#13253" class="Bound">x</a> <a id="13270" href="/PLFA-zh/Quantifiers/#13257" class="Bound">y</a> <a id="13272" class="Symbol">}</a>
    <a id="13278" class="Symbol">;</a> <a id="13280" class="Field">from∘to</a> <a id="13288" class="Symbol">=</a>  <a id="13291" class="Symbol">λ{</a> <a id="13294" href="/PLFA-zh/Quantifiers/#13294" class="Bound">¬∃xy</a> <a id="13299" class="Symbol">→</a> <a id="13301" href="/PLFA-zh/Isomorphism/#3791" class="Postulate">extensionality</a> <a id="13316" class="Symbol">λ{</a> <a id="13319" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟨</a> <a id="13321" href="/PLFA-zh/Quantifiers/#13321" class="Bound">x</a> <a id="13323" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">,</a> <a id="13325" href="/PLFA-zh/Quantifiers/#13325" class="Bound">y</a> <a id="13327" href="/PLFA-zh/Quantifiers/#4411" class="InductiveConstructor Operator">⟩</a> <a id="13329" class="Symbol">→</a> <a id="13331" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="13336" class="Symbol">}</a> <a id="13338" class="Symbol">}</a>
    <a id="13344" class="Symbol">;</a> <a id="13346" class="Field">to∘from</a> <a id="13354" class="Symbol">=</a>  <a id="13357" class="Symbol">λ{</a> <a id="13360" href="/PLFA-zh/Quantifiers/#13360" class="Bound">∀¬xy</a> <a id="13365" class="Symbol">→</a> <a id="13367" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="13372" class="Symbol">}</a>
    <a id="13378" class="Symbol">}</a></pre>
<p>In the <code class="highlighter-rouge">to</code> direction, we are given a value <code class="highlighter-rouge">¬∃xy</code> of type
<code class="highlighter-rouge">¬ ∃[ x ] B x</code>, and need to show that given a value
<code class="highlighter-rouge">x</code> that <code class="highlighter-rouge">¬ B x</code> follows, in other words, from
a value <code class="highlighter-rouge">y</code> of type <code class="highlighter-rouge">B x</code> we can derive false.  Combining
<code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> gives us a value <code class="highlighter-rouge">⟨ x , y ⟩</code> of type <code class="highlighter-rouge">∃[ x ] B x</code>,
and applying <code class="highlighter-rouge">¬∃xy</code> to that yields a contradiction.</p>

<p>In the <code class="highlighter-rouge">from</code> direction, we are given a value <code class="highlighter-rouge">∀¬xy</code> of type
<code class="highlighter-rouge">∀ x → ¬ B x</code>, and need to show that from a value <code class="highlighter-rouge">⟨ x , y ⟩</code>
of type <code class="highlighter-rouge">∃[ x ] B x</code> we can derive false.  Applying <code class="highlighter-rouge">∀¬xy</code>
to <code class="highlighter-rouge">x</code> gives a value of type <code class="highlighter-rouge">¬ B x</code>, and applying that to <code class="highlighter-rouge">y</code> yields
a contradiction.</p>

<p>The two inverse proofs are straightforward, where one direction
requires extensionality.</p>

<h4 id="exercise--implies--recommended">Exercise <code class="highlighter-rouge">∃¬-implies-¬∀</code> (recommended)</h4>

<p>Show that existential of a negation implies negation of a universal:</p>
<pre class="Agda"><a id="14211" class="Keyword">postulate</a>
  <a id="∃¬-implies-¬∀"></a><a id="14223" href="/PLFA-zh/Quantifiers/#14223" class="Postulate">∃¬-implies-¬∀</a> <a id="14237" class="Symbol">:</a> <a id="14239" class="Symbol">∀</a> <a id="14241" class="Symbol">{</a><a id="14242" href="/PLFA-zh/Quantifiers/#14242" class="Bound">A</a> <a id="14244" class="Symbol">:</a> <a id="14246" class="PrimitiveType">Set</a><a id="14249" class="Symbol">}</a> <a id="14251" class="Symbol">{</a><a id="14252" href="/PLFA-zh/Quantifiers/#14252" class="Bound">B</a> <a id="14254" class="Symbol">:</a> <a id="14256" href="/PLFA-zh/Quantifiers/#14242" class="Bound">A</a> <a id="14258" class="Symbol">→</a> <a id="14260" class="PrimitiveType">Set</a><a id="14263" class="Symbol">}</a>
    <a id="14269" class="Symbol">→</a> <a id="14271" href="/PLFA-zh/Quantifiers/#6840" class="Function">∃[</a> <a id="14274" href="/PLFA-zh/Quantifiers/#14274" class="Bound">x</a> <a id="14276" href="/PLFA-zh/Quantifiers/#6840" class="Function">]</a> <a id="14278" class="Symbol">(</a><a id="14279" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="14281" href="/PLFA-zh/Quantifiers/#14252" class="Bound">B</a> <a id="14283" href="/PLFA-zh/Quantifiers/#14274" class="Bound">x</a><a id="14284" class="Symbol">)</a>
      <a id="14292" class="Comment">--------------</a>
    <a id="14311" class="Symbol">→</a> <a id="14313" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="14315" class="Symbol">(∀</a> <a id="14318" href="/PLFA-zh/Quantifiers/#14318" class="Bound">x</a> <a id="14320" class="Symbol">→</a> <a id="14322" href="/PLFA-zh/Quantifiers/#14252" class="Bound">B</a> <a id="14324" href="/PLFA-zh/Quantifiers/#14318" class="Bound">x</a><a id="14325" class="Symbol">)</a></pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>

<h4 id="Bin-isomorphism">Exercise <code class="highlighter-rouge">Bin-isomorphism</code> (stretch)</h4>

<p>Recall that Exercises
<a href="/PLFA-zh/Naturals/#Bin">Bin</a>,
<a href="/PLFA-zh/Induction/#Bin-laws">Bin-laws</a>, and
<a href="/PLFA-zh/Relations/#Bin-predicates">Bin-predicates</a>
define a datatype of bitstrings representing natural numbers:</p>
<pre class="Agda"><a id="14673" class="Keyword">data</a> <a id="Bin"></a><a id="14678" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a> <a id="14682" class="Symbol">:</a> <a id="14684" class="PrimitiveType">Set</a> <a id="14688" class="Keyword">where</a>
  <a id="Bin.nil"></a><a id="14696" href="/PLFA-zh/Quantifiers/#14696" class="InductiveConstructor">nil</a> <a id="14700" class="Symbol">:</a> <a id="14702" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a>
  <a id="Bin.x0_"></a><a id="14708" href="/PLFA-zh/Quantifiers/#14708" class="InductiveConstructor Operator">x0_</a> <a id="14712" class="Symbol">:</a> <a id="14714" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a> <a id="14718" class="Symbol">→</a> <a id="14720" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a>
  <a id="Bin.x1_"></a><a id="14726" href="/PLFA-zh/Quantifiers/#14726" class="InductiveConstructor Operator">x1_</a> <a id="14730" class="Symbol">:</a> <a id="14732" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a> <a id="14736" class="Symbol">→</a> <a id="14738" href="/PLFA-zh/Quantifiers/#14678" class="Datatype">Bin</a></pre>
<p>And ask you to define the following functions and predicates:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>to   : ℕ → Bin
from : Bin → ℕ
Can  : Bin → Set
</code></pre></div></div>

<p>And to establish the following properties:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from (to n) ≡ n

----------
Can (to n)

Can x
---------------
to (from x) ≡ x
</code></pre></div></div>

<p>Using the above, establish that there is an isomorphism between <code class="highlighter-rouge">ℕ</code> and
<code class="highlighter-rouge">∃[ x ](Can x)</code>.</p>

<pre class="Agda"><a id="15126" class="Comment">-- Your code goes here</a></pre>

<h2 id="standard-prelude">Standard Prelude</h2>

<p>Definitions similar to those in this chapter can be found in the standard library:</p>
<pre class="Agda"><a id="15279" class="Keyword">import</a> <a id="15286" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="15299" class="Keyword">using</a> <a id="15305" class="Symbol">(</a><a id="15306" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#69" class="Record">Σ</a><a id="15307" class="Symbol">;</a> <a id="15309" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a><a id="15312" class="Symbol">;</a> <a id="15314" href="https://agda.github.io/agda-stdlib/Data.Product.html#881" class="Function">∃</a><a id="15315" class="Symbol">;</a> <a id="15317" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ-syntax</a><a id="15325" class="Symbol">;</a> <a id="15327" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃-syntax</a><a id="15335" class="Symbol">)</a></pre>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Π  U+03A0  GREEK CAPITAL LETTER PI (\Pi)
Σ  U+03A3  GREEK CAPITAL LETTER SIGMA (\Sigma)
∃  U+2203  THERE EXISTS (\ex, \exists)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Negation/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Quantifiers.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/Decidable/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
