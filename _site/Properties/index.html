<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Properties: Progress and Preservation | 编程语言基础：Agda 描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Properties: Progress and Preservation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 描述" />
<meta property="og:description" content="编程语言基础：Agda 描述" />
<link rel="canonical" href="https://roger-uw.github.io/PLFA-zh/Properties/" />
<meta property="og:url" content="https://roger-uw.github.io/PLFA-zh/Properties/" />
<meta property="og:site_name" content="编程语言基础：Agda 描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 描述","@type":"WebPage","url":"https://roger-uw.github.io/PLFA-zh/Properties/","headline":"Properties: Progress and Preservation","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">目录</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Properties: Progress and Preservation</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Lambda/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Properties.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/DeBruijn/">后一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="161" class="Keyword">module</a> <a id="168" href="/PLFA-zh/Properties/" class="Module">plfa.Properties</a> <a id="184" class="Keyword">where</a></pre>

<p>This chapter covers properties of the simply-typed lambda calculus, as
introduced in the previous chapter.  The most important of these
properties are progress and preservation.  We introduce these below,
and show how to combine them to get Agda to compute reduction
sequences for us.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="514" class="Keyword">open</a> <a id="519" class="Keyword">import</a> <a id="526" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="566" class="Keyword">using</a> <a id="572" class="Symbol">(</a><a id="573" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="576" class="Symbol">;</a> <a id="578" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">_≢_</a><a id="581" class="Symbol">;</a> <a id="583" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="587" class="Symbol">;</a> <a id="589" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="592" class="Symbol">;</a> <a id="594" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="598" class="Symbol">;</a> <a id="600" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a><a id="605" class="Symbol">)</a>
<a id="607" class="Keyword">open</a> <a id="612" class="Keyword">import</a> <a id="619" href="https://agda.github.io/agda-stdlib/Data.String.html" class="Module">Data.String</a> <a id="631" class="Keyword">using</a> <a id="637" class="Symbol">(</a><a id="638" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a><a id="644" class="Symbol">)</a>
<a id="646" class="Keyword">open</a> <a id="651" class="Keyword">import</a> <a id="658" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html" class="Module">Data.String.Unsafe</a> <a id="677" class="Keyword">using</a> <a id="683" class="Symbol">(</a><a id="684" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">_≟_</a><a id="687" class="Symbol">)</a>
<a id="689" class="Keyword">open</a> <a id="694" class="Keyword">import</a> <a id="701" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="710" class="Keyword">using</a> <a id="716" class="Symbol">(</a><a id="717" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="718" class="Symbol">;</a> <a id="720" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="724" class="Symbol">;</a> <a id="726" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="729" class="Symbol">)</a>
<a id="731" class="Keyword">open</a> <a id="736" class="Keyword">import</a> <a id="743" href="https://agda.github.io/agda-stdlib/Data.Empty.html" class="Module">Data.Empty</a> <a id="754" class="Keyword">using</a> <a id="760" class="Symbol">(</a><a id="761" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a><a id="762" class="Symbol">;</a> <a id="764" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a><a id="770" class="Symbol">)</a>
<a id="772" class="Keyword">open</a> <a id="777" class="Keyword">import</a> <a id="784" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a>
  <a id="799" class="Keyword">using</a> <a id="805" class="Symbol">(</a><a id="806" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">_×_</a><a id="809" class="Symbol">;</a> <a id="811" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a><a id="816" class="Symbol">;</a> <a id="818" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a><a id="823" class="Symbol">;</a> <a id="825" href="https://agda.github.io/agda-stdlib/Data.Product.html#881" class="Function">∃</a><a id="826" class="Symbol">;</a> <a id="828" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃-syntax</a><a id="836" class="Symbol">)</a>
  <a id="840" class="Keyword">renaming</a> <a id="849" class="Symbol">(</a><a id="850" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="854" class="Symbol">to</a> <a id="857" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="862" class="Symbol">)</a>
<a id="864" class="Keyword">open</a> <a id="869" class="Keyword">import</a> <a id="876" href="https://agda.github.io/agda-stdlib/Data.Sum.html" class="Module">Data.Sum</a> <a id="885" class="Keyword">using</a> <a id="891" class="Symbol">(</a><a id="892" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">_⊎_</a><a id="895" class="Symbol">;</a> <a id="897" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a><a id="901" class="Symbol">;</a> <a id="903" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a><a id="907" class="Symbol">)</a>
<a id="909" class="Keyword">open</a> <a id="914" class="Keyword">import</a> <a id="921" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="938" class="Keyword">using</a> <a id="944" class="Symbol">(</a><a id="945" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="947" class="Symbol">;</a> <a id="949" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="952" class="Symbol">;</a> <a id="954" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="957" class="Symbol">;</a> <a id="959" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="961" class="Symbol">)</a>
<a id="963" class="Keyword">open</a> <a id="968" class="Keyword">import</a> <a id="975" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="984" class="Keyword">using</a> <a id="990" class="Symbol">(</a><a id="991" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">_∘_</a><a id="994" class="Symbol">)</a>
<a id="996" class="Keyword">open</a> <a id="1001" class="Keyword">import</a> <a id="1008" href="/PLFA-zh/Isomorphism/" class="Module">plfa.Isomorphism</a>
<a id="1025" class="Keyword">open</a> <a id="1030" class="Keyword">import</a> <a id="1037" href="/PLFA-zh/Lambda/" class="Module">plfa.Lambda</a></pre>

<h2 id="introduction">Introduction</h2>

<p>The last chapter introduced simply-typed lambda calculus,
including the notions of closed terms, terms that are values,
reducing one term to another, and well-typed terms.</p>

<p>Ultimately, we would like to show that we can keep reducing a term
until we reach a value.  For instance, in the last chapter we showed
that two plus two is four,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plus · two · two  —↠  `suc `suc `suc `suc `zero
</code></pre></div></div>

<p>which was proved by a long chain of reductions, ending in the value
on the right.  Every term in the chain had the same type, <code class="highlighter-rouge">`ℕ</code>.
We also saw a second, similar example involving Church numerals.</p>

<p>What we might expect is that every term is either a value or can take
a reduction step.  As we will see, this property does <em>not</em> hold for
every term, but it does hold for every closed, well-typed term.</p>

<p><em>Progress</em>: If <code class="highlighter-rouge">∅ ⊢ M ⦂ A</code> then either <code class="highlighter-rouge">M</code> is a value or there is an <code class="highlighter-rouge">N</code> such
that <code class="highlighter-rouge">M —→ N</code>.</p>

<p>So, either we have a value, and we are done, or we can take a reduction step.
In the latter case, we would like to apply progress again. But to do so we need
to know that the term yielded by the reduction is itself closed and well-typed.
It turns out that this property holds whenever we start with a closed,
well-typed term.</p>

<p><em>Preservation</em>: If <code class="highlighter-rouge">∅ ⊢ M ⦂ A</code> and <code class="highlighter-rouge">M —→ N</code> then <code class="highlighter-rouge">∅ ⊢ N ⦂ A</code>.</p>

<p>This gives us a recipe for automating evaluation. Start with a closed
and well-typed term.  By progress, it is either a value, in which case
we are done, or it reduces to some other term.  By preservation, that
other term will itself be closed and well-typed.  Repeat.  We will
either loop forever, in which case evaluation does not terminate, or
we will eventually reach a value, which is guaranteed to be closed and
of the same type as the original term.  We will turn this recipe into
Agda code that can compute for us the reduction sequence of <code class="highlighter-rouge">plus ·
two · two</code>, and its Church numeral variant.</p>

<p>(The development in this chapter was inspired by the corresponding
development in <em>Software Foundations, volume _Programming Language
Foundations</em>, chapter <em>StlcProp</em>.  It will turn out that one of our technical choices
— to introduce an explicit judgment <code class="highlighter-rouge">Γ ∋ x ⦂ A</code> in place of
treating a context as a function from identifiers to types —
permits a simpler development. In particular, we can prove substitution preserves
types without needing to develop a separate inductive definition of the
<code class="highlighter-rouge">appears_free_in</code> relation.)</p>

<h2 id="values-do-not-reduce">Values do not reduce</h2>

<p>We start with any easy observation. Values do not reduce:</p>
<pre class="Agda"><a id="V¬—→"></a><a id="3582" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="3587" class="Symbol">:</a> <a id="3589" class="Symbol">∀</a> <a id="3591" class="Symbol">{</a><a id="3592" href="/PLFA-zh/Properties/#3592" class="Bound">M</a> <a id="3594" href="/PLFA-zh/Properties/#3594" class="Bound">N</a><a id="3595" class="Symbol">}</a>
  <a id="3599" class="Symbol">→</a> <a id="3601" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="3607" href="/PLFA-zh/Properties/#3592" class="Bound">M</a>
    <a id="3613" class="Comment">----------</a>
  <a id="3626" class="Symbol">→</a> <a id="3628" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="3630" class="Symbol">(</a><a id="3631" href="/PLFA-zh/Properties/#3592" class="Bound">M</a> <a id="3633" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="3636" href="/PLFA-zh/Properties/#3594" class="Bound">N</a><a id="3637" class="Symbol">)</a>
<a id="3639" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="3644" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a>        <a id="3655" class="Symbol">()</a>
<a id="3658" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="3663" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a>     <a id="3674" class="Symbol">()</a>
<a id="3677" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="3682" class="Symbol">(</a><a id="3683" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="3689" href="/PLFA-zh/Properties/#3689" class="Bound">VM</a><a id="3691" class="Symbol">)</a> <a id="3693" class="Symbol">(</a><a id="3694" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="3700" href="/PLFA-zh/Properties/#3700" class="Bound">M—→N</a><a id="3704" class="Symbol">)</a> <a id="3706" class="Symbol">=</a> <a id="3708" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="3713" href="/PLFA-zh/Properties/#3689" class="Bound">VM</a> <a id="3716" href="/PLFA-zh/Properties/#3700" class="Bound">M—→N</a></pre>
<p>We consider the three possibilities for values:</p>

<ul>
  <li>
    <p>If it is an abstraction then no reduction applies</p>
  </li>
  <li>
    <p>If it is zero then no reduction applies</p>
  </li>
  <li>
    <p>If it is a successor then rule <code class="highlighter-rouge">ξ-suc</code> may apply,
but in that case the successor is itself of a value
that reduces, which by induction cannot occur.</p>
  </li>
</ul>

<p>As a corollary, terms that reduce are not values:</p>
<pre class="Agda"><a id="—→¬V"></a><a id="4096" href="/PLFA-zh/Properties/#4096" class="Function">—→¬V</a> <a id="4101" class="Symbol">:</a> <a id="4103" class="Symbol">∀</a> <a id="4105" class="Symbol">{</a><a id="4106" href="/PLFA-zh/Properties/#4106" class="Bound">M</a> <a id="4108" href="/PLFA-zh/Properties/#4108" class="Bound">N</a><a id="4109" class="Symbol">}</a>
  <a id="4113" class="Symbol">→</a> <a id="4115" href="/PLFA-zh/Properties/#4106" class="Bound">M</a> <a id="4117" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="4120" href="/PLFA-zh/Properties/#4108" class="Bound">N</a>
    <a id="4126" class="Comment">---------</a>
  <a id="4138" class="Symbol">→</a> <a id="4140" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="4142" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="4148" href="/PLFA-zh/Properties/#4106" class="Bound">M</a>
<a id="4150" href="/PLFA-zh/Properties/#4096" class="Function">—→¬V</a> <a id="4155" href="/PLFA-zh/Properties/#4155" class="Bound">M—→N</a> <a id="4160" href="/PLFA-zh/Properties/#4160" class="Bound">VM</a>  <a id="4164" class="Symbol">=</a>  <a id="4167" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="4172" href="/PLFA-zh/Properties/#4160" class="Bound">VM</a> <a id="4175" href="/PLFA-zh/Properties/#4155" class="Bound">M—→N</a></pre>
<p>If we expand out the negations, we have</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>V¬—→ : ∀ {M N} → Value M → M —→ N → ⊥
—→¬V : ∀ {M N} → M —→ N → Value M → ⊥
</code></pre></div></div>

<p>which are the same function with the arguments swapped.</p>

<h2 id="canonical-forms">Canonical Forms</h2>

<p>Well-typed values must take one of a small number of <em>canonical forms</em>.
We provide an analogue of the <code class="highlighter-rouge">Value</code> relation that relates values
to their types.  A lambda expression must have a function type,
and a zero or successor expression must be a natural.
Further, the body of a function must be well-typed in a context
containing only its bound variable, and the argument of successor
must itself be canonical:</p>
<pre class="Agda"><a id="4821" class="Keyword">infix</a>  <a id="4828" class="Number">4</a> <a id="4830" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical_⦂_</a>

<a id="4844" class="Keyword">data</a> <a id="Canonical_⦂_"></a><a id="4849" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical_⦂_</a> <a id="4862" class="Symbol">:</a> <a id="4864" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a> <a id="4869" class="Symbol">→</a> <a id="4871" href="/PLFA-zh/Lambda/#28685" class="Datatype">Type</a> <a id="4876" class="Symbol">→</a> <a id="4878" class="PrimitiveType">Set</a> <a id="4882" class="Keyword">where</a>

  <a id="Canonical_⦂_.C-ƛ"></a><a id="4891" href="/PLFA-zh/Properties/#4891" class="InductiveConstructor">C-ƛ</a> <a id="4895" class="Symbol">:</a> <a id="4897" class="Symbol">∀</a> <a id="4899" class="Symbol">{</a><a id="4900" href="/PLFA-zh/Properties/#4900" class="Bound">x</a> <a id="4902" href="/PLFA-zh/Properties/#4902" class="Bound">A</a> <a id="4904" href="/PLFA-zh/Properties/#4904" class="Bound">N</a> <a id="4906" href="/PLFA-zh/Properties/#4906" class="Bound">B</a><a id="4907" class="Symbol">}</a>
    <a id="4913" class="Symbol">→</a> <a id="4915" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="4917" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="4919" href="/PLFA-zh/Properties/#4900" class="Bound">x</a> <a id="4921" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="4923" href="/PLFA-zh/Properties/#4902" class="Bound">A</a> <a id="4925" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="4927" href="/PLFA-zh/Properties/#4904" class="Bound">N</a> <a id="4929" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="4931" href="/PLFA-zh/Properties/#4906" class="Bound">B</a>
      <a id="4939" class="Comment">-----------------------------</a>
    <a id="4973" class="Symbol">→</a> <a id="4975" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="4985" class="Symbol">(</a><a id="4986" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="4988" href="/PLFA-zh/Properties/#4900" class="Bound">x</a> <a id="4990" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="4992" href="/PLFA-zh/Properties/#4904" class="Bound">N</a><a id="4993" class="Symbol">)</a> <a id="4995" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="4997" class="Symbol">(</a><a id="4998" href="/PLFA-zh/Properties/#4902" class="Bound">A</a> <a id="5000" href="/PLFA-zh/Lambda/#28704" class="InductiveConstructor Operator">⇒</a> <a id="5002" href="/PLFA-zh/Properties/#4906" class="Bound">B</a><a id="5003" class="Symbol">)</a>

  <a id="Canonical_⦂_.C-zero"></a><a id="5008" href="/PLFA-zh/Properties/#5008" class="InductiveConstructor">C-zero</a> <a id="5015" class="Symbol">:</a>
      <a id="5023" class="Comment">--------------------</a>
      <a id="5050" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="5060" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a> <a id="5066" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="5068" href="/PLFA-zh/Lambda/#28731" class="InductiveConstructor">`ℕ</a>

  <a id="Canonical_⦂_.C-suc"></a><a id="5074" href="/PLFA-zh/Properties/#5074" class="InductiveConstructor">C-suc</a> <a id="5080" class="Symbol">:</a> <a id="5082" class="Symbol">∀</a> <a id="5084" class="Symbol">{</a><a id="5085" href="/PLFA-zh/Properties/#5085" class="Bound">V</a><a id="5086" class="Symbol">}</a>
    <a id="5092" class="Symbol">→</a> <a id="5094" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="5104" href="/PLFA-zh/Properties/#5085" class="Bound">V</a> <a id="5106" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="5108" href="/PLFA-zh/Lambda/#28731" class="InductiveConstructor">`ℕ</a>
      <a id="5117" class="Comment">---------------------</a>
    <a id="5143" class="Symbol">→</a> <a id="5145" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="5155" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="5160" href="/PLFA-zh/Properties/#5085" class="Bound">V</a> <a id="5162" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="5164" href="/PLFA-zh/Lambda/#28731" class="InductiveConstructor">`ℕ</a></pre>

<p>Every closed, well-typed value is canonical:</p>
<pre class="Agda"><a id="canonical"></a><a id="5241" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5251" class="Symbol">:</a> <a id="5253" class="Symbol">∀</a> <a id="5255" class="Symbol">{</a><a id="5256" href="/PLFA-zh/Properties/#5256" class="Bound">V</a> <a id="5258" href="/PLFA-zh/Properties/#5258" class="Bound">A</a><a id="5259" class="Symbol">}</a>
  <a id="5263" class="Symbol">→</a> <a id="5265" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="5267" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="5269" href="/PLFA-zh/Properties/#5256" class="Bound">V</a> <a id="5271" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="5273" href="/PLFA-zh/Properties/#5258" class="Bound">A</a>
  <a id="5277" class="Symbol">→</a> <a id="5279" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="5285" href="/PLFA-zh/Properties/#5256" class="Bound">V</a>
    <a id="5291" class="Comment">-----------</a>
  <a id="5305" class="Symbol">→</a> <a id="5307" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="5317" href="/PLFA-zh/Properties/#5256" class="Bound">V</a> <a id="5319" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="5321" href="/PLFA-zh/Properties/#5258" class="Bound">A</a>
<a id="5323" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5333" class="Symbol">(</a><a id="5334" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="5337" class="Symbol">())</a>          <a id="5350" class="Symbol">()</a>
<a id="5353" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5363" class="Symbol">(</a><a id="5364" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="5367" href="/PLFA-zh/Properties/#5367" class="Bound">⊢N</a><a id="5369" class="Symbol">)</a>          <a id="5380" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a>         <a id="5392" class="Symbol">=</a>  <a id="5395" href="/PLFA-zh/Properties/#4891" class="InductiveConstructor">C-ƛ</a> <a id="5399" href="/PLFA-zh/Properties/#5367" class="Bound">⊢N</a>
<a id="5402" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5412" class="Symbol">(</a><a id="5413" href="/PLFA-zh/Properties/#5413" class="Bound">⊢L</a> <a id="5416" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="5418" href="/PLFA-zh/Properties/#5418" class="Bound">⊢M</a><a id="5420" class="Symbol">)</a>        <a id="5429" class="Symbol">()</a>
<a id="5432" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5442" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>            <a id="5459" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a>      <a id="5471" class="Symbol">=</a>  <a id="5474" href="/PLFA-zh/Properties/#5008" class="InductiveConstructor">C-zero</a>
<a id="5481" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5491" class="Symbol">(</a><a id="5492" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="5497" href="/PLFA-zh/Properties/#5497" class="Bound">⊢V</a><a id="5499" class="Symbol">)</a>        <a id="5508" class="Symbol">(</a><a id="5509" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="5515" href="/PLFA-zh/Properties/#5515" class="Bound">VV</a><a id="5517" class="Symbol">)</a>  <a id="5520" class="Symbol">=</a>  <a id="5523" href="/PLFA-zh/Properties/#5074" class="InductiveConstructor">C-suc</a> <a id="5529" class="Symbol">(</a><a id="5530" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5540" href="/PLFA-zh/Properties/#5497" class="Bound">⊢V</a> <a id="5543" href="/PLFA-zh/Properties/#5515" class="Bound">VV</a><a id="5545" class="Symbol">)</a>
<a id="5547" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5557" class="Symbol">(</a><a id="5558" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="5564" href="/PLFA-zh/Properties/#5564" class="Bound">⊢L</a> <a id="5567" href="/PLFA-zh/Properties/#5567" class="Bound">⊢M</a> <a id="5570" href="/PLFA-zh/Properties/#5570" class="Bound">⊢N</a><a id="5572" class="Symbol">)</a> <a id="5574" class="Symbol">()</a>
<a id="5577" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="5587" class="Symbol">(</a><a id="5588" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="5591" href="/PLFA-zh/Properties/#5591" class="Bound">⊢M</a><a id="5593" class="Symbol">)</a>          <a id="5604" class="Symbol">()</a></pre>
<p>There are only three interesting cases to consider:</p>

<ul>
  <li>
    <p>If the term is a lambda abstraction, then well-typing of the term
guarantees well-typing of the body.</p>
  </li>
  <li>
    <p>If the term is zero then it is canonical trivially.</p>
  </li>
  <li>
    <p>If the term is a successor then since it is well-typed its argument
is well-typed, and since it is a value its argument is a value.
Hence, by induction its argument is also canonical.</p>
  </li>
</ul>

<p>The variable case is thrown out because a closed term has no free
variables and because a variable is not a value.  The cases for
application, zero, successor, and fixpoint are thrown out because they
are not values.</p>

<p>Conversely, if a term is canonical then it is a value
and it is well-typed in the empty context:</p>
<pre class="Agda"><a id="value"></a><a id="6353" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="6359" class="Symbol">:</a> <a id="6361" class="Symbol">∀</a> <a id="6363" class="Symbol">{</a><a id="6364" href="/PLFA-zh/Properties/#6364" class="Bound">M</a> <a id="6366" href="/PLFA-zh/Properties/#6366" class="Bound">A</a><a id="6367" class="Symbol">}</a>
  <a id="6371" class="Symbol">→</a> <a id="6373" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="6383" href="/PLFA-zh/Properties/#6364" class="Bound">M</a> <a id="6385" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="6387" href="/PLFA-zh/Properties/#6366" class="Bound">A</a>
    <a id="6393" class="Comment">----------------</a>
  <a id="6412" class="Symbol">→</a> <a id="6414" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="6420" href="/PLFA-zh/Properties/#6364" class="Bound">M</a>
<a id="6422" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="6428" class="Symbol">(</a><a id="6429" href="/PLFA-zh/Properties/#4891" class="InductiveConstructor">C-ƛ</a> <a id="6433" href="/PLFA-zh/Properties/#6433" class="Bound">⊢N</a><a id="6435" class="Symbol">)</a>    <a id="6440" class="Symbol">=</a>  <a id="6443" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a>
<a id="6447" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="6453" href="/PLFA-zh/Properties/#5008" class="InductiveConstructor">C-zero</a>      <a id="6465" class="Symbol">=</a>  <a id="6468" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a>
<a id="6475" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="6481" class="Symbol">(</a><a id="6482" href="/PLFA-zh/Properties/#5074" class="InductiveConstructor">C-suc</a> <a id="6488" href="/PLFA-zh/Properties/#6488" class="Bound">CM</a><a id="6490" class="Symbol">)</a>  <a id="6493" class="Symbol">=</a>  <a id="6496" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="6502" class="Symbol">(</a><a id="6503" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="6509" href="/PLFA-zh/Properties/#6488" class="Bound">CM</a><a id="6511" class="Symbol">)</a>

<a id="typed"></a><a id="6514" href="/PLFA-zh/Properties/#6514" class="Function">typed</a> <a id="6520" class="Symbol">:</a> <a id="6522" class="Symbol">∀</a> <a id="6524" class="Symbol">{</a><a id="6525" href="/PLFA-zh/Properties/#6525" class="Bound">M</a> <a id="6527" href="/PLFA-zh/Properties/#6527" class="Bound">A</a><a id="6528" class="Symbol">}</a>
  <a id="6532" class="Symbol">→</a> <a id="6534" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">Canonical</a> <a id="6544" href="/PLFA-zh/Properties/#6525" class="Bound">M</a> <a id="6546" href="/PLFA-zh/Properties/#4849" class="Datatype Operator">⦂</a> <a id="6548" href="/PLFA-zh/Properties/#6527" class="Bound">A</a>
    <a id="6554" class="Comment">---------------</a>
  <a id="6572" class="Symbol">→</a> <a id="6574" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="6576" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="6578" href="/PLFA-zh/Properties/#6525" class="Bound">M</a> <a id="6580" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="6582" href="/PLFA-zh/Properties/#6527" class="Bound">A</a>
<a id="6584" href="/PLFA-zh/Properties/#6514" class="Function">typed</a> <a id="6590" class="Symbol">(</a><a id="6591" href="/PLFA-zh/Properties/#4891" class="InductiveConstructor">C-ƛ</a> <a id="6595" href="/PLFA-zh/Properties/#6595" class="Bound">⊢N</a><a id="6597" class="Symbol">)</a>    <a id="6602" class="Symbol">=</a>  <a id="6605" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="6608" href="/PLFA-zh/Properties/#6595" class="Bound">⊢N</a>
<a id="6611" href="/PLFA-zh/Properties/#6514" class="Function">typed</a> <a id="6617" href="/PLFA-zh/Properties/#5008" class="InductiveConstructor">C-zero</a>      <a id="6629" class="Symbol">=</a>  <a id="6632" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>
<a id="6638" href="/PLFA-zh/Properties/#6514" class="Function">typed</a> <a id="6644" class="Symbol">(</a><a id="6645" href="/PLFA-zh/Properties/#5074" class="InductiveConstructor">C-suc</a> <a id="6651" href="/PLFA-zh/Properties/#6651" class="Bound">CM</a><a id="6653" class="Symbol">)</a>  <a id="6656" class="Symbol">=</a>  <a id="6659" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="6664" class="Symbol">(</a><a id="6665" href="/PLFA-zh/Properties/#6514" class="Function">typed</a> <a id="6671" href="/PLFA-zh/Properties/#6651" class="Bound">CM</a><a id="6673" class="Symbol">)</a></pre>
<p>The proofs are straightforward, and again use induction in the
case of successor.</p>

<h2 id="progress">Progress</h2>

<p>We would like to show that every term is either a value or takes a
reduction step.  However, this is not true in general.  The term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`zero · `suc `zero
</code></pre></div></div>

<p>is neither a value nor can take a reduction step. And if <code class="highlighter-rouge">s ⦂ `ℕ ⇒ `ℕ</code>
then the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> s · `zero
</code></pre></div></div>

<p>cannot reduce because we do not know which function is bound to the
free variable <code class="highlighter-rouge">s</code>.  The first of those terms is ill-typed, and the
second has a free variable.  Every term that is well-typed and closed
has the desired property.</p>

<p><em>Progress</em>: If <code class="highlighter-rouge">∅ ⊢ M ⦂ A</code> then either <code class="highlighter-rouge">M</code> is a value or there is an <code class="highlighter-rouge">N</code> such
that <code class="highlighter-rouge">M —→ N</code>.</p>

<p>To formulate this property, we first introduce a relation that
captures what it means for a term <code class="highlighter-rouge">M</code> to make progress:</p>
<pre class="Agda"><a id="7504" class="Keyword">data</a> <a id="Progress"></a><a id="7509" href="/PLFA-zh/Properties/#7509" class="Datatype">Progress</a> <a id="7518" class="Symbol">(</a><a id="7519" href="/PLFA-zh/Properties/#7519" class="Bound">M</a> <a id="7521" class="Symbol">:</a> <a id="7523" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a><a id="7527" class="Symbol">)</a> <a id="7529" class="Symbol">:</a> <a id="7531" class="PrimitiveType">Set</a> <a id="7535" class="Keyword">where</a>

  <a id="Progress.step"></a><a id="7544" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="7549" class="Symbol">:</a> <a id="7551" class="Symbol">∀</a> <a id="7553" class="Symbol">{</a><a id="7554" href="/PLFA-zh/Properties/#7554" class="Bound">N</a><a id="7555" class="Symbol">}</a>
    <a id="7561" class="Symbol">→</a> <a id="7563" href="/PLFA-zh/Properties/#7519" class="Bound">M</a> <a id="7565" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="7568" href="/PLFA-zh/Properties/#7554" class="Bound">N</a>
      <a id="7576" class="Comment">----------</a>
    <a id="7591" class="Symbol">→</a> <a id="7593" href="/PLFA-zh/Properties/#7509" class="Datatype">Progress</a> <a id="7602" href="/PLFA-zh/Properties/#7519" class="Bound">M</a>

  <a id="Progress.done"></a><a id="7607" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="7612" class="Symbol">:</a>
      <a id="7620" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="7626" href="/PLFA-zh/Properties/#7519" class="Bound">M</a>
      <a id="7634" class="Comment">----------</a>
    <a id="7649" class="Symbol">→</a> <a id="7651" href="/PLFA-zh/Properties/#7509" class="Datatype">Progress</a> <a id="7660" href="/PLFA-zh/Properties/#7519" class="Bound">M</a></pre>
<p>A term <code class="highlighter-rouge">M</code> makes progress if either it can take a step, meaning there
exists a term <code class="highlighter-rouge">N</code> such that <code class="highlighter-rouge">M —→ N</code>, or if it is done, meaning that
<code class="highlighter-rouge">M</code> is a value.</p>

<p>If a term is well-typed in the empty context then it satisfies progress:</p>
<pre class="Agda"><a id="progress"></a><a id="7915" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="7924" class="Symbol">:</a> <a id="7926" class="Symbol">∀</a> <a id="7928" class="Symbol">{</a><a id="7929" href="/PLFA-zh/Properties/#7929" class="Bound">M</a> <a id="7931" href="/PLFA-zh/Properties/#7931" class="Bound">A</a><a id="7932" class="Symbol">}</a>
  <a id="7936" class="Symbol">→</a> <a id="7938" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="7940" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="7942" href="/PLFA-zh/Properties/#7929" class="Bound">M</a> <a id="7944" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="7946" href="/PLFA-zh/Properties/#7931" class="Bound">A</a>
    <a id="7952" class="Comment">----------</a>
  <a id="7965" class="Symbol">→</a> <a id="7967" href="/PLFA-zh/Properties/#7509" class="Datatype">Progress</a> <a id="7976" href="/PLFA-zh/Properties/#7929" class="Bound">M</a>
<a id="7978" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="7987" class="Symbol">(</a><a id="7988" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="7991" class="Symbol">())</a>
<a id="7995" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8004" class="Symbol">(</a><a id="8005" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="8008" href="/PLFA-zh/Properties/#8008" class="Bound">⊢N</a><a id="8010" class="Symbol">)</a>                            <a id="8039" class="Symbol">=</a>  <a id="8042" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8047" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a>
<a id="8051" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8060" class="Symbol">(</a><a id="8061" href="/PLFA-zh/Properties/#8061" class="Bound">⊢L</a> <a id="8064" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="8066" href="/PLFA-zh/Properties/#8066" class="Bound">⊢M</a><a id="8068" class="Symbol">)</a> <a id="8070" class="Keyword">with</a> <a id="8075" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8084" href="/PLFA-zh/Properties/#8061" class="Bound">⊢L</a>
<a id="8087" class="Symbol">...</a> <a id="8091" class="Symbol">|</a> <a id="8093" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8098" href="/PLFA-zh/Properties/#8098" class="Bound">L—→L′</a>                            <a id="8131" class="Symbol">=</a>  <a id="8134" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8139" class="Symbol">(</a><a id="8140" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="8145" href="/PLFA-zh/Properties/#8098" class="Bound">L—→L′</a><a id="8150" class="Symbol">)</a>
<a id="8152" class="Symbol">...</a> <a id="8156" class="Symbol">|</a> <a id="8158" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8163" href="/PLFA-zh/Properties/#8163" class="Bound">VL</a> <a id="8166" class="Keyword">with</a> <a id="8171" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8180" class="Bound">⊢M</a>
<a id="8183" class="Symbol">...</a>   <a id="8189" class="Symbol">|</a> <a id="8191" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8196" href="/PLFA-zh/Properties/#8196" class="Bound">M—→M′</a>                          <a id="8227" class="Symbol">=</a>  <a id="8230" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8235" class="Symbol">(</a><a id="8236" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="8241" class="Bound">VL</a> <a id="8244" href="/PLFA-zh/Properties/#8196" class="Bound">M—→M′</a><a id="8249" class="Symbol">)</a>
<a id="8251" class="Symbol">...</a>   <a id="8257" class="Symbol">|</a> <a id="8259" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8264" href="/PLFA-zh/Properties/#8264" class="Bound">VM</a> <a id="8267" class="Keyword">with</a> <a id="8272" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="8282" class="Bound">⊢L</a> <a id="8285" class="Bound">VL</a>
<a id="8288" class="Symbol">...</a>     <a id="8296" class="Symbol">|</a> <a id="8298" href="/PLFA-zh/Properties/#4891" class="InductiveConstructor">C-ƛ</a> <a id="8302" class="Symbol">_</a>                             <a id="8332" class="Symbol">=</a>  <a id="8335" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8340" class="Symbol">(</a><a id="8341" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="8345" class="Bound">VM</a><a id="8347" class="Symbol">)</a>
<a id="8349" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8358" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>                              <a id="8393" class="Symbol">=</a>  <a id="8396" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8401" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a>
<a id="8408" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8417" class="Symbol">(</a><a id="8418" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="8423" href="/PLFA-zh/Properties/#8423" class="Bound">⊢M</a><a id="8425" class="Symbol">)</a> <a id="8427" class="Keyword">with</a> <a id="8432" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8441" href="/PLFA-zh/Properties/#8423" class="Bound">⊢M</a>
<a id="8444" class="Symbol">...</a>  <a id="8449" class="Symbol">|</a> <a id="8451" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8456" href="/PLFA-zh/Properties/#8456" class="Bound">M—→M′</a>                           <a id="8488" class="Symbol">=</a>  <a id="8491" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8496" class="Symbol">(</a><a id="8497" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="8503" href="/PLFA-zh/Properties/#8456" class="Bound">M—→M′</a><a id="8508" class="Symbol">)</a>
<a id="8510" class="Symbol">...</a>  <a id="8515" class="Symbol">|</a> <a id="8517" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8522" href="/PLFA-zh/Properties/#8522" class="Bound">VM</a>                              <a id="8554" class="Symbol">=</a>  <a id="8557" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8562" class="Symbol">(</a><a id="8563" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="8569" href="/PLFA-zh/Properties/#8522" class="Bound">VM</a><a id="8571" class="Symbol">)</a>
<a id="8573" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8582" class="Symbol">(</a><a id="8583" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="8589" href="/PLFA-zh/Properties/#8589" class="Bound">⊢L</a> <a id="8592" href="/PLFA-zh/Properties/#8592" class="Bound">⊢M</a> <a id="8595" href="/PLFA-zh/Properties/#8595" class="Bound">⊢N</a><a id="8597" class="Symbol">)</a> <a id="8599" class="Keyword">with</a> <a id="8604" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8613" href="/PLFA-zh/Properties/#8589" class="Bound">⊢L</a>
<a id="8616" class="Symbol">...</a> <a id="8620" class="Symbol">|</a> <a id="8622" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8627" href="/PLFA-zh/Properties/#8627" class="Bound">L—→L′</a>                            <a id="8660" class="Symbol">=</a>  <a id="8663" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8668" class="Symbol">(</a><a id="8669" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="8676" href="/PLFA-zh/Properties/#8627" class="Bound">L—→L′</a><a id="8681" class="Symbol">)</a>
<a id="8683" class="Symbol">...</a> <a id="8687" class="Symbol">|</a> <a id="8689" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="8694" href="/PLFA-zh/Properties/#8694" class="Bound">VL</a> <a id="8697" class="Keyword">with</a> <a id="8702" href="/PLFA-zh/Properties/#5241" class="Function">canonical</a> <a id="8712" class="Bound">⊢L</a> <a id="8715" href="/PLFA-zh/Properties/#8694" class="Bound">VL</a>
<a id="8718" class="Symbol">...</a>   <a id="8724" class="Symbol">|</a> <a id="8726" href="/PLFA-zh/Properties/#5008" class="InductiveConstructor">C-zero</a>                              <a id="8762" class="Symbol">=</a>  <a id="8765" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8770" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>
<a id="8777" class="Symbol">...</a>   <a id="8783" class="Symbol">|</a> <a id="8785" href="/PLFA-zh/Properties/#5074" class="InductiveConstructor">C-suc</a> <a id="8791" href="/PLFA-zh/Properties/#8791" class="Bound">CL</a>                            <a id="8821" class="Symbol">=</a>  <a id="8824" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8829" class="Symbol">(</a><a id="8830" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="8836" class="Symbol">(</a><a id="8837" href="/PLFA-zh/Properties/#6353" class="Function">value</a> <a id="8843" href="/PLFA-zh/Properties/#8791" class="Bound">CL</a><a id="8845" class="Symbol">))</a>
<a id="8848" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="8857" class="Symbol">(</a><a id="8858" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="8861" href="/PLFA-zh/Properties/#8861" class="Bound">⊢M</a><a id="8863" class="Symbol">)</a>                            <a id="8892" class="Symbol">=</a>  <a id="8895" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="8900" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a></pre>
<p>We induct on the evidence that the term is well-typed.
Let’s unpack the first three cases:</p>

<ul>
  <li>
    <p>The term cannot be a variable, since no variable is well typed
in the empty context.</p>
  </li>
  <li>
    <p>If the term is a lambda abstraction then it is a value.</p>
  </li>
  <li>
    <p>If the term is an application <code class="highlighter-rouge">L · M</code>, recursively apply
progress to the derivation that <code class="highlighter-rouge">L</code> is well-typed:</p>

    <ul>
      <li>
        <p>If the term steps, we have evidence that <code class="highlighter-rouge">L —→ L′</code>,
which by <code class="highlighter-rouge">ξ-·₁</code> means that our original term steps
to <code class="highlighter-rouge">L′ · M</code></p>
      </li>
      <li>
        <p>If the term is done, we have evidence that <code class="highlighter-rouge">L</code> is
a value. Recursively apply progress to the derivation
that <code class="highlighter-rouge">M</code> is well-typed:</p>

        <ul>
          <li>
            <p>If the term steps, we have evidence that <code class="highlighter-rouge">M —→ M′</code>,
which by <code class="highlighter-rouge">ξ-·₂</code> means that our original term steps
to <code class="highlighter-rouge">L · M′</code>.  Step <code class="highlighter-rouge">ξ-·₂</code> applies only if we have
evidence that <code class="highlighter-rouge">L</code> is a value, but progress on that
subterm has already supplied the required evidence.</p>
          </li>
          <li>
            <p>If the term is done, we have evidence that <code class="highlighter-rouge">M</code> is
a value.  We apply the canonical forms lemma to the
evidence that <code class="highlighter-rouge">L</code> is well typed and a value, which
since we are in an application leads to the
conclusion that <code class="highlighter-rouge">L</code> must be a lambda
abstraction.  We also have evidence that <code class="highlighter-rouge">M</code> is
a value, so our original term steps by <code class="highlighter-rouge">β-ƛ</code>.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The remaining cases are similar.  If by induction we have a
<code class="highlighter-rouge">step</code> case we apply a <code class="highlighter-rouge">ξ</code> rule, and if we have a <code class="highlighter-rouge">done</code> case
then either we have a value or apply a <code class="highlighter-rouge">β</code> rule.  For fixpoint,
no induction is required as the <code class="highlighter-rouge">β</code> rule applies immediately.</p>

<p>Our code reads neatly in part because we consider the
<code class="highlighter-rouge">step</code> option before the <code class="highlighter-rouge">done</code> option. We could, of course,
do it the other way around, but then the <code class="highlighter-rouge">...</code> abbreviation
no longer works, and we will need to write out all the arguments
in full. In general, the rule of thumb is to consider the easy case
(here <code class="highlighter-rouge">step</code>) before the hard case (here <code class="highlighter-rouge">done</code>).
If you have two hard cases, you will have to expand out <code class="highlighter-rouge">...</code>
or introduce subsidiary functions.</p>

<p>Instead of defining a data type for <code class="highlighter-rouge">Progress M</code>, we could
have formulated progress using disjunction and existentials:</p>
<pre class="Agda"><a id="11036" class="Keyword">postulate</a>
  <a id="progress′"></a><a id="11048" href="/PLFA-zh/Properties/#11048" class="Postulate">progress′</a> <a id="11058" class="Symbol">:</a> <a id="11060" class="Symbol">∀</a> <a id="11062" href="/PLFA-zh/Properties/#11062" class="Bound">M</a> <a id="11064" class="Symbol">{</a><a id="11065" href="/PLFA-zh/Properties/#11065" class="Bound">A</a><a id="11066" class="Symbol">}</a> <a id="11068" class="Symbol">→</a> <a id="11070" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="11072" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="11074" href="/PLFA-zh/Properties/#11062" class="Bound">M</a> <a id="11076" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="11078" href="/PLFA-zh/Properties/#11065" class="Bound">A</a> <a id="11080" class="Symbol">→</a> <a id="11082" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="11088" href="/PLFA-zh/Properties/#11062" class="Bound">M</a> <a id="11090" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="11092" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃[</a> <a id="11095" href="/PLFA-zh/Properties/#11095" class="Bound">N</a> <a id="11097" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">]</a><a id="11098" class="Symbol">(</a><a id="11099" href="/PLFA-zh/Properties/#11062" class="Bound">M</a> <a id="11101" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="11104" href="/PLFA-zh/Properties/#11095" class="Bound">N</a><a id="11105" class="Symbol">)</a></pre>
<p>This leads to a less perspicuous proof.  Instead of the mnemonic <code class="highlighter-rouge">done</code>
and <code class="highlighter-rouge">step</code> we use <code class="highlighter-rouge">inj₁</code> and <code class="highlighter-rouge">inj₂</code>, and the term <code class="highlighter-rouge">N</code> is no longer
implicit and so must be written out in full.  In the case for <code class="highlighter-rouge">β-ƛ</code>
this requires that we match against the lambda expression <code class="highlighter-rouge">L</code> to
determine its bound variable and body, <code class="highlighter-rouge">ƛ x ⇒ N</code>, so we can show that
<code class="highlighter-rouge">L · M</code> reduces to <code class="highlighter-rouge">N [ x := M ]</code>.</p>

<h4 id="exercise-progress-">Exercise <code class="highlighter-rouge">Progress-≃</code></h4>

<p>Show that <code class="highlighter-rouge">Progress M</code> is isomorphic to <code class="highlighter-rouge">Value M ⊎ ∃[ N ](M —→ N)</code>.</p>

<pre class="Agda"><a id="11606" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-progress">Exercise <code class="highlighter-rouge">progress′</code></h4>

<p>Write out the proof of <code class="highlighter-rouge">progress′</code> in full, and compare it to the
proof of <code class="highlighter-rouge">progress</code> above.</p>

<pre class="Agda"><a id="11775" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-value">Exercise <code class="highlighter-rouge">value?</code></h4>

<p>Combine <code class="highlighter-rouge">progress</code> and <code class="highlighter-rouge">—→¬V</code> to write a program that decides
whether a well-typed term is a value:</p>
<pre class="Agda"><a id="11947" class="Keyword">postulate</a>
  <a id="value?"></a><a id="11959" href="/PLFA-zh/Properties/#11959" class="Postulate">value?</a> <a id="11966" class="Symbol">:</a> <a id="11968" class="Symbol">∀</a> <a id="11970" class="Symbol">{</a><a id="11971" href="/PLFA-zh/Properties/#11971" class="Bound">A</a> <a id="11973" href="/PLFA-zh/Properties/#11973" class="Bound">M</a><a id="11974" class="Symbol">}</a> <a id="11976" class="Symbol">→</a> <a id="11978" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="11980" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="11982" href="/PLFA-zh/Properties/#11973" class="Bound">M</a> <a id="11984" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="11986" href="/PLFA-zh/Properties/#11971" class="Bound">A</a> <a id="11988" class="Symbol">→</a> <a id="11990" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="11994" class="Symbol">(</a><a id="11995" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="12001" href="/PLFA-zh/Properties/#11973" class="Bound">M</a><a id="12002" class="Symbol">)</a></pre>

<h2 id="prelude-to-preservation">Prelude to preservation</h2>

<p>The other property we wish to prove, preservation of typing under
reduction, turns out to require considerably more work.  The proof has
three key steps.</p>

<p>The first step is to show that types are preserved by <em>renaming</em>.</p>

<p><em>Renaming</em>:
Let <code class="highlighter-rouge">Γ</code> and <code class="highlighter-rouge">Δ</code> be two context such that every variable that
appears in <code class="highlighter-rouge">Γ</code> also appears with the same type in <code class="highlighter-rouge">Δ</code>.  Then
if any term is typeable under <code class="highlighter-rouge">Γ</code>, it has the same type under <code class="highlighter-rouge">Δ</code>.</p>

<p>In symbols:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∀ {x A} → Γ ∋ x ⦂ A  →  Δ ∋ x ⦂ A
---------------------------------
∀ {M A} → Γ ⊢ M ⦂ A  →  Δ ⊢ M ⦂ A
</code></pre></div></div>

<p>Three important corollaries follow.  The <em>weaken</em> lemma asserts a term
well-typed in the empty context is also well-typed in an arbitrary
context.  The <em>drop</em> lemma asserts a term well-typed in a context where the
same variable appears twice remains well-typed if we drop the shadowed
occurrence.  The <em>swap</em> lemma asserts a term well-typed in a context
remains well-typed if we swap two variables.</p>

<p>(Renaming is similar to the <em>context invariance</em> lemma in <em>Software
Foundations</em>, but it does not require the definition of
<code class="highlighter-rouge">appears_free_in</code> nor the <code class="highlighter-rouge">free_in_context</code> lemma.)</p>

<p>The second step is to show that types are preserved by
<em>substitution</em>.</p>

<p><em>Substitution</em>:
Say we have a closed term <code class="highlighter-rouge">V</code> of type <code class="highlighter-rouge">A</code>, and under the
assumption that <code class="highlighter-rouge">x</code> has type <code class="highlighter-rouge">A</code> the term <code class="highlighter-rouge">N</code> has type <code class="highlighter-rouge">B</code>.
Then substituting <code class="highlighter-rouge">V</code> for <code class="highlighter-rouge">x</code> in <code class="highlighter-rouge">N</code> yields a term that
also has type <code class="highlighter-rouge">B</code>.</p>

<p>In symbols:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ A
Γ , x ⦂ A ⊢ N ⦂ B
--------------------
Γ ⊢ N [ x := V ] ⦂ B
</code></pre></div></div>

<p>The result does not depend on <code class="highlighter-rouge">V</code> being a value, but it does
require that <code class="highlighter-rouge">V</code> be closed; recall that we restricted our attention
to substitution by closed terms in order to avoid the need to
rename bound variables.  The term into which we are substituting
is typed in an arbitrary context <code class="highlighter-rouge">Γ</code>, extended by the variable
<code class="highlighter-rouge">x</code> for which we are substituting; and the result term is typed
in <code class="highlighter-rouge">Γ</code>.</p>

<p>The lemma establishes that substitution composes well with typing:
typing the components separately guarantees that the result of
combining them is also well typed.</p>

<p>The third step is to show preservation.</p>

<p><em>Preservation</em>:
If <code class="highlighter-rouge">∅ ⊢ M ⦂ A</code> and <code class="highlighter-rouge">M —→ N</code> then <code class="highlighter-rouge">∅ ⊢ N ⦂ A</code>.</p>

<p>The proof is by induction over the possible reductions, and
the substitution lemma is crucial in showing that each of the
<code class="highlighter-rouge">β</code> rules that uses substitution preserves types.</p>

<p>We now proceed with our three-step programme.</p>

<h2 id="renaming">Renaming</h2>

<p>We often need to “rebase” a type derivation, replacing a derivation
<code class="highlighter-rouge">Γ ⊢ M ⦂ A</code> by a related derivation <code class="highlighter-rouge">Δ ⊢ M ⦂ A</code>.  We may do so as long
as every variable that appears in <code class="highlighter-rouge">Γ</code> also appears in <code class="highlighter-rouge">Δ</code>, and with
the same type.</p>

<p>Three of the rules for typing (lambda abstraction, case on naturals,
and fixpoint) have hypotheses that extend the context to include a
bound variable. In each of these rules, <code class="highlighter-rouge">Γ</code> appears in the conclusion
and <code class="highlighter-rouge">Γ , x ⦂ A</code> appears in a hypothesis.  Thus:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , x ⦂ A ⊢ N ⦂ B
------------------- ⊢ƛ
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ B
</code></pre></div></div>

<p>for lambda expressions, and similarly for case and fixpoint.  To deal
with this situation, we first prove a lemma showing that if one context maps to another, 
this is still true after adding the same variable to
both contexts:</p>
<pre class="Agda"><a id="ext"></a><a id="15244" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="15248" class="Symbol">:</a> <a id="15250" class="Symbol">∀</a> <a id="15252" class="Symbol">{</a><a id="15253" href="/PLFA-zh/Properties/#15253" class="Bound">Γ</a> <a id="15255" href="/PLFA-zh/Properties/#15255" class="Bound">Δ</a><a id="15256" class="Symbol">}</a>
  <a id="15260" class="Symbol">→</a> <a id="15262" class="Symbol">(∀</a> <a id="15265" class="Symbol">{</a><a id="15266" href="/PLFA-zh/Properties/#15266" class="Bound">x</a> <a id="15268" href="/PLFA-zh/Properties/#15268" class="Bound">A</a><a id="15269" class="Symbol">}</a>     <a id="15275" class="Symbol">→</a>         <a id="15285" href="/PLFA-zh/Properties/#15253" class="Bound">Γ</a> <a id="15287" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="15289" href="/PLFA-zh/Properties/#15266" class="Bound">x</a> <a id="15291" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="15293" href="/PLFA-zh/Properties/#15268" class="Bound">A</a> <a id="15295" class="Symbol">→</a>         <a id="15305" href="/PLFA-zh/Properties/#15255" class="Bound">Δ</a> <a id="15307" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="15309" href="/PLFA-zh/Properties/#15266" class="Bound">x</a> <a id="15311" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="15313" href="/PLFA-zh/Properties/#15268" class="Bound">A</a><a id="15314" class="Symbol">)</a>
    <a id="15320" class="Comment">-----------------------------------------------------</a>
  <a id="15376" class="Symbol">→</a> <a id="15378" class="Symbol">(∀</a> <a id="15381" class="Symbol">{</a><a id="15382" href="/PLFA-zh/Properties/#15382" class="Bound">x</a> <a id="15384" href="/PLFA-zh/Properties/#15384" class="Bound">y</a> <a id="15386" href="/PLFA-zh/Properties/#15386" class="Bound">A</a> <a id="15388" href="/PLFA-zh/Properties/#15388" class="Bound">B</a><a id="15389" class="Symbol">}</a> <a id="15391" class="Symbol">→</a> <a id="15393" href="/PLFA-zh/Properties/#15253" class="Bound">Γ</a> <a id="15395" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="15397" href="/PLFA-zh/Properties/#15384" class="Bound">y</a> <a id="15399" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="15401" href="/PLFA-zh/Properties/#15388" class="Bound">B</a> <a id="15403" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="15405" href="/PLFA-zh/Properties/#15382" class="Bound">x</a> <a id="15407" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="15409" href="/PLFA-zh/Properties/#15386" class="Bound">A</a> <a id="15411" class="Symbol">→</a> <a id="15413" href="/PLFA-zh/Properties/#15255" class="Bound">Δ</a> <a id="15415" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="15417" href="/PLFA-zh/Properties/#15384" class="Bound">y</a> <a id="15419" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="15421" href="/PLFA-zh/Properties/#15388" class="Bound">B</a> <a id="15423" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="15425" href="/PLFA-zh/Properties/#15382" class="Bound">x</a> <a id="15427" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="15429" href="/PLFA-zh/Properties/#15386" class="Bound">A</a><a id="15430" class="Symbol">)</a>
<a id="15432" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="15436" href="/PLFA-zh/Properties/#15436" class="Bound">ρ</a> <a id="15438" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>           <a id="15450" class="Symbol">=</a>  <a id="15453" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>
<a id="15455" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="15459" href="/PLFA-zh/Properties/#15459" class="Bound">ρ</a> <a id="15461" class="Symbol">(</a><a id="15462" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="15464" href="/PLFA-zh/Properties/#15464" class="Bound">x≢y</a> <a id="15468" href="/PLFA-zh/Properties/#15468" class="Bound">∋x</a><a id="15470" class="Symbol">)</a>  <a id="15473" class="Symbol">=</a>  <a id="15476" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="15478" href="/PLFA-zh/Properties/#15464" class="Bound">x≢y</a> <a id="15482" class="Symbol">(</a><a id="15483" href="/PLFA-zh/Properties/#15459" class="Bound">ρ</a> <a id="15485" href="/PLFA-zh/Properties/#15468" class="Bound">∋x</a><a id="15487" class="Symbol">)</a></pre>
<p>Let <code class="highlighter-rouge">ρ</code> be the name of the map that takes evidence that
<code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Γ</code> to evidence that <code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Δ</code>.
The proof is by case analysis of the evidence that <code class="highlighter-rouge">x</code> appears
in the extended map <code class="highlighter-rouge">Γ , y ⦂ B</code>:</p>

<ul>
  <li>
    <p>If <code class="highlighter-rouge">x</code> is the same as <code class="highlighter-rouge">y</code>, we used <code class="highlighter-rouge">Z</code> to access the last variable
in the extended <code class="highlighter-rouge">Γ</code>; and can similarly use <code class="highlighter-rouge">Z</code> to access the last
variable in the extended <code class="highlighter-rouge">Δ</code>.</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">x</code> differs from <code class="highlighter-rouge">y</code>, then we used <code class="highlighter-rouge">S</code> to skip over the last
variable in the extended <code class="highlighter-rouge">Γ</code>, where <code class="highlighter-rouge">x≢y</code> is evidence that <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>
differ, and <code class="highlighter-rouge">∋x</code> is the evidence that <code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Γ</code>; and we can
similarly use <code class="highlighter-rouge">S</code> to skip over the last variable in the extended <code class="highlighter-rouge">Δ</code>,
applying <code class="highlighter-rouge">ρ</code> to find the evidence that <code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Δ</code>.</p>
  </li>
</ul>

<p>With the extension lemma under our belts, it is straightforward to
prove renaming preserves types:</p>
<pre class="Agda"><a id="rename"></a><a id="16323" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16330" class="Symbol">:</a> <a id="16332" class="Symbol">∀</a> <a id="16334" class="Symbol">{</a><a id="16335" href="/PLFA-zh/Properties/#16335" class="Bound">Γ</a> <a id="16337" href="/PLFA-zh/Properties/#16337" class="Bound">Δ</a><a id="16338" class="Symbol">}</a>
        <a id="16348" class="Symbol">→</a> <a id="16350" class="Symbol">(∀</a> <a id="16353" class="Symbol">{</a><a id="16354" href="/PLFA-zh/Properties/#16354" class="Bound">x</a> <a id="16356" href="/PLFA-zh/Properties/#16356" class="Bound">A</a><a id="16357" class="Symbol">}</a> <a id="16359" class="Symbol">→</a> <a id="16361" href="/PLFA-zh/Properties/#16335" class="Bound">Γ</a> <a id="16363" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="16365" href="/PLFA-zh/Properties/#16354" class="Bound">x</a> <a id="16367" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="16369" href="/PLFA-zh/Properties/#16356" class="Bound">A</a> <a id="16371" class="Symbol">→</a> <a id="16373" href="/PLFA-zh/Properties/#16337" class="Bound">Δ</a> <a id="16375" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="16377" href="/PLFA-zh/Properties/#16354" class="Bound">x</a> <a id="16379" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="16381" href="/PLFA-zh/Properties/#16356" class="Bound">A</a><a id="16382" class="Symbol">)</a>
          <a id="16394" class="Comment">----------------------------------</a>
        <a id="16437" class="Symbol">→</a> <a id="16439" class="Symbol">(∀</a> <a id="16442" class="Symbol">{</a><a id="16443" href="/PLFA-zh/Properties/#16443" class="Bound">M</a> <a id="16445" href="/PLFA-zh/Properties/#16445" class="Bound">A</a><a id="16446" class="Symbol">}</a> <a id="16448" class="Symbol">→</a> <a id="16450" href="/PLFA-zh/Properties/#16335" class="Bound">Γ</a> <a id="16452" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="16454" href="/PLFA-zh/Properties/#16443" class="Bound">M</a> <a id="16456" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="16458" href="/PLFA-zh/Properties/#16445" class="Bound">A</a> <a id="16460" class="Symbol">→</a> <a id="16462" href="/PLFA-zh/Properties/#16337" class="Bound">Δ</a> <a id="16464" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="16466" href="/PLFA-zh/Properties/#16443" class="Bound">M</a> <a id="16468" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="16470" href="/PLFA-zh/Properties/#16445" class="Bound">A</a><a id="16471" class="Symbol">)</a>
<a id="16473" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16480" href="/PLFA-zh/Properties/#16480" class="Bound">ρ</a> <a id="16482" class="Symbol">(</a><a id="16483" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="16486" href="/PLFA-zh/Properties/#16486" class="Bound">∋w</a><a id="16488" class="Symbol">)</a>           <a id="16500" class="Symbol">=</a>  <a id="16503" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="16506" class="Symbol">(</a><a id="16507" href="/PLFA-zh/Properties/#16480" class="Bound">ρ</a> <a id="16509" href="/PLFA-zh/Properties/#16486" class="Bound">∋w</a><a id="16511" class="Symbol">)</a>
<a id="16513" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16520" href="/PLFA-zh/Properties/#16520" class="Bound">ρ</a> <a id="16522" class="Symbol">(</a><a id="16523" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="16526" href="/PLFA-zh/Properties/#16526" class="Bound">⊢N</a><a id="16528" class="Symbol">)</a>           <a id="16540" class="Symbol">=</a>  <a id="16543" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="16546" class="Symbol">(</a><a id="16547" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16554" class="Symbol">(</a><a id="16555" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="16559" href="/PLFA-zh/Properties/#16520" class="Bound">ρ</a><a id="16560" class="Symbol">)</a> <a id="16562" href="/PLFA-zh/Properties/#16526" class="Bound">⊢N</a><a id="16564" class="Symbol">)</a>
<a id="16566" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16573" href="/PLFA-zh/Properties/#16573" class="Bound">ρ</a> <a id="16575" class="Symbol">(</a><a id="16576" href="/PLFA-zh/Properties/#16576" class="Bound">⊢L</a> <a id="16579" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="16581" href="/PLFA-zh/Properties/#16581" class="Bound">⊢M</a><a id="16583" class="Symbol">)</a>         <a id="16593" class="Symbol">=</a>  <a id="16596" class="Symbol">(</a><a id="16597" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16604" href="/PLFA-zh/Properties/#16573" class="Bound">ρ</a> <a id="16606" href="/PLFA-zh/Properties/#16576" class="Bound">⊢L</a><a id="16608" class="Symbol">)</a> <a id="16610" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="16612" class="Symbol">(</a><a id="16613" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16620" href="/PLFA-zh/Properties/#16573" class="Bound">ρ</a> <a id="16622" href="/PLFA-zh/Properties/#16581" class="Bound">⊢M</a><a id="16624" class="Symbol">)</a>
<a id="16626" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16633" href="/PLFA-zh/Properties/#16633" class="Bound">ρ</a> <a id="16635" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>             <a id="16653" class="Symbol">=</a>  <a id="16656" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>
<a id="16662" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16669" href="/PLFA-zh/Properties/#16669" class="Bound">ρ</a> <a id="16671" class="Symbol">(</a><a id="16672" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="16677" href="/PLFA-zh/Properties/#16677" class="Bound">⊢M</a><a id="16679" class="Symbol">)</a>         <a id="16689" class="Symbol">=</a>  <a id="16692" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="16697" class="Symbol">(</a><a id="16698" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16705" href="/PLFA-zh/Properties/#16669" class="Bound">ρ</a> <a id="16707" href="/PLFA-zh/Properties/#16677" class="Bound">⊢M</a><a id="16709" class="Symbol">)</a>
<a id="16711" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16718" href="/PLFA-zh/Properties/#16718" class="Bound">ρ</a> <a id="16720" class="Symbol">(</a><a id="16721" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="16727" href="/PLFA-zh/Properties/#16727" class="Bound">⊢L</a> <a id="16730" href="/PLFA-zh/Properties/#16730" class="Bound">⊢M</a> <a id="16733" href="/PLFA-zh/Properties/#16733" class="Bound">⊢N</a><a id="16735" class="Symbol">)</a>  <a id="16738" class="Symbol">=</a>  <a id="16741" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="16747" class="Symbol">(</a><a id="16748" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16755" href="/PLFA-zh/Properties/#16718" class="Bound">ρ</a> <a id="16757" href="/PLFA-zh/Properties/#16727" class="Bound">⊢L</a><a id="16759" class="Symbol">)</a> <a id="16761" class="Symbol">(</a><a id="16762" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16769" href="/PLFA-zh/Properties/#16718" class="Bound">ρ</a> <a id="16771" href="/PLFA-zh/Properties/#16730" class="Bound">⊢M</a><a id="16773" class="Symbol">)</a> <a id="16775" class="Symbol">(</a><a id="16776" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16783" class="Symbol">(</a><a id="16784" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="16788" href="/PLFA-zh/Properties/#16718" class="Bound">ρ</a><a id="16789" class="Symbol">)</a> <a id="16791" href="/PLFA-zh/Properties/#16733" class="Bound">⊢N</a><a id="16793" class="Symbol">)</a>
<a id="16795" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16802" href="/PLFA-zh/Properties/#16802" class="Bound">ρ</a> <a id="16804" class="Symbol">(</a><a id="16805" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="16808" href="/PLFA-zh/Properties/#16808" class="Bound">⊢M</a><a id="16810" class="Symbol">)</a>           <a id="16822" class="Symbol">=</a>  <a id="16825" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="16828" class="Symbol">(</a><a id="16829" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="16836" class="Symbol">(</a><a id="16837" href="/PLFA-zh/Properties/#15244" class="Function">ext</a> <a id="16841" href="/PLFA-zh/Properties/#16802" class="Bound">ρ</a><a id="16842" class="Symbol">)</a> <a id="16844" href="/PLFA-zh/Properties/#16808" class="Bound">⊢M</a><a id="16846" class="Symbol">)</a></pre>
<p>As before, let <code class="highlighter-rouge">ρ</code> be the name of the map that takes evidence that
<code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Γ</code> to evidence that <code class="highlighter-rouge">x</code> appears in <code class="highlighter-rouge">Δ</code>.  We induct
on the evidence that <code class="highlighter-rouge">M</code> is well-typed in <code class="highlighter-rouge">Γ</code>.  Let’s unpack the
first three cases:</p>

<ul>
  <li>
    <p>If the term is a variable, then applying <code class="highlighter-rouge">ρ</code> to the evidence
that the variable appears in <code class="highlighter-rouge">Γ</code> yields the corresponding evidence that
the variable appears in <code class="highlighter-rouge">Δ</code>.</p>
  </li>
  <li>
    <p>If the term is a lambda abstraction, use the previous lemma to
extend the map <code class="highlighter-rouge">ρ</code> suitably and use induction to rename the body of the
abstraction</p>
  </li>
  <li>
    <p>If the term is an application, use induction to rename both the
function and the argument.</p>
  </li>
</ul>

<p>The remaining cases are similar, using induction for each subterm, and
extending the map whenever the construct introduces a bound variable.</p>

<p>The induction is over the derivation that the term is well-typed,
so extending the context doesn’t invalidate the inductive hypothesis.
Equivalently, the recursion terminates because the second argument
always grows smaller, even though the first argument sometimes grows larger.</p>

<p>We have three important corollaries, each proved by constructing
a suitable map between contexts.</p>

<p>First, a closed term can be weakened to any context:</p>
<pre class="Agda"><a id="weaken"></a><a id="18075" href="/PLFA-zh/Properties/#18075" class="Function">weaken</a> <a id="18082" class="Symbol">:</a> <a id="18084" class="Symbol">∀</a> <a id="18086" class="Symbol">{</a><a id="18087" href="/PLFA-zh/Properties/#18087" class="Bound">Γ</a> <a id="18089" href="/PLFA-zh/Properties/#18089" class="Bound">M</a> <a id="18091" href="/PLFA-zh/Properties/#18091" class="Bound">A</a><a id="18092" class="Symbol">}</a>
  <a id="18096" class="Symbol">→</a> <a id="18098" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="18100" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="18102" href="/PLFA-zh/Properties/#18089" class="Bound">M</a> <a id="18104" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="18106" href="/PLFA-zh/Properties/#18091" class="Bound">A</a>
    <a id="18112" class="Comment">----------</a>
  <a id="18125" class="Symbol">→</a> <a id="18127" href="/PLFA-zh/Properties/#18087" class="Bound">Γ</a> <a id="18129" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="18131" href="/PLFA-zh/Properties/#18089" class="Bound">M</a> <a id="18133" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="18135" href="/PLFA-zh/Properties/#18091" class="Bound">A</a>
<a id="18137" href="/PLFA-zh/Properties/#18075" class="Function">weaken</a> <a id="18144" class="Symbol">{</a><a id="18145" href="/PLFA-zh/Properties/#18145" class="Bound">Γ</a><a id="18146" class="Symbol">}</a> <a id="18148" href="/PLFA-zh/Properties/#18148" class="Bound">⊢M</a> <a id="18151" class="Symbol">=</a> <a id="18153" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="18160" href="/PLFA-zh/Properties/#18175" class="Function">ρ</a> <a id="18162" href="/PLFA-zh/Properties/#18148" class="Bound">⊢M</a>
  <a id="18167" class="Keyword">where</a>
  <a id="18175" href="/PLFA-zh/Properties/#18175" class="Function">ρ</a> <a id="18177" class="Symbol">:</a> <a id="18179" class="Symbol">∀</a> <a id="18181" class="Symbol">{</a><a id="18182" href="/PLFA-zh/Properties/#18182" class="Bound">z</a> <a id="18184" href="/PLFA-zh/Properties/#18184" class="Bound">C</a><a id="18185" class="Symbol">}</a>
    <a id="18191" class="Symbol">→</a> <a id="18193" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="18195" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="18197" href="/PLFA-zh/Properties/#18182" class="Bound">z</a> <a id="18199" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="18201" href="/PLFA-zh/Properties/#18184" class="Bound">C</a>
      <a id="18209" class="Comment">---------</a>
    <a id="18223" class="Symbol">→</a> <a id="18225" href="/PLFA-zh/Properties/#18145" class="Bound">Γ</a> <a id="18227" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="18229" href="/PLFA-zh/Properties/#18182" class="Bound">z</a> <a id="18231" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="18233" href="/PLFA-zh/Properties/#18184" class="Bound">C</a>
  <a id="18237" href="/PLFA-zh/Properties/#18175" class="Function">ρ</a> <a id="18239" class="Symbol">()</a></pre>
<p>Here the map <code class="highlighter-rouge">ρ</code> is trivial, since there are no possible
arguments in the empty context <code class="highlighter-rouge">∅</code>.</p>

<p>Second, if the last two variables in a context are equal then we can
drop the shadowed one:</p>
<pre class="Agda"><a id="drop"></a><a id="18452" href="/PLFA-zh/Properties/#18452" class="Function">drop</a> <a id="18457" class="Symbol">:</a> <a id="18459" class="Symbol">∀</a> <a id="18461" class="Symbol">{</a><a id="18462" href="/PLFA-zh/Properties/#18462" class="Bound">Γ</a> <a id="18464" href="/PLFA-zh/Properties/#18464" class="Bound">x</a> <a id="18466" href="/PLFA-zh/Properties/#18466" class="Bound">M</a> <a id="18468" href="/PLFA-zh/Properties/#18468" class="Bound">A</a> <a id="18470" href="/PLFA-zh/Properties/#18470" class="Bound">B</a> <a id="18472" href="/PLFA-zh/Properties/#18472" class="Bound">C</a><a id="18473" class="Symbol">}</a>
  <a id="18477" class="Symbol">→</a> <a id="18479" href="/PLFA-zh/Properties/#18462" class="Bound">Γ</a> <a id="18481" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18483" href="/PLFA-zh/Properties/#18464" class="Bound">x</a> <a id="18485" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18487" href="/PLFA-zh/Properties/#18468" class="Bound">A</a> <a id="18489" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18491" href="/PLFA-zh/Properties/#18464" class="Bound">x</a> <a id="18493" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18495" href="/PLFA-zh/Properties/#18470" class="Bound">B</a> <a id="18497" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="18499" href="/PLFA-zh/Properties/#18466" class="Bound">M</a> <a id="18501" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="18503" href="/PLFA-zh/Properties/#18472" class="Bound">C</a>
    <a id="18509" class="Comment">--------------------------</a>
  <a id="18538" class="Symbol">→</a> <a id="18540" href="/PLFA-zh/Properties/#18462" class="Bound">Γ</a> <a id="18542" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18544" href="/PLFA-zh/Properties/#18464" class="Bound">x</a> <a id="18546" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18548" href="/PLFA-zh/Properties/#18470" class="Bound">B</a> <a id="18550" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="18552" href="/PLFA-zh/Properties/#18466" class="Bound">M</a> <a id="18554" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="18556" href="/PLFA-zh/Properties/#18472" class="Bound">C</a>
<a id="18558" href="/PLFA-zh/Properties/#18452" class="Function">drop</a> <a id="18563" class="Symbol">{</a><a id="18564" href="/PLFA-zh/Properties/#18564" class="Bound">Γ</a><a id="18565" class="Symbol">}</a> <a id="18567" class="Symbol">{</a><a id="18568" href="/PLFA-zh/Properties/#18568" class="Bound">x</a><a id="18569" class="Symbol">}</a> <a id="18571" class="Symbol">{</a><a id="18572" href="/PLFA-zh/Properties/#18572" class="Bound">M</a><a id="18573" class="Symbol">}</a> <a id="18575" class="Symbol">{</a><a id="18576" href="/PLFA-zh/Properties/#18576" class="Bound">A</a><a id="18577" class="Symbol">}</a> <a id="18579" class="Symbol">{</a><a id="18580" href="/PLFA-zh/Properties/#18580" class="Bound">B</a><a id="18581" class="Symbol">}</a> <a id="18583" class="Symbol">{</a><a id="18584" href="/PLFA-zh/Properties/#18584" class="Bound">C</a><a id="18585" class="Symbol">}</a> <a id="18587" href="/PLFA-zh/Properties/#18587" class="Bound">⊢M</a> <a id="18590" class="Symbol">=</a> <a id="18592" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="18599" href="/PLFA-zh/Properties/#18614" class="Function">ρ</a> <a id="18601" href="/PLFA-zh/Properties/#18587" class="Bound">⊢M</a>
  <a id="18606" class="Keyword">where</a>
  <a id="18614" href="/PLFA-zh/Properties/#18614" class="Function">ρ</a> <a id="18616" class="Symbol">:</a> <a id="18618" class="Symbol">∀</a> <a id="18620" class="Symbol">{</a><a id="18621" href="/PLFA-zh/Properties/#18621" class="Bound">z</a> <a id="18623" href="/PLFA-zh/Properties/#18623" class="Bound">C</a><a id="18624" class="Symbol">}</a>
    <a id="18630" class="Symbol">→</a> <a id="18632" href="/PLFA-zh/Properties/#18564" class="Bound">Γ</a> <a id="18634" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18636" href="/PLFA-zh/Properties/#18568" class="Bound">x</a> <a id="18638" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18640" href="/PLFA-zh/Properties/#18576" class="Bound">A</a> <a id="18642" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18644" href="/PLFA-zh/Properties/#18568" class="Bound">x</a> <a id="18646" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18648" href="/PLFA-zh/Properties/#18580" class="Bound">B</a> <a id="18650" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="18652" href="/PLFA-zh/Properties/#18621" class="Bound">z</a> <a id="18654" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="18656" href="/PLFA-zh/Properties/#18623" class="Bound">C</a>
      <a id="18664" class="Comment">-------------------------</a>
    <a id="18694" class="Symbol">→</a> <a id="18696" href="/PLFA-zh/Properties/#18564" class="Bound">Γ</a> <a id="18698" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="18700" href="/PLFA-zh/Properties/#18568" class="Bound">x</a> <a id="18702" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="18704" href="/PLFA-zh/Properties/#18580" class="Bound">B</a> <a id="18706" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="18708" href="/PLFA-zh/Properties/#18621" class="Bound">z</a> <a id="18710" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="18712" href="/PLFA-zh/Properties/#18623" class="Bound">C</a>
  <a id="18716" href="/PLFA-zh/Properties/#18614" class="Function">ρ</a> <a id="18718" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>                 <a id="18736" class="Symbol">=</a>  <a id="18739" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>
  <a id="18743" href="/PLFA-zh/Properties/#18614" class="Function">ρ</a> <a id="18745" class="Symbol">(</a><a id="18746" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="18748" href="/PLFA-zh/Properties/#18748" class="Bound">x≢x</a> <a id="18752" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a><a id="18753" class="Symbol">)</a>         <a id="18763" class="Symbol">=</a>  <a id="18766" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="18773" class="Symbol">(</a><a id="18774" href="/PLFA-zh/Properties/#18748" class="Bound">x≢x</a> <a id="18778" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="18782" class="Symbol">)</a>
  <a id="18786" href="/PLFA-zh/Properties/#18614" class="Function">ρ</a> <a id="18788" class="Symbol">(</a><a id="18789" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="18791" href="/PLFA-zh/Properties/#18791" class="Bound">z≢x</a> <a id="18795" class="Symbol">(</a><a id="18796" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="18798" class="Symbol">_</a> <a id="18800" href="/PLFA-zh/Properties/#18800" class="Bound">∋z</a><a id="18802" class="Symbol">))</a>  <a id="18806" class="Symbol">=</a>  <a id="18809" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="18811" href="/PLFA-zh/Properties/#18791" class="Bound">z≢x</a> <a id="18815" href="/PLFA-zh/Properties/#18800" class="Bound">∋z</a></pre>
<p>Here map <code class="highlighter-rouge">ρ</code> can never be invoked on the inner occurrence of <code class="highlighter-rouge">x</code> since
it is masked by the outer occurrence.  Skipping over the <code class="highlighter-rouge">x</code> in the
first position can only happen if the variable looked for differs from
<code class="highlighter-rouge">x</code> (the evidence for which is <code class="highlighter-rouge">x≢x</code> or <code class="highlighter-rouge">z≢x</code>) but if the variable is
found in the second position, which also contains <code class="highlighter-rouge">x</code>, this leads to a
contradiction (evidenced by <code class="highlighter-rouge">x≢x refl</code>).</p>

<p>Third, if the last two variables in a context differ then we can swap them:</p>
<pre class="Agda"><a id="swap"></a><a id="19311" href="/PLFA-zh/Properties/#19311" class="Function">swap</a> <a id="19316" class="Symbol">:</a> <a id="19318" class="Symbol">∀</a> <a id="19320" class="Symbol">{</a><a id="19321" href="/PLFA-zh/Properties/#19321" class="Bound">Γ</a> <a id="19323" href="/PLFA-zh/Properties/#19323" class="Bound">x</a> <a id="19325" href="/PLFA-zh/Properties/#19325" class="Bound">y</a> <a id="19327" href="/PLFA-zh/Properties/#19327" class="Bound">M</a> <a id="19329" href="/PLFA-zh/Properties/#19329" class="Bound">A</a> <a id="19331" href="/PLFA-zh/Properties/#19331" class="Bound">B</a> <a id="19333" href="/PLFA-zh/Properties/#19333" class="Bound">C</a><a id="19334" class="Symbol">}</a>
  <a id="19338" class="Symbol">→</a> <a id="19340" href="/PLFA-zh/Properties/#19323" class="Bound">x</a> <a id="19342" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">≢</a> <a id="19344" href="/PLFA-zh/Properties/#19325" class="Bound">y</a>
  <a id="19348" class="Symbol">→</a> <a id="19350" href="/PLFA-zh/Properties/#19321" class="Bound">Γ</a> <a id="19352" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19354" href="/PLFA-zh/Properties/#19325" class="Bound">y</a> <a id="19356" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19358" href="/PLFA-zh/Properties/#19331" class="Bound">B</a> <a id="19360" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19362" href="/PLFA-zh/Properties/#19323" class="Bound">x</a> <a id="19364" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19366" href="/PLFA-zh/Properties/#19329" class="Bound">A</a> <a id="19368" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="19370" href="/PLFA-zh/Properties/#19327" class="Bound">M</a> <a id="19372" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="19374" href="/PLFA-zh/Properties/#19333" class="Bound">C</a>
    <a id="19380" class="Comment">--------------------------</a>
  <a id="19409" class="Symbol">→</a> <a id="19411" href="/PLFA-zh/Properties/#19321" class="Bound">Γ</a> <a id="19413" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19415" href="/PLFA-zh/Properties/#19323" class="Bound">x</a> <a id="19417" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19419" href="/PLFA-zh/Properties/#19329" class="Bound">A</a> <a id="19421" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19423" href="/PLFA-zh/Properties/#19325" class="Bound">y</a> <a id="19425" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19427" href="/PLFA-zh/Properties/#19331" class="Bound">B</a> <a id="19429" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="19431" href="/PLFA-zh/Properties/#19327" class="Bound">M</a> <a id="19433" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="19435" href="/PLFA-zh/Properties/#19333" class="Bound">C</a>
<a id="19437" href="/PLFA-zh/Properties/#19311" class="Function">swap</a> <a id="19442" class="Symbol">{</a><a id="19443" href="/PLFA-zh/Properties/#19443" class="Bound">Γ</a><a id="19444" class="Symbol">}</a> <a id="19446" class="Symbol">{</a><a id="19447" href="/PLFA-zh/Properties/#19447" class="Bound">x</a><a id="19448" class="Symbol">}</a> <a id="19450" class="Symbol">{</a><a id="19451" href="/PLFA-zh/Properties/#19451" class="Bound">y</a><a id="19452" class="Symbol">}</a> <a id="19454" class="Symbol">{</a><a id="19455" href="/PLFA-zh/Properties/#19455" class="Bound">M</a><a id="19456" class="Symbol">}</a> <a id="19458" class="Symbol">{</a><a id="19459" href="/PLFA-zh/Properties/#19459" class="Bound">A</a><a id="19460" class="Symbol">}</a> <a id="19462" class="Symbol">{</a><a id="19463" href="/PLFA-zh/Properties/#19463" class="Bound">B</a><a id="19464" class="Symbol">}</a> <a id="19466" class="Symbol">{</a><a id="19467" href="/PLFA-zh/Properties/#19467" class="Bound">C</a><a id="19468" class="Symbol">}</a> <a id="19470" href="/PLFA-zh/Properties/#19470" class="Bound">x≢y</a> <a id="19474" href="/PLFA-zh/Properties/#19474" class="Bound">⊢M</a> <a id="19477" class="Symbol">=</a> <a id="19479" href="/PLFA-zh/Properties/#16323" class="Function">rename</a> <a id="19486" href="/PLFA-zh/Properties/#19501" class="Function">ρ</a> <a id="19488" href="/PLFA-zh/Properties/#19474" class="Bound">⊢M</a>
  <a id="19493" class="Keyword">where</a>
  <a id="19501" href="/PLFA-zh/Properties/#19501" class="Function">ρ</a> <a id="19503" class="Symbol">:</a> <a id="19505" class="Symbol">∀</a> <a id="19507" class="Symbol">{</a><a id="19508" href="/PLFA-zh/Properties/#19508" class="Bound">z</a> <a id="19510" href="/PLFA-zh/Properties/#19510" class="Bound">C</a><a id="19511" class="Symbol">}</a>
    <a id="19517" class="Symbol">→</a> <a id="19519" href="/PLFA-zh/Properties/#19443" class="Bound">Γ</a> <a id="19521" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19523" href="/PLFA-zh/Properties/#19451" class="Bound">y</a> <a id="19525" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19527" href="/PLFA-zh/Properties/#19463" class="Bound">B</a> <a id="19529" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19531" href="/PLFA-zh/Properties/#19447" class="Bound">x</a> <a id="19533" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19535" href="/PLFA-zh/Properties/#19459" class="Bound">A</a> <a id="19537" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="19539" href="/PLFA-zh/Properties/#19508" class="Bound">z</a> <a id="19541" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="19543" href="/PLFA-zh/Properties/#19510" class="Bound">C</a>
      <a id="19551" class="Comment">--------------------------</a>
    <a id="19582" class="Symbol">→</a> <a id="19584" href="/PLFA-zh/Properties/#19443" class="Bound">Γ</a> <a id="19586" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19588" href="/PLFA-zh/Properties/#19447" class="Bound">x</a> <a id="19590" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19592" href="/PLFA-zh/Properties/#19459" class="Bound">A</a> <a id="19594" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="19596" href="/PLFA-zh/Properties/#19451" class="Bound">y</a> <a id="19598" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="19600" href="/PLFA-zh/Properties/#19463" class="Bound">B</a> <a id="19602" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">∋</a> <a id="19604" href="/PLFA-zh/Properties/#19508" class="Bound">z</a> <a id="19606" href="/PLFA-zh/Lambda/#31335" class="Datatype Operator">⦂</a> <a id="19608" href="/PLFA-zh/Properties/#19510" class="Bound">C</a>
  <a id="19612" href="/PLFA-zh/Properties/#19501" class="Function">ρ</a> <a id="19614" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>                   <a id="19634" class="Symbol">=</a>  <a id="19637" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19639" href="/PLFA-zh/Properties/#19470" class="Bound">x≢y</a> <a id="19643" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>
  <a id="19647" href="/PLFA-zh/Properties/#19501" class="Function">ρ</a> <a id="19649" class="Symbol">(</a><a id="19650" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19652" href="/PLFA-zh/Properties/#19652" class="Bound">y≢x</a> <a id="19656" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a><a id="19657" class="Symbol">)</a>           <a id="19669" class="Symbol">=</a>  <a id="19672" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a>
  <a id="19676" href="/PLFA-zh/Properties/#19501" class="Function">ρ</a> <a id="19678" class="Symbol">(</a><a id="19679" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19681" href="/PLFA-zh/Properties/#19681" class="Bound">z≢x</a> <a id="19685" class="Symbol">(</a><a id="19686" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19688" href="/PLFA-zh/Properties/#19688" class="Bound">z≢y</a> <a id="19692" href="/PLFA-zh/Properties/#19692" class="Bound">∋z</a><a id="19694" class="Symbol">))</a>  <a id="19698" class="Symbol">=</a>  <a id="19701" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19703" href="/PLFA-zh/Properties/#19688" class="Bound">z≢y</a> <a id="19707" class="Symbol">(</a><a id="19708" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="19710" href="/PLFA-zh/Properties/#19681" class="Bound">z≢x</a> <a id="19714" href="/PLFA-zh/Properties/#19692" class="Bound">∋z</a><a id="19716" class="Symbol">)</a></pre>
<p>Here the renaming map takes a variable at the end into a variable one
from the end, and vice versa.  The first line is responsible for
moving <code class="highlighter-rouge">x</code> from a position at the end to a position one from the end
with <code class="highlighter-rouge">y</code> at the end, and requires the provided evidence that <code class="highlighter-rouge">x ≢ y</code>.</p>

<h2 id="substitution">Substitution</h2>

<p>The key to preservation – and the trickiest bit of the proof – is
the lemma establishing that substitution preserves types.</p>

<p>Recall that in order to avoid renaming bound variables,
substitution is restricted to be by closed terms only.
This restriction was not enforced by our definition of substitution,
but it is captured by our lemma to assert that substitution
preserves typing.</p>

<p>Our concern is with reducing closed terms, which means that when
we apply <code class="highlighter-rouge">β</code> reduction, the term substituted in contains a single
free variable (the bound variable of the lambda abstraction, or
similarly for case or fixpoint). However, substitution
is defined by recursion, and as we descend into terms with bound
variables the context grows.  So for the induction to go through,
we require an arbitrary context <code class="highlighter-rouge">Γ</code>, as in the statement of the lemma.</p>

<p>Here is the formal statement and proof that substitution preserves types:</p>
<pre class="Agda"><a id="subst"></a><a id="20946" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="20952" class="Symbol">:</a> <a id="20954" class="Symbol">∀</a> <a id="20956" class="Symbol">{</a><a id="20957" href="/PLFA-zh/Properties/#20957" class="Bound">Γ</a> <a id="20959" href="/PLFA-zh/Properties/#20959" class="Bound">x</a> <a id="20961" href="/PLFA-zh/Properties/#20961" class="Bound">N</a> <a id="20963" href="/PLFA-zh/Properties/#20963" class="Bound">V</a> <a id="20965" href="/PLFA-zh/Properties/#20965" class="Bound">A</a> <a id="20967" href="/PLFA-zh/Properties/#20967" class="Bound">B</a><a id="20968" class="Symbol">}</a>
  <a id="20972" class="Symbol">→</a> <a id="20974" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="20976" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="20978" href="/PLFA-zh/Properties/#20963" class="Bound">V</a> <a id="20980" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="20982" href="/PLFA-zh/Properties/#20965" class="Bound">A</a>
  <a id="20986" class="Symbol">→</a> <a id="20988" href="/PLFA-zh/Properties/#20957" class="Bound">Γ</a> <a id="20990" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">,</a> <a id="20992" href="/PLFA-zh/Properties/#20959" class="Bound">x</a> <a id="20994" href="/PLFA-zh/Lambda/#30394" class="InductiveConstructor Operator">⦂</a> <a id="20996" href="/PLFA-zh/Properties/#20965" class="Bound">A</a> <a id="20998" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="21000" href="/PLFA-zh/Properties/#20961" class="Bound">N</a> <a id="21002" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="21004" href="/PLFA-zh/Properties/#20967" class="Bound">B</a>
    <a id="21010" class="Comment">--------------------</a>
  <a id="21033" class="Symbol">→</a> <a id="21035" href="/PLFA-zh/Properties/#20957" class="Bound">Γ</a> <a id="21037" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="21039" href="/PLFA-zh/Properties/#20961" class="Bound">N</a> <a id="21041" href="/PLFA-zh/Lambda/#14889" class="Function Operator">[</a> <a id="21043" href="/PLFA-zh/Properties/#20959" class="Bound">x</a> <a id="21045" href="/PLFA-zh/Lambda/#14889" class="Function Operator">:=</a> <a id="21048" href="/PLFA-zh/Properties/#20963" class="Bound">V</a> <a id="21050" href="/PLFA-zh/Lambda/#14889" class="Function Operator">]</a> <a id="21052" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="21054" href="/PLFA-zh/Properties/#20967" class="Bound">B</a>

<a id="21057" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21063" class="Symbol">{</a><a id="21064" class="Argument">x</a> <a id="21066" class="Symbol">=</a> <a id="21068" href="/PLFA-zh/Properties/#21068" class="Bound">y</a><a id="21069" class="Symbol">}</a> <a id="21071" href="/PLFA-zh/Properties/#21071" class="Bound">⊢V</a> <a id="21074" class="Symbol">(</a><a id="21075" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="21078" class="Symbol">{</a><a id="21079" class="Argument">x</a> <a id="21081" class="Symbol">=</a> <a id="21083" href="/PLFA-zh/Properties/#21083" class="Bound">x</a><a id="21084" class="Symbol">}</a> <a id="21086" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a><a id="21087" class="Symbol">)</a> <a id="21089" class="Keyword">with</a> <a id="21094" href="/PLFA-zh/Properties/#21083" class="Bound">x</a> <a id="21096" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="21098" href="/PLFA-zh/Properties/#21068" class="Bound">y</a>
<a id="21100" class="Symbol">...</a> <a id="21104" class="Symbol">|</a> <a id="21106" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="21110" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>        <a id="21122" class="Symbol">=</a>  <a id="21125" href="/PLFA-zh/Properties/#18075" class="Function">weaken</a> <a id="21132" class="Bound">⊢V</a>
<a id="21135" class="Symbol">...</a> <a id="21139" class="Symbol">|</a> <a id="21141" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="21145" href="/PLFA-zh/Properties/#21145" class="Bound">x≢y</a>         <a id="21157" class="Symbol">=</a>  <a id="21160" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="21167" class="Symbol">(</a><a id="21168" href="/PLFA-zh/Properties/#21145" class="Bound">x≢y</a> <a id="21172" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="21176" class="Symbol">)</a>
<a id="21178" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21184" class="Symbol">{</a><a id="21185" class="Argument">x</a> <a id="21187" class="Symbol">=</a> <a id="21189" href="/PLFA-zh/Properties/#21189" class="Bound">y</a><a id="21190" class="Symbol">}</a> <a id="21192" href="/PLFA-zh/Properties/#21192" class="Bound">⊢V</a> <a id="21195" class="Symbol">(</a><a id="21196" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="21199" class="Symbol">{</a><a id="21200" class="Argument">x</a> <a id="21202" class="Symbol">=</a> <a id="21204" href="/PLFA-zh/Properties/#21204" class="Bound">x</a><a id="21205" class="Symbol">}</a> <a id="21207" class="Symbol">(</a><a id="21208" href="/PLFA-zh/Lambda/#31444" class="InductiveConstructor">S</a> <a id="21210" href="/PLFA-zh/Properties/#21210" class="Bound">x≢y</a> <a id="21214" href="/PLFA-zh/Properties/#21214" class="Bound">∋x</a><a id="21216" class="Symbol">))</a> <a id="21219" class="Keyword">with</a> <a id="21224" href="/PLFA-zh/Properties/#21204" class="Bound">x</a> <a id="21226" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="21228" href="/PLFA-zh/Properties/#21189" class="Bound">y</a>
<a id="21230" class="Symbol">...</a> <a id="21234" class="Symbol">|</a> <a id="21236" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="21240" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>        <a id="21252" class="Symbol">=</a>  <a id="21255" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="21262" class="Symbol">(</a><a id="21263" class="Bound">x≢y</a> <a id="21267" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="21271" class="Symbol">)</a>
<a id="21273" class="Symbol">...</a> <a id="21277" class="Symbol">|</a> <a id="21279" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="21283" class="Symbol">_</a>           <a id="21295" class="Symbol">=</a>  <a id="21298" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="21301" class="Bound">∋x</a>
<a id="21304" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21310" class="Symbol">{</a><a id="21311" class="Argument">x</a> <a id="21313" class="Symbol">=</a> <a id="21315" href="/PLFA-zh/Properties/#21315" class="Bound">y</a><a id="21316" class="Symbol">}</a> <a id="21318" href="/PLFA-zh/Properties/#21318" class="Bound">⊢V</a> <a id="21321" class="Symbol">(</a><a id="21322" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="21325" class="Symbol">{</a><a id="21326" class="Argument">x</a> <a id="21328" class="Symbol">=</a> <a id="21330" href="/PLFA-zh/Properties/#21330" class="Bound">x</a><a id="21331" class="Symbol">}</a> <a id="21333" href="/PLFA-zh/Properties/#21333" class="Bound">⊢N</a><a id="21335" class="Symbol">)</a> <a id="21337" class="Keyword">with</a> <a id="21342" href="/PLFA-zh/Properties/#21330" class="Bound">x</a> <a id="21344" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="21346" href="/PLFA-zh/Properties/#21315" class="Bound">y</a>
<a id="21348" class="Symbol">...</a> <a id="21352" class="Symbol">|</a> <a id="21354" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="21358" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>        <a id="21370" class="Symbol">=</a>  <a id="21373" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="21376" class="Symbol">(</a><a id="21377" href="/PLFA-zh/Properties/#18452" class="Function">drop</a> <a id="21382" class="Bound">⊢N</a><a id="21384" class="Symbol">)</a>
<a id="21386" class="Symbol">...</a> <a id="21390" class="Symbol">|</a> <a id="21392" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="21396" href="/PLFA-zh/Properties/#21396" class="Bound">x≢y</a>         <a id="21408" class="Symbol">=</a>  <a id="21411" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="21414" class="Symbol">(</a><a id="21415" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21421" class="Bound">⊢V</a> <a id="21424" class="Symbol">(</a><a id="21425" href="/PLFA-zh/Properties/#19311" class="Function">swap</a> <a id="21430" href="/PLFA-zh/Properties/#21396" class="Bound">x≢y</a> <a id="21434" class="Bound">⊢N</a><a id="21436" class="Symbol">))</a>
<a id="21439" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21445" href="/PLFA-zh/Properties/#21445" class="Bound">⊢V</a> <a id="21448" class="Symbol">(</a><a id="21449" href="/PLFA-zh/Properties/#21449" class="Bound">⊢L</a> <a id="21452" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="21454" href="/PLFA-zh/Properties/#21454" class="Bound">⊢M</a><a id="21456" class="Symbol">)</a>    <a id="21461" class="Symbol">=</a>  <a id="21464" class="Symbol">(</a><a id="21465" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21471" href="/PLFA-zh/Properties/#21445" class="Bound">⊢V</a> <a id="21474" href="/PLFA-zh/Properties/#21449" class="Bound">⊢L</a><a id="21476" class="Symbol">)</a> <a id="21478" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="21480" class="Symbol">(</a><a id="21481" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21487" href="/PLFA-zh/Properties/#21445" class="Bound">⊢V</a> <a id="21490" href="/PLFA-zh/Properties/#21454" class="Bound">⊢M</a><a id="21492" class="Symbol">)</a>
<a id="21494" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21500" href="/PLFA-zh/Properties/#21500" class="Bound">⊢V</a> <a id="21503" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>        <a id="21516" class="Symbol">=</a>  <a id="21519" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>
<a id="21525" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21531" href="/PLFA-zh/Properties/#21531" class="Bound">⊢V</a> <a id="21534" class="Symbol">(</a><a id="21535" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="21540" href="/PLFA-zh/Properties/#21540" class="Bound">⊢M</a><a id="21542" class="Symbol">)</a>    <a id="21547" class="Symbol">=</a>  <a id="21550" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="21555" class="Symbol">(</a><a id="21556" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21562" href="/PLFA-zh/Properties/#21531" class="Bound">⊢V</a> <a id="21565" href="/PLFA-zh/Properties/#21540" class="Bound">⊢M</a><a id="21567" class="Symbol">)</a>
<a id="21569" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21575" class="Symbol">{</a><a id="21576" class="Argument">x</a> <a id="21578" class="Symbol">=</a> <a id="21580" href="/PLFA-zh/Properties/#21580" class="Bound">y</a><a id="21581" class="Symbol">}</a> <a id="21583" href="/PLFA-zh/Properties/#21583" class="Bound">⊢V</a> <a id="21586" class="Symbol">(</a><a id="21587" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="21593" class="Symbol">{</a><a id="21594" class="Argument">x</a> <a id="21596" class="Symbol">=</a> <a id="21598" href="/PLFA-zh/Properties/#21598" class="Bound">x</a><a id="21599" class="Symbol">}</a> <a id="21601" href="/PLFA-zh/Properties/#21601" class="Bound">⊢L</a> <a id="21604" href="/PLFA-zh/Properties/#21604" class="Bound">⊢M</a> <a id="21607" href="/PLFA-zh/Properties/#21607" class="Bound">⊢N</a><a id="21609" class="Symbol">)</a> <a id="21611" class="Keyword">with</a> <a id="21616" href="/PLFA-zh/Properties/#21598" class="Bound">x</a> <a id="21618" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="21620" href="/PLFA-zh/Properties/#21580" class="Bound">y</a>
<a id="21622" class="Symbol">...</a> <a id="21626" class="Symbol">|</a> <a id="21628" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="21632" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>        <a id="21644" class="Symbol">=</a>  <a id="21647" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="21653" class="Symbol">(</a><a id="21654" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21660" class="Bound">⊢V</a> <a id="21663" class="Bound">⊢L</a><a id="21665" class="Symbol">)</a> <a id="21667" class="Symbol">(</a><a id="21668" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21674" class="Bound">⊢V</a> <a id="21677" class="Bound">⊢M</a><a id="21679" class="Symbol">)</a> <a id="21681" class="Symbol">(</a><a id="21682" href="/PLFA-zh/Properties/#18452" class="Function">drop</a> <a id="21687" class="Bound">⊢N</a><a id="21689" class="Symbol">)</a>
<a id="21691" class="Symbol">...</a> <a id="21695" class="Symbol">|</a> <a id="21697" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="21701" href="/PLFA-zh/Properties/#21701" class="Bound">x≢y</a>         <a id="21713" class="Symbol">=</a>  <a id="21716" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="21722" class="Symbol">(</a><a id="21723" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21729" class="Bound">⊢V</a> <a id="21732" class="Bound">⊢L</a><a id="21734" class="Symbol">)</a> <a id="21736" class="Symbol">(</a><a id="21737" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21743" class="Bound">⊢V</a> <a id="21746" class="Bound">⊢M</a><a id="21748" class="Symbol">)</a> <a id="21750" class="Symbol">(</a><a id="21751" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21757" class="Bound">⊢V</a> <a id="21760" class="Symbol">(</a><a id="21761" href="/PLFA-zh/Properties/#19311" class="Function">swap</a> <a id="21766" href="/PLFA-zh/Properties/#21701" class="Bound">x≢y</a> <a id="21770" class="Bound">⊢N</a><a id="21772" class="Symbol">))</a>
<a id="21775" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21781" class="Symbol">{</a><a id="21782" class="Argument">x</a> <a id="21784" class="Symbol">=</a> <a id="21786" href="/PLFA-zh/Properties/#21786" class="Bound">y</a><a id="21787" class="Symbol">}</a> <a id="21789" href="/PLFA-zh/Properties/#21789" class="Bound">⊢V</a> <a id="21792" class="Symbol">(</a><a id="21793" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="21796" class="Symbol">{</a><a id="21797" class="Argument">x</a> <a id="21799" class="Symbol">=</a> <a id="21801" href="/PLFA-zh/Properties/#21801" class="Bound">x</a><a id="21802" class="Symbol">}</a> <a id="21804" href="/PLFA-zh/Properties/#21804" class="Bound">⊢M</a><a id="21806" class="Symbol">)</a> <a id="21808" class="Keyword">with</a> <a id="21813" href="/PLFA-zh/Properties/#21801" class="Bound">x</a> <a id="21815" href="https://agda.github.io/agda-stdlib/Data.String.Unsafe.html#749" class="Function Operator">≟</a> <a id="21817" href="/PLFA-zh/Properties/#21786" class="Bound">y</a>
<a id="21819" class="Symbol">...</a> <a id="21823" class="Symbol">|</a> <a id="21825" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="21829" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>        <a id="21841" class="Symbol">=</a>  <a id="21844" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="21847" class="Symbol">(</a><a id="21848" href="/PLFA-zh/Properties/#18452" class="Function">drop</a> <a id="21853" class="Bound">⊢M</a><a id="21855" class="Symbol">)</a>
<a id="21857" class="Symbol">...</a> <a id="21861" class="Symbol">|</a> <a id="21863" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="21867" href="/PLFA-zh/Properties/#21867" class="Bound">x≢y</a>         <a id="21879" class="Symbol">=</a>  <a id="21882" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="21885" class="Symbol">(</a><a id="21886" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="21892" class="Bound">⊢V</a> <a id="21895" class="Symbol">(</a><a id="21896" href="/PLFA-zh/Properties/#19311" class="Function">swap</a> <a id="21901" href="/PLFA-zh/Properties/#21867" class="Bound">x≢y</a> <a id="21905" class="Bound">⊢M</a><a id="21907" class="Symbol">))</a></pre>
<p>We induct on the evidence that <code class="highlighter-rouge">N</code> is well-typed in the
context <code class="highlighter-rouge">Γ</code> extended by <code class="highlighter-rouge">x</code>.</p>

<p>First, we note a wee issue with naming.  In the lemma
statement, the variable <code class="highlighter-rouge">x</code> is an implicit parameter for the variable
substituted, while in the type rules for variables, abstractions,
cases, and fixpoints, the variable <code class="highlighter-rouge">x</code> is an implicit parameter for
the relevant variable.  We are going to need to get hold of both
variables, so we use the syntax <code class="highlighter-rouge">{x = y}</code> to bind <code class="highlighter-rouge">y</code> to the
substituted variable and the syntax <code class="highlighter-rouge">{x = x}</code> to bind <code class="highlighter-rouge">x</code> to the
relevant variable in the patterns for <code class="highlighter-rouge">⊢`</code>, <code class="highlighter-rouge">⊢ƛ</code>, <code class="highlighter-rouge">⊢case</code>, and <code class="highlighter-rouge">⊢μ</code>.
Using the name <code class="highlighter-rouge">y</code> here is consistent with the naming in the original
definition of substitution in the previous chapter.  The proof never
mentions the types of <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, <code class="highlighter-rouge">V</code>, or <code class="highlighter-rouge">N</code>, so in what follows we
choose type name as convenient.</p>

<p>Now that naming is resolved, let’s unpack the first three cases:</p>

<ul>
  <li>
    <p>In the variable case, we must show</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B ⊢ ` x ⦂ A
------------------------
Γ ⊢ ` x [ y := V ] ⦂ A
</code></pre></div>    </div>

    <p>where the second hypothesis follows from:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , y ⦂ B ∋ x ⦂ A
</code></pre></div>    </div>

    <p>There are two subcases, depending on the evidence for this judgment:</p>

    <ul>
      <li>
        <p>The lookup judgment is evidenced by rule <code class="highlighter-rouge">Z</code>:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----------------
Γ , x ⦂ A ⊢ x ⦂ A
</code></pre></div>        </div>

        <p>In this case, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are necessarily identical, as are <code class="highlighter-rouge">A</code>
and <code class="highlighter-rouge">B</code>.  Nonetheless, we must evaluate <code class="highlighter-rouge">x ≟ y</code> in order to allow
the definition of substitution to simplify:</p>

        <ul>
          <li>
            <p>If the variables are equal, then after simplification we
must show</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ A
---------
Γ ⊢ V ⦂ A
</code></pre></div>            </div>

            <p>which follows by weakening.</p>
          </li>
          <li>
            <p>If the variables are unequal we have a contradiction.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>The lookup judgment is evidenced by rule <code class="highlighter-rouge">S</code>:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x ≢ y
Γ ∋ x ⦂ A
-----------------
Γ , y ⦂ B ∋ x ⦂ A
</code></pre></div>        </div>

        <p>In this case, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are necessarily distinct.
Nonetheless, we must again evaluate <code class="highlighter-rouge">x ≟ y</code> in order to allow
the definition of substitution to simplify:</p>

        <ul>
          <li>
            <p>If the variables are equal we have a contradiction.</p>
          </li>
          <li>
            <p>If the variables are unequal, then after simplification we
must show</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
x ≢ y
Γ ∋ x ⦂ A
-------------
Γ ⊢ ` x ⦂ A
</code></pre></div>            </div>

            <p>which follows by the typing rule for variables.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>In the abstraction case, we must show</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B ⊢ (ƛ x ⇒ N) ⦂ A ⇒ C
--------------------------------
Γ ⊢ (ƛ x ⇒ N) [ y := V ] ⦂ A ⇒ C
</code></pre></div>    </div>

    <p>where the second hypothesis follows from</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C
</code></pre></div>    </div>

    <p>We evaluate <code class="highlighter-rouge">x ≟ y</code> in order to allow the definition of substitution to simplify:</p>

    <ul>
      <li>
        <p>If the variables are equal then after simplification we must show:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
Γ , x ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ C
</code></pre></div>        </div>

        <p>From the drop lemma, <code class="highlighter-rouge">drop</code>, we may conclude:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , x ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ , x ⦂ A ⊢ N ⦂ C
</code></pre></div>        </div>

        <p>The typing rule for abstractions then yields the required conclusion.</p>
      </li>
      <li>
        <p>If the variables are distinct then after simplification we must show:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C
--------------------------------
Γ ⊢ ƛ x ⇒ (N [ y := V ]) ⦂ A ⇒ C
</code></pre></div>        </div>

        <p>From the swap lemma we may conclude:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ , x ⦂ A , y ⦂ B ⊢ N ⦂ C
</code></pre></div>        </div>

        <p>The inductive hypothesis gives us:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ B
Γ , x ⦂ A , y ⦂ B ⊢ N ⦂ C        
------------------------------------
Γ , x ⦂ A , y ⦂ B ⊢ N [ y := V ] ⦂ C
</code></pre></div>        </div>

        <p>The typing rule for abstractions then yields the required conclusion.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>In the application case, we must show</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ C
Γ , y ⦂ C ⊢ L · M ⦂ B
--------------------------
Γ ⊢ (L · M) [ y := V ] ⦂ B
</code></pre></div>    </div>

    <p>where the second hypothesis follows from the two judgments</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , y ⦂ C ⊢ L ⦂ A ⇒ B
Γ , y ⦂ C ⊢ M ⦂ A
</code></pre></div>    </div>

    <p>By the definition of substitution, we must show:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∅ ⊢ V ⦂ C
Γ , y ⦂ C ⊢ L ⦂ A ⇒ B
Γ , y ⦂ C ⊢ M ⦂ A
---------------------------------------
Γ ⊢ (L [ y := V ]) · (M [ y := V ]) ⦂ B
</code></pre></div>    </div>

    <p>Applying the induction hypothesis for <code class="highlighter-rouge">L</code> and <code class="highlighter-rouge">M</code> and the typing
rule for applications yields the required conclusion.</p>
  </li>
</ul>

<p>The remaining cases are similar, using induction for each subterm.
Where the construct introduces a bound variable we need to compare it
with the substituted variable, applying the drop lemma if they are
equal and the swap lemma if they are distinct.</p>

<h4 id="exercise-subst-stretch">Exercise <code class="highlighter-rouge">subst′</code> (stretch)</h4>

<p>Rewrite <code class="highlighter-rouge">subst</code> to work with the modified definition <code class="highlighter-rouge">_[_:=_]′</code>
from the exercise in the previous chapter.  As before, this
should factor dealing with bound variables into a single function,
defined by mutual recursion with the proof that substitution
preserves types.</p>

<pre class="Agda"><a id="26795" class="Comment">-- Your code goes here</a></pre>

<h2 id="preservation">Preservation</h2>

<p>Once we have shown that substitution preserves types, showing
that reduction preserves types is straightforward:</p>

<pre class="Agda"><a id="preserve"></a><a id="26975" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="26984" class="Symbol">:</a> <a id="26986" class="Symbol">∀</a> <a id="26988" class="Symbol">{</a><a id="26989" href="/PLFA-zh/Properties/#26989" class="Bound">M</a> <a id="26991" href="/PLFA-zh/Properties/#26991" class="Bound">N</a> <a id="26993" href="/PLFA-zh/Properties/#26993" class="Bound">A</a><a id="26994" class="Symbol">}</a>
  <a id="26998" class="Symbol">→</a> <a id="27000" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="27002" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="27004" href="/PLFA-zh/Properties/#26989" class="Bound">M</a> <a id="27006" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="27008" href="/PLFA-zh/Properties/#26993" class="Bound">A</a>
  <a id="27012" class="Symbol">→</a> <a id="27014" href="/PLFA-zh/Properties/#26989" class="Bound">M</a> <a id="27016" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="27019" href="/PLFA-zh/Properties/#26991" class="Bound">N</a>
    <a id="27025" class="Comment">----------</a>
  <a id="27038" class="Symbol">→</a> <a id="27040" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="27042" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="27044" href="/PLFA-zh/Properties/#26991" class="Bound">N</a> <a id="27046" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="27048" href="/PLFA-zh/Properties/#26993" class="Bound">A</a>
<a id="27050" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27059" class="Symbol">(</a><a id="27060" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="27063" class="Symbol">())</a>
<a id="27067" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27076" class="Symbol">(</a><a id="27077" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="27080" href="/PLFA-zh/Properties/#27080" class="Bound">⊢N</a><a id="27082" class="Symbol">)</a>                 <a id="27100" class="Symbol">()</a>
<a id="27103" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27112" class="Symbol">(</a><a id="27113" href="/PLFA-zh/Properties/#27113" class="Bound">⊢L</a> <a id="27116" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="27118" href="/PLFA-zh/Properties/#27118" class="Bound">⊢M</a><a id="27120" class="Symbol">)</a>               <a id="27136" class="Symbol">(</a><a id="27137" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="27142" href="/PLFA-zh/Properties/#27142" class="Bound">L—→L′</a><a id="27147" class="Symbol">)</a>     <a id="27153" class="Symbol">=</a>  <a id="27156" class="Symbol">(</a><a id="27157" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27166" href="/PLFA-zh/Properties/#27113" class="Bound">⊢L</a> <a id="27169" href="/PLFA-zh/Properties/#27142" class="Bound">L—→L′</a><a id="27174" class="Symbol">)</a> <a id="27176" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="27178" href="/PLFA-zh/Properties/#27118" class="Bound">⊢M</a>
<a id="27181" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27190" class="Symbol">(</a><a id="27191" href="/PLFA-zh/Properties/#27191" class="Bound">⊢L</a> <a id="27194" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="27196" href="/PLFA-zh/Properties/#27196" class="Bound">⊢M</a><a id="27198" class="Symbol">)</a>               <a id="27214" class="Symbol">(</a><a id="27215" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="27220" href="/PLFA-zh/Properties/#27220" class="Bound">VL</a> <a id="27223" href="/PLFA-zh/Properties/#27223" class="Bound">M—→M′</a><a id="27228" class="Symbol">)</a>  <a id="27231" class="Symbol">=</a>  <a id="27234" href="/PLFA-zh/Properties/#27191" class="Bound">⊢L</a> <a id="27237" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="27239" class="Symbol">(</a><a id="27240" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27249" href="/PLFA-zh/Properties/#27196" class="Bound">⊢M</a> <a id="27252" href="/PLFA-zh/Properties/#27223" class="Bound">M—→M′</a><a id="27257" class="Symbol">)</a>
<a id="27259" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27268" class="Symbol">((</a><a id="27270" href="/PLFA-zh/Lambda/#32654" class="InductiveConstructor">⊢ƛ</a> <a id="27273" href="/PLFA-zh/Properties/#27273" class="Bound">⊢N</a><a id="27275" class="Symbol">)</a> <a id="27277" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="27279" href="/PLFA-zh/Properties/#27279" class="Bound">⊢V</a><a id="27281" class="Symbol">)</a>          <a id="27292" class="Symbol">(</a><a id="27293" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="27297" href="/PLFA-zh/Properties/#27297" class="Bound">VV</a><a id="27299" class="Symbol">)</a>         <a id="27309" class="Symbol">=</a>  <a id="27312" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="27318" href="/PLFA-zh/Properties/#27279" class="Bound">⊢V</a> <a id="27321" href="/PLFA-zh/Properties/#27273" class="Bound">⊢N</a>
<a id="27324" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27333" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a>                   <a id="27357" class="Symbol">()</a>
<a id="27360" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27369" class="Symbol">(</a><a id="27370" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="27375" href="/PLFA-zh/Properties/#27375" class="Bound">⊢M</a><a id="27377" class="Symbol">)</a>               <a id="27393" class="Symbol">(</a><a id="27394" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="27400" href="/PLFA-zh/Properties/#27400" class="Bound">M—→M′</a><a id="27405" class="Symbol">)</a>    <a id="27410" class="Symbol">=</a>  <a id="27413" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="27418" class="Symbol">(</a><a id="27419" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27428" href="/PLFA-zh/Properties/#27375" class="Bound">⊢M</a> <a id="27431" href="/PLFA-zh/Properties/#27400" class="Bound">M—→M′</a><a id="27436" class="Symbol">)</a>
<a id="27438" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27447" class="Symbol">(</a><a id="27448" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="27454" href="/PLFA-zh/Properties/#27454" class="Bound">⊢L</a> <a id="27457" href="/PLFA-zh/Properties/#27457" class="Bound">⊢M</a> <a id="27460" href="/PLFA-zh/Properties/#27460" class="Bound">⊢N</a><a id="27462" class="Symbol">)</a>        <a id="27471" class="Symbol">(</a><a id="27472" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="27479" href="/PLFA-zh/Properties/#27479" class="Bound">L—→L′</a><a id="27484" class="Symbol">)</a>   <a id="27488" class="Symbol">=</a>  <a id="27491" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="27497" class="Symbol">(</a><a id="27498" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27507" href="/PLFA-zh/Properties/#27454" class="Bound">⊢L</a> <a id="27510" href="/PLFA-zh/Properties/#27479" class="Bound">L—→L′</a><a id="27515" class="Symbol">)</a> <a id="27517" href="/PLFA-zh/Properties/#27457" class="Bound">⊢M</a> <a id="27520" href="/PLFA-zh/Properties/#27460" class="Bound">⊢N</a>
<a id="27523" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27532" class="Symbol">(</a><a id="27533" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="27539" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a> <a id="27545" href="/PLFA-zh/Properties/#27545" class="Bound">⊢M</a> <a id="27548" href="/PLFA-zh/Properties/#27548" class="Bound">⊢N</a><a id="27550" class="Symbol">)</a>     <a id="27556" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>           <a id="27573" class="Symbol">=</a>  <a id="27576" href="/PLFA-zh/Properties/#27545" class="Bound">⊢M</a>
<a id="27579" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27588" class="Symbol">(</a><a id="27589" href="/PLFA-zh/Lambda/#33027" class="InductiveConstructor">⊢case</a> <a id="27595" class="Symbol">(</a><a id="27596" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="27601" href="/PLFA-zh/Properties/#27601" class="Bound">⊢V</a><a id="27603" class="Symbol">)</a> <a id="27605" href="/PLFA-zh/Properties/#27605" class="Bound">⊢M</a> <a id="27608" href="/PLFA-zh/Properties/#27608" class="Bound">⊢N</a><a id="27610" class="Symbol">)</a> <a id="27612" class="Symbol">(</a><a id="27613" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="27619" href="/PLFA-zh/Properties/#27619" class="Bound">VV</a><a id="27621" class="Symbol">)</a>       <a id="27629" class="Symbol">=</a>  <a id="27632" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="27638" href="/PLFA-zh/Properties/#27601" class="Bound">⊢V</a> <a id="27641" href="/PLFA-zh/Properties/#27608" class="Bound">⊢N</a> 
<a id="27645" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="27654" class="Symbol">(</a><a id="27655" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="27658" href="/PLFA-zh/Properties/#27658" class="Bound">⊢M</a><a id="27660" class="Symbol">)</a>                 <a id="27678" class="Symbol">(</a><a id="27679" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="27682" class="Symbol">)</a>            <a id="27695" class="Symbol">=</a>  <a id="27698" href="/PLFA-zh/Properties/#20946" class="Function">subst</a> <a id="27704" class="Symbol">(</a><a id="27705" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="27708" href="/PLFA-zh/Properties/#27658" class="Bound">⊢M</a><a id="27710" class="Symbol">)</a> <a id="27712" href="/PLFA-zh/Properties/#27658" class="Bound">⊢M</a></pre>
<p>The proof never mentions the types of <code class="highlighter-rouge">M</code> or <code class="highlighter-rouge">N</code>,
so in what follows we choose type name as convenient.</p>

<p>Let’s unpack the cases for two of the reduction rules:</p>

<ul>
  <li>
    <p>Rule <code class="highlighter-rouge">ξ-·₁</code>.  We have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L —→ L′
----------------
L · M —→ L′ · M
</code></pre></div>    </div>

    <p>where the left-hand side is typed by</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ L ⦂ A ⇒ B
Γ ⊢ M ⦂ A
-------------
Γ ⊢ L · M ⦂ B
</code></pre></div>    </div>

    <p>By induction, we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ L ⦂ A ⇒ B
L —→ L′
--------------
Γ ⊢ L′ ⦂ A ⇒ B
</code></pre></div>    </div>

    <p>from which the typing of the right-hand side follows immediately.</p>
  </li>
  <li>
    <p>Rule <code class="highlighter-rouge">β-ƛ</code>.  We have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value V
----------------------------
(ƛ x ⇒ N) · V ⊢ N [ x := V ]
</code></pre></div>    </div>

    <p>where the left-hand side is typed by</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ , x ⦂ A ⊢ N ⦂ B
-------------------
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ B    Γ ⊢ V ⦂ A
--------------------------------
Γ ⊢ (ƛ x ⇒ N) · V ⦂ B
</code></pre></div>    </div>

    <p>By the substitution lemma, we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ V ⦂ A
Γ , x ⦂ A ⊢ N ⦂ B
--------------------
Γ ⊢ N [ x := V ] ⦂ B
</code></pre></div>    </div>

    <p>from which the typing of the right-hand side follows immediately.</p>
  </li>
</ul>

<p>The remaining cases are similar.  Each <code class="highlighter-rouge">ξ</code> rule follows by induction,
and each <code class="highlighter-rouge">β</code> rule follows by the substitution lemma.</p>

<h2 id="evaluation">Evaluation</h2>

<p>By repeated application of progress and preservation, we can evaluate
any well-typed term.  In this section, we will present an Agda
function that computes the reduction sequence from any given closed,
well-typed term to its value, if it has one.</p>

<p>Some terms may reduce forever.  Here is a simple example:</p>
<pre class="Agda"><a id="sucμ"></a><a id="29227" href="/PLFA-zh/Properties/#29227" class="Function">sucμ</a>  <a id="29233" class="Symbol">=</a>  <a id="29236" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="29238" class="String">&quot;x&quot;</a> <a id="29242" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="29244" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29249" class="Symbol">(</a><a id="29250" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="29252" class="String">&quot;x&quot;</a><a id="29255" class="Symbol">)</a>

<a id="29258" href="/PLFA-zh/Properties/#29258" class="Function">_</a> <a id="29260" class="Symbol">=</a>
  <a id="29264" href="/PLFA-zh/Lambda/#22010" class="Function Operator">begin</a>
    <a id="29274" href="/PLFA-zh/Properties/#29227" class="Function">sucμ</a>
  <a id="29281" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="29285" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a> <a id="29289" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="29295" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29300" href="/PLFA-zh/Properties/#29227" class="Function">sucμ</a>
  <a id="29307" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="29311" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="29317" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a> <a id="29321" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="29327" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29332" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29337" href="/PLFA-zh/Properties/#29227" class="Function">sucμ</a>
  <a id="29344" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="29348" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="29354" class="Symbol">(</a><a id="29355" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="29361" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="29364" class="Symbol">)</a> <a id="29366" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="29372" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29377" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29382" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="29387" href="/PLFA-zh/Properties/#29227" class="Function">sucμ</a>
  <a id="29394" class="Comment">--  ...</a>
  <a id="29404" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a></pre>
<p>Since every Agda computation must terminate,
we cannot simply ask Agda to reduce a term to a value.
Instead, we will provide a natural number to Agda, and permit it
to stop short of a value if the term requires more than the given
number of reduction steps.</p>

<p>A similar issue arises with cryptocurrencies.  Systems which use
smart contracts require the miners that maintain the blockchain to
evaluate the program which embodies the contract.  For instance,
validating a transaction on Ethereum may require executing a program
for the Ethereum Virtual Machine (EVM).  A long-running or
non-terminating program might cause the miner to invest arbitrary
effort in validating a contract for little or no return.  To avoid
this situation, each transaction is accompanied by an amount of <em>gas</em>
available for computation.  Each step executed on the EVM is charged
an advertised amount of gas, and the transaction pays for the gas at a
published rate: a given number of Ethers (the currency of Ethereum)
per unit of gas.</p>

<p>By analogy, we will use the name <em>gas</em> for the parameter which puts a
bound on the number of reduction steps.  <code class="highlighter-rouge">Gas</code> is specified by a natural number:</p>
<pre class="Agda"><a id="30594" class="Keyword">data</a> <a id="Gas"></a><a id="30599" href="/PLFA-zh/Properties/#30599" class="Datatype">Gas</a> <a id="30603" class="Symbol">:</a> <a id="30605" class="PrimitiveType">Set</a> <a id="30609" class="Keyword">where</a>
  <a id="Gas.gas"></a><a id="30617" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="30621" class="Symbol">:</a> <a id="30623" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="30625" class="Symbol">→</a> <a id="30627" href="/PLFA-zh/Properties/#30599" class="Datatype">Gas</a></pre>
<p>When our evaluator returns a term <code class="highlighter-rouge">N</code>, it will either give evidence that
<code class="highlighter-rouge">N</code> is a value or indicate that it ran out of gas:</p>
<pre class="Agda"><a id="30779" class="Keyword">data</a> <a id="Finished"></a><a id="30784" href="/PLFA-zh/Properties/#30784" class="Datatype">Finished</a> <a id="30793" class="Symbol">(</a><a id="30794" href="/PLFA-zh/Properties/#30794" class="Bound">N</a> <a id="30796" class="Symbol">:</a> <a id="30798" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a><a id="30802" class="Symbol">)</a> <a id="30804" class="Symbol">:</a> <a id="30806" class="PrimitiveType">Set</a> <a id="30810" class="Keyword">where</a>

  <a id="Finished.done"></a><a id="30819" href="/PLFA-zh/Properties/#30819" class="InductiveConstructor">done</a> <a id="30824" class="Symbol">:</a>
      <a id="30832" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="30838" href="/PLFA-zh/Properties/#30794" class="Bound">N</a>
      <a id="30846" class="Comment">----------</a>
    <a id="30861" class="Symbol">→</a> <a id="30863" href="/PLFA-zh/Properties/#30784" class="Datatype">Finished</a> <a id="30872" href="/PLFA-zh/Properties/#30794" class="Bound">N</a>

  <a id="Finished.out-of-gas"></a><a id="30877" href="/PLFA-zh/Properties/#30877" class="InductiveConstructor">out-of-gas</a> <a id="30888" class="Symbol">:</a>
      <a id="30896" class="Comment">----------</a>
      <a id="30913" href="/PLFA-zh/Properties/#30784" class="Datatype">Finished</a> <a id="30922" href="/PLFA-zh/Properties/#30794" class="Bound">N</a></pre>
<p>Given a term <code class="highlighter-rouge">L</code> of type <code class="highlighter-rouge">A</code>, the evaluator will, for some <code class="highlighter-rouge">N</code>, return
a reduction sequence from <code class="highlighter-rouge">L</code> to <code class="highlighter-rouge">N</code> and an indication of whether
reduction finished:</p>
<pre class="Agda"><a id="31105" class="Keyword">data</a> <a id="Steps"></a><a id="31110" href="/PLFA-zh/Properties/#31110" class="Datatype">Steps</a> <a id="31116" class="Symbol">(</a><a id="31117" href="/PLFA-zh/Properties/#31117" class="Bound">L</a> <a id="31119" class="Symbol">:</a> <a id="31121" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a><a id="31125" class="Symbol">)</a> <a id="31127" class="Symbol">:</a> <a id="31129" class="PrimitiveType">Set</a> <a id="31133" class="Keyword">where</a>

  <a id="Steps.steps"></a><a id="31142" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a> <a id="31148" class="Symbol">:</a> <a id="31150" class="Symbol">∀</a> <a id="31152" class="Symbol">{</a><a id="31153" href="/PLFA-zh/Properties/#31153" class="Bound">N</a><a id="31154" class="Symbol">}</a>
    <a id="31160" class="Symbol">→</a> <a id="31162" href="/PLFA-zh/Properties/#31117" class="Bound">L</a> <a id="31164" href="/PLFA-zh/Lambda/#21860" class="Datatype Operator">—↠</a> <a id="31167" href="/PLFA-zh/Properties/#31153" class="Bound">N</a>  
    <a id="31175" class="Symbol">→</a> <a id="31177" href="/PLFA-zh/Properties/#30784" class="Datatype">Finished</a> <a id="31186" href="/PLFA-zh/Properties/#31153" class="Bound">N</a>
      <a id="31194" class="Comment">----------</a>
    <a id="31209" class="Symbol">→</a> <a id="31211" href="/PLFA-zh/Properties/#31110" class="Datatype">Steps</a> <a id="31217" href="/PLFA-zh/Properties/#31117" class="Bound">L</a></pre>
<p>The evaluator takes gas and evidence that a term is well-typed,
and returns the corresponding steps:</p>
<pre class="Agda"><a id="eval"></a><a id="31344" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="31349" class="Symbol">:</a> <a id="31351" class="Symbol">∀</a> <a id="31353" class="Symbol">{</a><a id="31354" href="/PLFA-zh/Properties/#31354" class="Bound">L</a> <a id="31356" href="/PLFA-zh/Properties/#31356" class="Bound">A</a><a id="31357" class="Symbol">}</a>
  <a id="31361" class="Symbol">→</a> <a id="31363" href="/PLFA-zh/Properties/#30599" class="Datatype">Gas</a>
  <a id="31369" class="Symbol">→</a> <a id="31371" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="31373" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="31375" href="/PLFA-zh/Properties/#31354" class="Bound">L</a> <a id="31377" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="31379" href="/PLFA-zh/Properties/#31356" class="Bound">A</a>
    <a id="31385" class="Comment">---------</a>
  <a id="31397" class="Symbol">→</a> <a id="31399" href="/PLFA-zh/Properties/#31110" class="Datatype">Steps</a> <a id="31405" href="/PLFA-zh/Properties/#31354" class="Bound">L</a>
<a id="31407" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="31412" class="Symbol">{</a><a id="31413" href="/PLFA-zh/Properties/#31413" class="Bound">L</a><a id="31414" class="Symbol">}</a> <a id="31416" class="Symbol">(</a><a id="31417" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="31421" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="31425" class="Symbol">)</a>    <a id="31430" href="/PLFA-zh/Properties/#31430" class="Bound">⊢L</a>                             <a id="31461" class="Symbol">=</a>  <a id="31464" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a> <a id="31470" class="Symbol">(</a><a id="31471" href="/PLFA-zh/Properties/#31413" class="Bound">L</a> <a id="31473" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="31474" class="Symbol">)</a> <a id="31476" href="/PLFA-zh/Properties/#30877" class="InductiveConstructor">out-of-gas</a>
<a id="31487" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="31492" class="Symbol">{</a><a id="31493" href="/PLFA-zh/Properties/#31493" class="Bound">L</a><a id="31494" class="Symbol">}</a> <a id="31496" class="Symbol">(</a><a id="31497" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="31501" class="Symbol">(</a><a id="31502" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="31506" href="/PLFA-zh/Properties/#31506" class="Bound">m</a><a id="31507" class="Symbol">))</a> <a id="31510" href="/PLFA-zh/Properties/#31510" class="Bound">⊢L</a> <a id="31513" class="Keyword">with</a> <a id="31518" href="/PLFA-zh/Properties/#7915" class="Function">progress</a> <a id="31527" href="/PLFA-zh/Properties/#31510" class="Bound">⊢L</a>
<a id="31530" class="Symbol">...</a> <a id="31534" class="Symbol">|</a> <a id="31536" href="/PLFA-zh/Properties/#7607" class="InductiveConstructor">done</a> <a id="31541" href="/PLFA-zh/Properties/#31541" class="Bound">VL</a>                                         <a id="31584" class="Symbol">=</a>  <a id="31587" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a> <a id="31593" class="Symbol">(</a><a id="31594" class="Bound">L</a> <a id="31596" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="31597" class="Symbol">)</a> <a id="31599" class="Symbol">(</a><a id="31600" href="/PLFA-zh/Properties/#30819" class="InductiveConstructor">done</a> <a id="31605" href="/PLFA-zh/Properties/#31541" class="Bound">VL</a><a id="31607" class="Symbol">)</a>
<a id="31609" class="Symbol">...</a> <a id="31613" class="Symbol">|</a> <a id="31615" href="/PLFA-zh/Properties/#7544" class="InductiveConstructor">step</a> <a id="31620" href="/PLFA-zh/Properties/#31620" class="Bound">L—→M</a> <a id="31625" class="Keyword">with</a> <a id="31630" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="31635" class="Symbol">(</a><a id="31636" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="31640" class="Bound">m</a><a id="31641" class="Symbol">)</a> <a id="31643" class="Symbol">(</a><a id="31644" href="/PLFA-zh/Properties/#26975" class="Function">preserve</a> <a id="31653" class="Bound">⊢L</a> <a id="31656" href="/PLFA-zh/Properties/#31620" class="Bound">L—→M</a><a id="31660" class="Symbol">)</a>
<a id="31662" class="Symbol">...</a>    <a id="31669" class="Symbol">|</a> <a id="31671" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a> <a id="31677" href="/PLFA-zh/Properties/#31677" class="Bound">M—↠N</a> <a id="31682" href="/PLFA-zh/Properties/#31682" class="Bound">fin</a>                               <a id="31716" class="Symbol">=</a>  <a id="31719" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a> <a id="31725" class="Symbol">(</a><a id="31726" class="Bound">L</a> <a id="31728" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="31732" class="Bound">L—→M</a> <a id="31737" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a> <a id="31739" href="/PLFA-zh/Properties/#31677" class="Bound">M—↠N</a><a id="31743" class="Symbol">)</a> <a id="31745" href="/PLFA-zh/Properties/#31682" class="Bound">fin</a></pre>
<p>Let <code class="highlighter-rouge">L</code> be the name of the term we are reducing, and <code class="highlighter-rouge">⊢L</code> be the
evidence that <code class="highlighter-rouge">L</code> is well-typed.  We consider the amount of gas
remaining.  There are two possibilities:</p>

<ul>
  <li>
    <p>It is zero, so we stop early.  We return the trivial reduction
sequence <code class="highlighter-rouge">L —↠ L</code>, evidence that <code class="highlighter-rouge">L</code> is well-typed, and an
indication that we are out of gas.</p>
  </li>
  <li>
    <p>It is non-zero and after the next step we have <code class="highlighter-rouge">m</code> gas remaining.
Apply progress to the evidence that term <code class="highlighter-rouge">L</code> is well-typed.  There
are two possibilities:</p>

    <ul>
      <li>
        <p>Term <code class="highlighter-rouge">L</code> is a value, so we are done. We return the
trivial reduction sequence <code class="highlighter-rouge">L —↠ L</code>, evidence that <code class="highlighter-rouge">L</code> is
well-typed, and the evidence that <code class="highlighter-rouge">L</code> is a value.</p>
      </li>
      <li>
        <p>Term <code class="highlighter-rouge">L</code> steps to another term <code class="highlighter-rouge">M</code>.  Preservation provides
evidence that <code class="highlighter-rouge">M</code> is also well-typed, and we recursively invoke
<code class="highlighter-rouge">eval</code> on the remaining gas.  The result is evidence that
<code class="highlighter-rouge">M —↠ N</code>, together with evidence that <code class="highlighter-rouge">N</code> is well-typed and an
indication of whether reduction finished.  We combine the evidence
that <code class="highlighter-rouge">L —→ M</code> and <code class="highlighter-rouge">M —↠ N</code> to return evidence that <code class="highlighter-rouge">L —↠ N</code>,
together with the other relevant evidence.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="examples">Examples</h3>

<p>We can now use Agda to compute the non-terminating reduction
sequence given earlier.  First, we show that the term <code class="highlighter-rouge">sucμ</code>
is well-typed:</p>
<pre class="Agda"><a id="⊢sucμ"></a><a id="33041" href="/PLFA-zh/Properties/#33041" class="Function">⊢sucμ</a> <a id="33047" class="Symbol">:</a> <a id="33049" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="33051" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="33053" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="33055" class="String">&quot;x&quot;</a> <a id="33059" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="33061" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33066" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33068" class="String">&quot;x&quot;</a> <a id="33072" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="33074" href="/PLFA-zh/Lambda/#28731" class="InductiveConstructor">`ℕ</a>
<a id="33077" href="/PLFA-zh/Properties/#33041" class="Function">⊢sucμ</a> <a id="33083" class="Symbol">=</a> <a id="33085" href="/PLFA-zh/Lambda/#33199" class="InductiveConstructor">⊢μ</a> <a id="33088" class="Symbol">(</a><a id="33089" href="/PLFA-zh/Lambda/#32939" class="InductiveConstructor">⊢suc</a> <a id="33094" class="Symbol">(</a><a id="33095" href="/PLFA-zh/Lambda/#32572" class="InductiveConstructor">⊢`</a> <a id="33098" href="/PLFA-zh/Properties/#33113" class="Function">∋x</a><a id="33100" class="Symbol">))</a>
  <a id="33105" class="Keyword">where</a>
  <a id="33113" href="/PLFA-zh/Properties/#33113" class="Function">∋x</a> <a id="33116" class="Symbol">=</a> <a id="33118" href="/PLFA-zh/Lambda/#31378" class="InductiveConstructor">Z</a></pre>
<p>To show the first three steps of the infinite reduction
sequence, we evaluate with three steps worth of gas:</p>
<pre class="Agda"><a id="33253" href="/PLFA-zh/Properties/#33253" class="Function">_</a> <a id="33255" class="Symbol">:</a> <a id="33257" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="33262" class="Symbol">(</a><a id="33263" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="33267" class="Number">3</a><a id="33268" class="Symbol">)</a> <a id="33270" href="/PLFA-zh/Properties/#33041" class="Function">⊢sucμ</a> <a id="33276" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a>
  <a id="33280" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a>
   <a id="33289" class="Symbol">(</a><a id="33290" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="33292" class="String">&quot;x&quot;</a> <a id="33296" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="33298" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33303" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33305" class="String">&quot;x&quot;</a>
   <a id="33312" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="33316" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a> <a id="33320" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="33326" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33331" class="Symbol">(</a><a id="33332" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="33334" class="String">&quot;x&quot;</a> <a id="33338" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="33340" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33345" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33347" class="String">&quot;x&quot;</a><a id="33350" class="Symbol">)</a>
   <a id="33355" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="33359" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="33365" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a> <a id="33369" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="33375" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33380" class="Symbol">(</a><a id="33381" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33386" class="Symbol">(</a><a id="33387" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="33389" class="String">&quot;x&quot;</a> <a id="33393" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="33395" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33400" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33402" class="String">&quot;x&quot;</a><a id="33405" class="Symbol">))</a>
   <a id="33411" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="33415" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="33421" class="Symbol">(</a><a id="33422" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="33428" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="33431" class="Symbol">)</a> <a id="33433" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="33439" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33444" class="Symbol">(</a><a id="33445" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33450" class="Symbol">(</a><a id="33451" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33456" class="Symbol">(</a><a id="33457" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="33459" class="String">&quot;x&quot;</a> <a id="33463" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a> <a id="33465" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33470" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33472" class="String">&quot;x&quot;</a><a id="33475" class="Symbol">)))</a>
   <a id="33482" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="33483" class="Symbol">)</a>
   <a id="33488" href="/PLFA-zh/Properties/#30877" class="InductiveConstructor">out-of-gas</a>
<a id="33499" class="Symbol">_</a> <a id="33501" class="Symbol">=</a> <a id="33503" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>Similarly, we can use Agda to compute the reductions sequences given
in the previous chapter.  We start with the Church numeral two
applied to successor and zero.  Supplying 100 steps of gas is more than enough:</p>
<pre class="Agda"><a id="33745" href="/PLFA-zh/Properties/#33745" class="Function">_</a> <a id="33747" class="Symbol">:</a> <a id="33749" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="33754" class="Symbol">(</a><a id="33755" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="33759" class="Number">100</a><a id="33762" class="Symbol">)</a> <a id="33764" class="Symbol">(</a><a id="33765" href="/PLFA-zh/Lambda/#36591" class="Function">⊢twoᶜ</a> <a id="33771" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="33773" href="/PLFA-zh/Lambda/#38087" class="Function">⊢sucᶜ</a> <a id="33779" href="/PLFA-zh/Lambda/#32761" class="InductiveConstructor Operator">·</a> <a id="33781" href="/PLFA-zh/Lambda/#32870" class="InductiveConstructor">⊢zero</a><a id="33786" class="Symbol">)</a> <a id="33788" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a>
  <a id="33792" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a>
   <a id="33801" class="Symbol">((</a><a id="33803" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33805" class="String">&quot;s&quot;</a> <a id="33809" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33811" class="Symbol">(</a><a id="33812" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33814" class="String">&quot;z&quot;</a> <a id="33818" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33820" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33822" class="String">&quot;s&quot;</a> <a id="33826" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33828" class="Symbol">(</a><a id="33829" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33831" class="String">&quot;s&quot;</a> <a id="33835" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33837" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33839" class="String">&quot;z&quot;</a><a id="33842" class="Symbol">)))</a> <a id="33846" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33848" class="Symbol">(</a><a id="33849" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33851" class="String">&quot;n&quot;</a> <a id="33855" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33857" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33862" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33864" class="String">&quot;n&quot;</a><a id="33867" class="Symbol">)</a>
   <a id="33872" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33874" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="33883" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="33887" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="33892" class="Symbol">(</a><a id="33893" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="33897" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="33900" class="Symbol">)</a> <a id="33902" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="33908" class="Symbol">(</a><a id="33909" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33911" class="String">&quot;z&quot;</a> <a id="33915" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33917" class="Symbol">(</a><a id="33918" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33920" class="String">&quot;n&quot;</a> <a id="33924" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33926" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33931" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33933" class="String">&quot;n&quot;</a><a id="33936" class="Symbol">)</a> <a id="33938" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33940" class="Symbol">((</a><a id="33942" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="33944" class="String">&quot;n&quot;</a> <a id="33948" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="33950" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="33955" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33957" class="String">&quot;n&quot;</a><a id="33960" class="Symbol">)</a> <a id="33962" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="33964" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="33966" class="String">&quot;z&quot;</a><a id="33969" class="Symbol">))</a> <a id="33972" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
     <a id="33979" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="33988" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="33992" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="33996" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a> <a id="34003" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="34009" class="Symbol">(</a><a id="34010" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34012" class="String">&quot;n&quot;</a> <a id="34016" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="34018" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34023" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34025" class="String">&quot;n&quot;</a><a id="34028" class="Symbol">)</a> <a id="34030" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34032" class="Symbol">((</a><a id="34034" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34036" class="String">&quot;n&quot;</a> <a id="34040" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="34042" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34047" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34049" class="String">&quot;n&quot;</a><a id="34052" class="Symbol">)</a> <a id="34054" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34056" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="34061" class="Symbol">)</a>
   <a id="34066" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="34070" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="34075" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="34079" class="Symbol">(</a><a id="34080" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="34084" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="34090" class="Symbol">)</a> <a id="34092" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="34098" class="Symbol">(</a><a id="34099" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34101" class="String">&quot;n&quot;</a> <a id="34105" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="34107" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34112" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34114" class="String">&quot;n&quot;</a><a id="34117" class="Symbol">)</a> <a id="34119" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34121" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34126" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="34135" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="34139" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="34143" class="Symbol">(</a><a id="34144" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="34150" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="34156" class="Symbol">)</a> <a id="34158" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="34164" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34169" class="Symbol">(</a><a id="34170" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34175" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="34180" class="Symbol">)</a>
   <a id="34185" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="34186" class="Symbol">)</a>
   <a id="34191" class="Symbol">(</a><a id="34192" href="/PLFA-zh/Properties/#30819" class="InductiveConstructor">done</a> <a id="34197" class="Symbol">(</a><a id="34198" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="34204" class="Symbol">(</a><a id="34205" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="34211" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="34217" class="Symbol">)))</a>
<a id="34221" class="Symbol">_</a> <a id="34223" class="Symbol">=</a> <a id="34225" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The example above was generated by using <code class="highlighter-rouge">C-c C-n</code> to normalise the
left-hand side of the equation and pasting in the result as the
right-hand side of the equation.  The example reduction of the
previous chapter was derived from this result, reformatting and
writing <code class="highlighter-rouge">twoᶜ</code> and <code class="highlighter-rouge">sucᶜ</code> in place of their expansions.</p>

<p>Next, we show two plus two is four:</p>
<pre class="Agda"><a id="34606" href="/PLFA-zh/Properties/#34606" class="Function">_</a> <a id="34608" class="Symbol">:</a> <a id="34610" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="34615" class="Symbol">(</a><a id="34616" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="34620" class="Number">100</a><a id="34623" class="Symbol">)</a> <a id="34625" href="/PLFA-zh/Lambda/#37114" class="Function">⊢2+2</a> <a id="34630" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a>
  <a id="34634" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a>
   <a id="34643" class="Symbol">((</a><a id="34645" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="34647" class="String">&quot;+&quot;</a> <a id="34651" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
     <a id="34658" class="Symbol">(</a><a id="34659" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34661" class="String">&quot;m&quot;</a> <a id="34665" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="34673" class="Symbol">(</a><a id="34674" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34676" class="String">&quot;n&quot;</a> <a id="34680" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="34689" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="34694" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34696" class="String">&quot;m&quot;</a> <a id="34700" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="34707" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34709" class="String">&quot;n&quot;</a> <a id="34713" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="34718" class="String">&quot;m&quot;</a> <a id="34722" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="34724" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34729" class="Symbol">(</a><a id="34730" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34732" class="String">&quot;+&quot;</a> <a id="34736" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34738" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34740" class="String">&quot;m&quot;</a> <a id="34744" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34746" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34748" class="String">&quot;n&quot;</a><a id="34751" class="Symbol">)</a>
       <a id="34760" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="34761" class="Symbol">)))</a>
    <a id="34769" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34771" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34776" class="Symbol">(</a><a id="34777" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34782" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="34787" class="Symbol">)</a>
    <a id="34793" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="34795" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34800" class="Symbol">(</a><a id="34801" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="34806" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="34811" class="Symbol">)</a>
   <a id="34816" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="34820" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="34825" class="Symbol">(</a><a id="34826" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="34831" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="34834" class="Symbol">)</a> <a id="34836" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="34842" class="Symbol">(</a><a id="34843" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34845" class="String">&quot;m&quot;</a> <a id="34849" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="34856" class="Symbol">(</a><a id="34857" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34859" class="String">&quot;n&quot;</a> <a id="34863" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="34871" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="34876" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34878" class="String">&quot;m&quot;</a> <a id="34882" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="34889" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34891" class="String">&quot;n&quot;</a> <a id="34895" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="34900" class="String">&quot;m&quot;</a> <a id="34904" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
      <a id="34912" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
      <a id="34923" class="Symbol">((</a><a id="34925" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="34927" class="String">&quot;+&quot;</a> <a id="34931" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
        <a id="34941" class="Symbol">(</a><a id="34942" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34944" class="String">&quot;m&quot;</a> <a id="34948" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
         <a id="34959" class="Symbol">(</a><a id="34960" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="34962" class="String">&quot;n&quot;</a> <a id="34966" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
          <a id="34978" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="34983" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34985" class="String">&quot;m&quot;</a> <a id="34989" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="34996" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="34998" class="String">&quot;n&quot;</a> <a id="35002" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35007" class="String">&quot;m&quot;</a> <a id="35011" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="35013" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35018" class="Symbol">(</a><a id="35019" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35021" class="String">&quot;+&quot;</a> <a id="35025" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35027" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35029" class="String">&quot;m&quot;</a> <a id="35033" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35035" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35037" class="String">&quot;n&quot;</a><a id="35040" class="Symbol">)</a>
          <a id="35052" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35053" class="Symbol">)))</a>
       <a id="35064" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35066" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35068" class="String">&quot;m&quot;</a>
       <a id="35079" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35081" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35083" class="String">&quot;n&quot;</a><a id="35086" class="Symbol">)</a>
      <a id="35094" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35095" class="Symbol">))</a>
    <a id="35102" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35104" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35109" class="Symbol">(</a><a id="35110" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35115" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35120" class="Symbol">)</a>
    <a id="35126" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35128" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35133" class="Symbol">(</a><a id="35134" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35139" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35144" class="Symbol">)</a>
   <a id="35149" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="35153" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="35158" class="Symbol">(</a><a id="35159" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="35163" class="Symbol">(</a><a id="35164" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="35170" class="Symbol">(</a><a id="35171" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="35177" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="35183" class="Symbol">)))</a> <a id="35187" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="35193" class="Symbol">(</a><a id="35194" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35196" class="String">&quot;n&quot;</a> <a id="35200" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="35207" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="35212" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35217" class="Symbol">(</a><a id="35218" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35223" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35228" class="Symbol">)</a> <a id="35230" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="35237" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35239" class="String">&quot;n&quot;</a> <a id="35243" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35248" class="String">&quot;m&quot;</a> <a id="35252" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
     <a id="35259" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="35269" class="Symbol">((</a><a id="35271" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="35273" class="String">&quot;+&quot;</a> <a id="35277" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
       <a id="35286" class="Symbol">(</a><a id="35287" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35289" class="String">&quot;m&quot;</a> <a id="35293" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="35303" class="Symbol">(</a><a id="35304" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35306" class="String">&quot;n&quot;</a> <a id="35310" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
         <a id="35321" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="35326" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35328" class="String">&quot;m&quot;</a> <a id="35332" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="35339" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35341" class="String">&quot;n&quot;</a> <a id="35345" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35350" class="String">&quot;m&quot;</a> <a id="35354" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="35356" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35361" class="Symbol">(</a><a id="35362" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35364" class="String">&quot;+&quot;</a> <a id="35368" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35370" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35372" class="String">&quot;m&quot;</a> <a id="35376" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35378" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35380" class="String">&quot;n&quot;</a><a id="35383" class="Symbol">)</a>
         <a id="35394" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35395" class="Symbol">)))</a>
      <a id="35405" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35407" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35409" class="String">&quot;m&quot;</a>
      <a id="35419" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35421" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35423" class="String">&quot;n&quot;</a><a id="35426" class="Symbol">)</a>
     <a id="35433" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35434" class="Symbol">)</a>
    <a id="35440" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35442" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35447" class="Symbol">(</a><a id="35448" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35453" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35458" class="Symbol">)</a>
   <a id="35463" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="35467" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="35471" class="Symbol">(</a><a id="35472" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="35478" class="Symbol">(</a><a id="35479" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="35485" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="35491" class="Symbol">))</a> <a id="35494" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="35500" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="35505" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35510" class="Symbol">(</a><a id="35511" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35516" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35521" class="Symbol">)</a> <a id="35523" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="35530" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35535" class="Symbol">(</a><a id="35536" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35541" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35546" class="Symbol">)</a> <a id="35548" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35553" class="String">&quot;m&quot;</a> <a id="35557" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
    <a id="35563" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="35572" class="Symbol">((</a><a id="35574" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="35576" class="String">&quot;+&quot;</a> <a id="35580" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
      <a id="35588" class="Symbol">(</a><a id="35589" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35591" class="String">&quot;m&quot;</a> <a id="35595" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="35604" class="Symbol">(</a><a id="35605" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35607" class="String">&quot;n&quot;</a> <a id="35611" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="35621" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="35626" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35628" class="String">&quot;m&quot;</a> <a id="35632" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="35639" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35641" class="String">&quot;n&quot;</a> <a id="35645" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35650" class="String">&quot;m&quot;</a> <a id="35654" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="35656" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35661" class="Symbol">(</a><a id="35662" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35664" class="String">&quot;+&quot;</a> <a id="35668" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35670" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35672" class="String">&quot;m&quot;</a> <a id="35676" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35678" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35680" class="String">&quot;n&quot;</a><a id="35683" class="Symbol">)</a>
        <a id="35693" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35694" class="Symbol">)))</a>
     <a id="35703" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35705" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35707" class="String">&quot;m&quot;</a>
     <a id="35716" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35718" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35723" class="Symbol">(</a><a id="35724" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35729" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35734" class="Symbol">))</a>
    <a id="35741" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a>
   <a id="35746" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="35750" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="35756" class="Symbol">(</a><a id="35757" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="35763" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="35769" class="Symbol">)</a> <a id="35771" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="35777" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="35786" class="Symbol">((</a><a id="35788" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="35790" class="String">&quot;+&quot;</a> <a id="35794" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
      <a id="35802" class="Symbol">(</a><a id="35803" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35805" class="String">&quot;m&quot;</a> <a id="35809" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="35818" class="Symbol">(</a><a id="35819" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="35821" class="String">&quot;n&quot;</a> <a id="35825" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="35835" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="35840" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35842" class="String">&quot;m&quot;</a> <a id="35846" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="35853" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35855" class="String">&quot;n&quot;</a> <a id="35859" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="35864" class="String">&quot;m&quot;</a> <a id="35868" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="35870" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35875" class="Symbol">(</a><a id="35876" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35878" class="String">&quot;+&quot;</a> <a id="35882" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35884" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35886" class="String">&quot;m&quot;</a> <a id="35890" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35892" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="35894" class="String">&quot;n&quot;</a><a id="35897" class="Symbol">)</a>
        <a id="35907" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="35908" class="Symbol">)))</a>
     <a id="35917" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35919" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35924" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
     <a id="35935" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="35937" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35942" class="Symbol">(</a><a id="35943" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="35948" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="35953" class="Symbol">))</a>
   <a id="35959" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="35963" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="35969" class="Symbol">(</a><a id="35970" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="35975" class="Symbol">(</a><a id="35976" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="35981" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="35984" class="Symbol">))</a> <a id="35987" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="35993" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="36002" class="Symbol">((</a><a id="36004" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36006" class="String">&quot;m&quot;</a> <a id="36010" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="36018" class="Symbol">(</a><a id="36019" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36021" class="String">&quot;n&quot;</a> <a id="36025" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="36034" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36039" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36041" class="String">&quot;m&quot;</a> <a id="36045" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36052" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36054" class="String">&quot;n&quot;</a> <a id="36058" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36063" class="String">&quot;m&quot;</a> <a id="36067" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
       <a id="36076" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
       <a id="36088" class="Symbol">((</a><a id="36090" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="36092" class="String">&quot;+&quot;</a> <a id="36096" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
         <a id="36107" class="Symbol">(</a><a id="36108" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36110" class="String">&quot;m&quot;</a> <a id="36114" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
          <a id="36126" class="Symbol">(</a><a id="36127" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36129" class="String">&quot;n&quot;</a> <a id="36133" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
           <a id="36146" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36151" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36153" class="String">&quot;m&quot;</a> <a id="36157" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36164" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36166" class="String">&quot;n&quot;</a> <a id="36170" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36175" class="String">&quot;m&quot;</a> <a id="36179" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="36181" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36186" class="Symbol">(</a><a id="36187" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36189" class="String">&quot;+&quot;</a> <a id="36193" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36195" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36197" class="String">&quot;m&quot;</a> <a id="36201" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36203" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36205" class="String">&quot;n&quot;</a><a id="36208" class="Symbol">)</a>
           <a id="36221" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="36222" class="Symbol">)))</a>
        <a id="36234" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36236" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36238" class="String">&quot;m&quot;</a>
        <a id="36250" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36252" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36254" class="String">&quot;n&quot;</a><a id="36257" class="Symbol">)</a>
       <a id="36266" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="36267" class="Symbol">))</a>
     <a id="36275" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36277" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36282" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
     <a id="36293" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36295" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36300" class="Symbol">(</a><a id="36301" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36306" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="36311" class="Symbol">))</a>
   <a id="36317" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="36321" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="36327" class="Symbol">(</a><a id="36328" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="36333" class="Symbol">(</a><a id="36334" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="36338" class="Symbol">(</a><a id="36339" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="36345" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="36351" class="Symbol">)))</a> <a id="36355" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="36361" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="36370" class="Symbol">((</a><a id="36372" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36374" class="String">&quot;n&quot;</a> <a id="36378" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="36386" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36391" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36396" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a> <a id="36402" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36409" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36411" class="String">&quot;n&quot;</a> <a id="36415" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36420" class="String">&quot;m&quot;</a> <a id="36424" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
      <a id="36432" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
      <a id="36443" class="Symbol">((</a><a id="36445" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="36447" class="String">&quot;+&quot;</a> <a id="36451" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
        <a id="36461" class="Symbol">(</a><a id="36462" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36464" class="String">&quot;m&quot;</a> <a id="36468" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
         <a id="36479" class="Symbol">(</a><a id="36480" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36482" class="String">&quot;n&quot;</a> <a id="36486" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
          <a id="36498" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36503" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36505" class="String">&quot;m&quot;</a> <a id="36509" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36516" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36518" class="String">&quot;n&quot;</a> <a id="36522" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36527" class="String">&quot;m&quot;</a> <a id="36531" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="36533" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36538" class="Symbol">(</a><a id="36539" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36541" class="String">&quot;+&quot;</a> <a id="36545" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36547" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36549" class="String">&quot;m&quot;</a> <a id="36553" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36555" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36557" class="String">&quot;n&quot;</a><a id="36560" class="Symbol">)</a>
          <a id="36572" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="36573" class="Symbol">)))</a>
       <a id="36584" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36586" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36588" class="String">&quot;m&quot;</a>
       <a id="36599" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36601" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36603" class="String">&quot;n&quot;</a><a id="36606" class="Symbol">)</a>
      <a id="36614" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="36615" class="Symbol">)</a>
     <a id="36622" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36624" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36629" class="Symbol">(</a><a id="36630" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36635" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="36640" class="Symbol">))</a>
   <a id="36646" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="36650" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="36656" class="Symbol">(</a><a id="36657" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="36661" class="Symbol">(</a><a id="36662" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="36668" class="Symbol">(</a><a id="36669" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="36675" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="36681" class="Symbol">)))</a> <a id="36685" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="36691" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="36700" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36705" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36710" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a> <a id="36716" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36723" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36728" class="Symbol">(</a><a id="36729" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36734" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="36739" class="Symbol">)</a> <a id="36741" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36746" class="String">&quot;m&quot;</a> <a id="36750" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
    <a id="36756" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="36765" class="Symbol">((</a><a id="36767" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="36769" class="String">&quot;+&quot;</a> <a id="36773" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
      <a id="36781" class="Symbol">(</a><a id="36782" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36784" class="String">&quot;m&quot;</a> <a id="36788" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="36797" class="Symbol">(</a><a id="36798" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="36800" class="String">&quot;n&quot;</a> <a id="36804" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="36814" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="36819" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36821" class="String">&quot;m&quot;</a> <a id="36825" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="36832" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36834" class="String">&quot;n&quot;</a> <a id="36838" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="36843" class="String">&quot;m&quot;</a> <a id="36847" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="36849" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36854" class="Symbol">(</a><a id="36855" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36857" class="String">&quot;+&quot;</a> <a id="36861" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36863" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36865" class="String">&quot;m&quot;</a> <a id="36869" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36871" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36873" class="String">&quot;n&quot;</a><a id="36876" class="Symbol">)</a>
        <a id="36886" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="36887" class="Symbol">)))</a>
     <a id="36896" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36898" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="36900" class="String">&quot;m&quot;</a>
     <a id="36909" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="36911" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36916" class="Symbol">(</a><a id="36917" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="36922" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="36927" class="Symbol">))</a>
    <a id="36934" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a>
   <a id="36939" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="36943" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="36949" class="Symbol">(</a><a id="36950" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="36956" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="36962" class="Symbol">)</a> <a id="36964" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="36970" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="36979" class="Symbol">(</a><a id="36980" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="36990" class="Symbol">((</a><a id="36992" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="36994" class="String">&quot;+&quot;</a> <a id="36998" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
       <a id="37007" class="Symbol">(</a><a id="37008" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37010" class="String">&quot;m&quot;</a> <a id="37014" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="37024" class="Symbol">(</a><a id="37025" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37027" class="String">&quot;n&quot;</a> <a id="37031" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
         <a id="37042" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37047" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37049" class="String">&quot;m&quot;</a> <a id="37053" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37060" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37062" class="String">&quot;n&quot;</a> <a id="37066" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="37071" class="String">&quot;m&quot;</a> <a id="37075" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="37077" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37082" class="Symbol">(</a><a id="37083" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37085" class="String">&quot;+&quot;</a> <a id="37089" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37091" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37093" class="String">&quot;m&quot;</a> <a id="37097" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37099" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37101" class="String">&quot;n&quot;</a><a id="37104" class="Symbol">)</a>
         <a id="37115" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="37116" class="Symbol">)))</a>
      <a id="37126" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37128" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
      <a id="37140" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37142" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37147" class="Symbol">(</a><a id="37148" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37153" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="37158" class="Symbol">)))</a>
   <a id="37165" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="37169" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37175" class="Symbol">(</a><a id="37176" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37182" class="Symbol">(</a><a id="37183" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="37188" class="Symbol">(</a><a id="37189" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="37194" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a><a id="37197" class="Symbol">)))</a> <a id="37201" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="37207" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="37216" class="Symbol">(</a><a id="37217" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="37227" class="Symbol">((</a><a id="37229" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37231" class="String">&quot;m&quot;</a> <a id="37235" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="37244" class="Symbol">(</a><a id="37245" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37247" class="String">&quot;n&quot;</a> <a id="37251" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="37261" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37266" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37268" class="String">&quot;m&quot;</a> <a id="37272" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37279" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37281" class="String">&quot;n&quot;</a> <a id="37285" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="37290" class="String">&quot;m&quot;</a> <a id="37294" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
        <a id="37304" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
        <a id="37317" class="Symbol">((</a><a id="37319" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="37321" class="String">&quot;+&quot;</a> <a id="37325" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
          <a id="37337" class="Symbol">(</a><a id="37338" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37340" class="String">&quot;m&quot;</a> <a id="37344" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
           <a id="37357" class="Symbol">(</a><a id="37358" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37360" class="String">&quot;n&quot;</a> <a id="37364" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
            <a id="37378" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37383" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37385" class="String">&quot;m&quot;</a> <a id="37389" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37396" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37398" class="String">&quot;n&quot;</a> <a id="37402" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="37407" class="String">&quot;m&quot;</a> <a id="37411" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="37413" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37418" class="Symbol">(</a><a id="37419" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37421" class="String">&quot;+&quot;</a> <a id="37425" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37427" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37429" class="String">&quot;m&quot;</a> <a id="37433" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37435" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37437" class="String">&quot;n&quot;</a><a id="37440" class="Symbol">)</a>
            <a id="37454" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="37455" class="Symbol">)))</a>
         <a id="37468" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37470" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37472" class="String">&quot;m&quot;</a>
         <a id="37485" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37487" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37489" class="String">&quot;n&quot;</a><a id="37492" class="Symbol">)</a>
        <a id="37502" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="37503" class="Symbol">))</a>
      <a id="37512" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37514" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
      <a id="37526" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37528" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37533" class="Symbol">(</a><a id="37534" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37539" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="37544" class="Symbol">)))</a>
   <a id="37551" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="37555" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37561" class="Symbol">(</a><a id="37562" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37568" class="Symbol">(</a><a id="37569" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="37574" class="Symbol">(</a><a id="37575" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="37579" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="37585" class="Symbol">)))</a> <a id="37589" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="37595" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="37604" class="Symbol">(</a><a id="37605" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="37615" class="Symbol">((</a><a id="37617" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37619" class="String">&quot;n&quot;</a> <a id="37623" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="37632" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37637" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a> <a id="37643" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37650" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37652" class="String">&quot;n&quot;</a> <a id="37656" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="37661" class="String">&quot;m&quot;</a> <a id="37665" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
       <a id="37674" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
       <a id="37686" class="Symbol">((</a><a id="37688" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="37690" class="String">&quot;+&quot;</a> <a id="37694" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
         <a id="37705" class="Symbol">(</a><a id="37706" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37708" class="String">&quot;m&quot;</a> <a id="37712" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
          <a id="37724" class="Symbol">(</a><a id="37725" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="37727" class="String">&quot;n&quot;</a> <a id="37731" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
           <a id="37744" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37749" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37751" class="String">&quot;m&quot;</a> <a id="37755" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37762" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37764" class="String">&quot;n&quot;</a> <a id="37768" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="37773" class="String">&quot;m&quot;</a> <a id="37777" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="37779" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37784" class="Symbol">(</a><a id="37785" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37787" class="String">&quot;+&quot;</a> <a id="37791" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37793" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37795" class="String">&quot;m&quot;</a> <a id="37799" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37801" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37803" class="String">&quot;n&quot;</a><a id="37806" class="Symbol">)</a>
           <a id="37819" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="37820" class="Symbol">)))</a>
        <a id="37832" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37834" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37836" class="String">&quot;m&quot;</a>
        <a id="37848" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37850" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="37852" class="String">&quot;n&quot;</a><a id="37855" class="Symbol">)</a>
       <a id="37864" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="37865" class="Symbol">)</a>
      <a id="37873" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="37875" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37880" class="Symbol">(</a><a id="37881" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37886" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="37891" class="Symbol">)))</a>
   <a id="37898" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="37902" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37908" class="Symbol">(</a><a id="37909" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="37915" class="Symbol">(</a><a id="37916" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="37920" class="Symbol">(</a><a id="37921" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="37927" class="Symbol">(</a><a id="37928" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="37934" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="37940" class="Symbol">))))</a> <a id="37945" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="37951" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
    <a id="37960" class="Symbol">(</a><a id="37961" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="37971" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="37976" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a> <a id="37982" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="37989" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="37994" class="Symbol">(</a><a id="37995" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38000" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="38005" class="Symbol">)</a> <a id="38007" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="38012" class="String">&quot;m&quot;</a> <a id="38016" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a>
     <a id="38023" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a>
     <a id="38033" class="Symbol">((</a><a id="38035" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">μ</a> <a id="38037" class="String">&quot;+&quot;</a> <a id="38041" href="/PLFA-zh/Lambda/#4070" class="InductiveConstructor Operator">⇒</a>
       <a id="38050" class="Symbol">(</a><a id="38051" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38053" class="String">&quot;m&quot;</a> <a id="38057" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
        <a id="38067" class="Symbol">(</a><a id="38068" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38070" class="String">&quot;n&quot;</a> <a id="38074" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
         <a id="38085" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case</a> <a id="38090" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38092" class="String">&quot;m&quot;</a> <a id="38096" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">[zero⇒</a> <a id="38103" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38105" class="String">&quot;n&quot;</a> <a id="38109" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">|suc</a> <a id="38114" class="String">&quot;m&quot;</a> <a id="38118" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">⇒</a> <a id="38120" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38125" class="Symbol">(</a><a id="38126" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38128" class="String">&quot;+&quot;</a> <a id="38132" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38134" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38136" class="String">&quot;m&quot;</a> <a id="38140" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38142" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38144" class="String">&quot;n&quot;</a><a id="38147" class="Symbol">)</a>
         <a id="38158" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="38159" class="Symbol">)))</a>
      <a id="38169" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38171" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38173" class="String">&quot;m&quot;</a>
      <a id="38183" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38185" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38190" class="Symbol">(</a><a id="38191" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38196" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="38201" class="Symbol">))</a>
     <a id="38209" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">]</a><a id="38210" class="Symbol">)</a>
   <a id="38215" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="38219" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="38225" class="Symbol">(</a><a id="38226" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="38232" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a><a id="38238" class="Symbol">)</a> <a id="38240" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="38246" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38251" class="Symbol">(</a><a id="38252" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38257" class="Symbol">(</a><a id="38258" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38263" class="Symbol">(</a><a id="38264" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38269" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="38274" class="Symbol">)))</a>
   <a id="38281" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="38282" class="Symbol">)</a>
   <a id="38287" class="Symbol">(</a><a id="38288" href="/PLFA-zh/Properties/#30819" class="InductiveConstructor">done</a> <a id="38293" class="Symbol">(</a><a id="38294" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="38300" class="Symbol">(</a><a id="38301" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="38307" class="Symbol">(</a><a id="38308" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="38314" class="Symbol">(</a><a id="38315" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="38321" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="38327" class="Symbol">)))))</a>
<a id="38333" class="Symbol">_</a> <a id="38335" class="Symbol">=</a> <a id="38337" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Again, the derivation in the previous chapter was derived by
editing the above.</p>

<p>Similarly, can evaluate the corresponding term for Church numerals:</p>
<pre class="Agda"><a id="38515" href="/PLFA-zh/Properties/#38515" class="Function">_</a> <a id="38517" class="Symbol">:</a> <a id="38519" href="/PLFA-zh/Properties/#31344" class="Function">eval</a> <a id="38524" class="Symbol">(</a><a id="38525" href="/PLFA-zh/Properties/#30617" class="InductiveConstructor">gas</a> <a id="38529" class="Number">100</a><a id="38532" class="Symbol">)</a> <a id="38534" href="/PLFA-zh/Lambda/#38166" class="Function">⊢2+2ᶜ</a> <a id="38540" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a>
  <a id="38544" href="/PLFA-zh/Properties/#31142" class="InductiveConstructor">steps</a>
   <a id="38553" class="Symbol">((</a><a id="38555" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38557" class="String">&quot;m&quot;</a> <a id="38561" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="38568" class="Symbol">(</a><a id="38569" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38571" class="String">&quot;n&quot;</a> <a id="38575" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="38583" class="Symbol">(</a><a id="38584" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38586" class="String">&quot;s&quot;</a> <a id="38590" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38592" class="Symbol">(</a><a id="38593" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38595" class="String">&quot;z&quot;</a> <a id="38599" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38601" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38603" class="String">&quot;m&quot;</a> <a id="38607" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38609" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38611" class="String">&quot;s&quot;</a> <a id="38615" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38617" class="Symbol">(</a><a id="38618" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38620" class="String">&quot;n&quot;</a> <a id="38624" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38626" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38628" class="String">&quot;s&quot;</a> <a id="38632" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38634" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38636" class="String">&quot;z&quot;</a><a id="38639" class="Symbol">)))))</a>
    <a id="38649" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38651" class="Symbol">(</a><a id="38652" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38654" class="String">&quot;s&quot;</a> <a id="38658" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38660" class="Symbol">(</a><a id="38661" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38663" class="String">&quot;z&quot;</a> <a id="38667" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38669" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38671" class="String">&quot;s&quot;</a> <a id="38675" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38677" class="Symbol">(</a><a id="38678" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38680" class="String">&quot;s&quot;</a> <a id="38684" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38686" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38688" class="String">&quot;z&quot;</a><a id="38691" class="Symbol">)))</a>
    <a id="38699" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38701" class="Symbol">(</a><a id="38702" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38704" class="String">&quot;s&quot;</a> <a id="38708" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38710" class="Symbol">(</a><a id="38711" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38713" class="String">&quot;z&quot;</a> <a id="38717" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38719" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38721" class="String">&quot;s&quot;</a> <a id="38725" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38727" class="Symbol">(</a><a id="38728" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38730" class="String">&quot;s&quot;</a> <a id="38734" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38736" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38738" class="String">&quot;z&quot;</a><a id="38741" class="Symbol">)))</a>
    <a id="38749" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38751" class="Symbol">(</a><a id="38752" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38754" class="String">&quot;n&quot;</a> <a id="38758" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38760" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="38765" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38767" class="String">&quot;n&quot;</a><a id="38770" class="Symbol">)</a>
    <a id="38776" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38778" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="38787" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="38791" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="38796" class="Symbol">(</a><a id="38797" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="38802" class="Symbol">(</a><a id="38803" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="38808" class="Symbol">(</a><a id="38809" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="38813" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="38816" class="Symbol">)))</a> <a id="38820" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="38826" class="Symbol">(</a><a id="38827" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38829" class="String">&quot;n&quot;</a> <a id="38833" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="38840" class="Symbol">(</a><a id="38841" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38843" class="String">&quot;s&quot;</a> <a id="38847" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="38855" class="Symbol">(</a><a id="38856" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38858" class="String">&quot;z&quot;</a> <a id="38862" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
       <a id="38871" class="Symbol">(</a><a id="38872" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38874" class="String">&quot;s&quot;</a> <a id="38878" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38880" class="Symbol">(</a><a id="38881" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38883" class="String">&quot;z&quot;</a> <a id="38887" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38889" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38891" class="String">&quot;s&quot;</a> <a id="38895" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38897" class="Symbol">(</a><a id="38898" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38900" class="String">&quot;s&quot;</a> <a id="38904" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38906" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38908" class="String">&quot;z&quot;</a><a id="38911" class="Symbol">)))</a> <a id="38915" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38917" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38919" class="String">&quot;s&quot;</a> <a id="38923" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
       <a id="38932" class="Symbol">(</a><a id="38933" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38935" class="String">&quot;n&quot;</a> <a id="38939" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38941" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38943" class="String">&quot;s&quot;</a> <a id="38947" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38949" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38951" class="String">&quot;z&quot;</a><a id="38954" class="Symbol">))))</a>
    <a id="38963" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38965" class="Symbol">(</a><a id="38966" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38968" class="String">&quot;s&quot;</a> <a id="38972" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38974" class="Symbol">(</a><a id="38975" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="38977" class="String">&quot;z&quot;</a> <a id="38981" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="38983" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38985" class="String">&quot;s&quot;</a> <a id="38989" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="38991" class="Symbol">(</a><a id="38992" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="38994" class="String">&quot;s&quot;</a> <a id="38998" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39000" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39002" class="String">&quot;z&quot;</a><a id="39005" class="Symbol">)))</a>
    <a id="39013" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39015" class="Symbol">(</a><a id="39016" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39018" class="String">&quot;n&quot;</a> <a id="39022" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39024" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39029" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39031" class="String">&quot;n&quot;</a><a id="39034" class="Symbol">)</a>
    <a id="39040" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39042" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="39051" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="39055" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="39060" class="Symbol">(</a><a id="39061" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="39066" class="Symbol">(</a><a id="39067" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="39071" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="39074" class="Symbol">))</a> <a id="39077" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="39083" class="Symbol">(</a><a id="39084" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39086" class="String">&quot;s&quot;</a> <a id="39090" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="39097" class="Symbol">(</a><a id="39098" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39100" class="String">&quot;z&quot;</a> <a id="39104" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
      <a id="39112" class="Symbol">(</a><a id="39113" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39115" class="String">&quot;s&quot;</a> <a id="39119" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39121" class="Symbol">(</a><a id="39122" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39124" class="String">&quot;z&quot;</a> <a id="39128" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39130" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39132" class="String">&quot;s&quot;</a> <a id="39136" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39138" class="Symbol">(</a><a id="39139" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39141" class="String">&quot;s&quot;</a> <a id="39145" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39147" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39149" class="String">&quot;z&quot;</a><a id="39152" class="Symbol">)))</a> <a id="39156" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39158" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39160" class="String">&quot;s&quot;</a> <a id="39164" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
      <a id="39172" class="Symbol">((</a><a id="39174" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39176" class="String">&quot;s&quot;</a> <a id="39180" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39182" class="Symbol">(</a><a id="39183" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39185" class="String">&quot;z&quot;</a> <a id="39189" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39191" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39193" class="String">&quot;s&quot;</a> <a id="39197" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39199" class="Symbol">(</a><a id="39200" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39202" class="String">&quot;s&quot;</a> <a id="39206" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39208" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39210" class="String">&quot;z&quot;</a><a id="39213" class="Symbol">)))</a> <a id="39217" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39219" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39221" class="String">&quot;s&quot;</a> <a id="39225" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39227" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39229" class="String">&quot;z&quot;</a><a id="39232" class="Symbol">)))</a>
    <a id="39240" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39242" class="Symbol">(</a><a id="39243" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39245" class="String">&quot;n&quot;</a> <a id="39249" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39251" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39256" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39258" class="String">&quot;n&quot;</a><a id="39261" class="Symbol">)</a>
    <a id="39267" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39269" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="39278" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="39282" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="39287" class="Symbol">(</a><a id="39288" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="39292" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="39295" class="Symbol">)</a> <a id="39297" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="39303" class="Symbol">(</a><a id="39304" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39306" class="String">&quot;z&quot;</a> <a id="39310" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a>
     <a id="39317" class="Symbol">(</a><a id="39318" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39320" class="String">&quot;s&quot;</a> <a id="39324" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39326" class="Symbol">(</a><a id="39327" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39329" class="String">&quot;z&quot;</a> <a id="39333" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39335" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39337" class="String">&quot;s&quot;</a> <a id="39341" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39343" class="Symbol">(</a><a id="39344" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39346" class="String">&quot;s&quot;</a> <a id="39350" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39352" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39354" class="String">&quot;z&quot;</a><a id="39357" class="Symbol">)))</a> <a id="39361" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39363" class="Symbol">(</a><a id="39364" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39366" class="String">&quot;n&quot;</a> <a id="39370" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39372" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39377" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39379" class="String">&quot;n&quot;</a><a id="39382" class="Symbol">)</a>
     <a id="39389" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
     <a id="39396" class="Symbol">((</a><a id="39398" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39400" class="String">&quot;s&quot;</a> <a id="39404" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39406" class="Symbol">(</a><a id="39407" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39409" class="String">&quot;z&quot;</a> <a id="39413" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39415" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39417" class="String">&quot;s&quot;</a> <a id="39421" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39423" class="Symbol">(</a><a id="39424" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39426" class="String">&quot;s&quot;</a> <a id="39430" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39432" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39434" class="String">&quot;z&quot;</a><a id="39437" class="Symbol">)))</a> <a id="39441" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39443" class="Symbol">(</a><a id="39444" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39446" class="String">&quot;n&quot;</a> <a id="39450" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39452" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39457" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39459" class="String">&quot;n&quot;</a><a id="39462" class="Symbol">)</a>
      <a id="39470" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39472" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39474" class="String">&quot;z&quot;</a><a id="39477" class="Symbol">))</a>
    <a id="39484" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39486" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a>
   <a id="39495" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="39499" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="39503" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a> <a id="39510" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="39516" class="Symbol">(</a><a id="39517" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39519" class="String">&quot;s&quot;</a> <a id="39523" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39525" class="Symbol">(</a><a id="39526" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39528" class="String">&quot;z&quot;</a> <a id="39532" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39534" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39536" class="String">&quot;s&quot;</a> <a id="39540" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39542" class="Symbol">(</a><a id="39543" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39545" class="String">&quot;s&quot;</a> <a id="39549" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39551" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39553" class="String">&quot;z&quot;</a><a id="39556" class="Symbol">)))</a> <a id="39560" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39562" class="Symbol">(</a><a id="39563" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39565" class="String">&quot;n&quot;</a> <a id="39569" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39571" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39576" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39578" class="String">&quot;n&quot;</a><a id="39581" class="Symbol">)</a>
    <a id="39587" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="39593" class="Symbol">((</a><a id="39595" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39597" class="String">&quot;s&quot;</a> <a id="39601" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39603" class="Symbol">(</a><a id="39604" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39606" class="String">&quot;z&quot;</a> <a id="39610" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39612" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39614" class="String">&quot;s&quot;</a> <a id="39618" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39620" class="Symbol">(</a><a id="39621" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39623" class="String">&quot;s&quot;</a> <a id="39627" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39629" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39631" class="String">&quot;z&quot;</a><a id="39634" class="Symbol">)))</a> <a id="39638" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39640" class="Symbol">(</a><a id="39641" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39643" class="String">&quot;n&quot;</a> <a id="39647" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39649" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39654" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39656" class="String">&quot;n&quot;</a><a id="39659" class="Symbol">)</a>
     <a id="39666" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39668" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="39673" class="Symbol">)</a>
   <a id="39678" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="39682" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="39687" class="Symbol">(</a><a id="39688" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="39692" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="39695" class="Symbol">)</a> <a id="39697" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="39703" class="Symbol">(</a><a id="39704" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39706" class="String">&quot;z&quot;</a> <a id="39710" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39712" class="Symbol">(</a><a id="39713" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39715" class="String">&quot;n&quot;</a> <a id="39719" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39721" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39726" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39728" class="String">&quot;n&quot;</a><a id="39731" class="Symbol">)</a> <a id="39733" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39735" class="Symbol">((</a><a id="39737" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39739" class="String">&quot;n&quot;</a> <a id="39743" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39745" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39750" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39752" class="String">&quot;n&quot;</a><a id="39755" class="Symbol">)</a> <a id="39757" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39759" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39761" class="String">&quot;z&quot;</a><a id="39764" class="Symbol">))</a> <a id="39767" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="39773" class="Symbol">((</a><a id="39775" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39777" class="String">&quot;s&quot;</a> <a id="39781" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39783" class="Symbol">(</a><a id="39784" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39786" class="String">&quot;z&quot;</a> <a id="39790" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39792" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39794" class="String">&quot;s&quot;</a> <a id="39798" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39800" class="Symbol">(</a><a id="39801" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39803" class="String">&quot;s&quot;</a> <a id="39807" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39809" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39811" class="String">&quot;z&quot;</a><a id="39814" class="Symbol">)))</a> <a id="39818" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39820" class="Symbol">(</a><a id="39821" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39823" class="String">&quot;n&quot;</a> <a id="39827" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39829" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39834" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39836" class="String">&quot;n&quot;</a><a id="39839" class="Symbol">)</a>
     <a id="39846" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39848" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="39853" class="Symbol">)</a>
   <a id="39858" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="39862" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="39867" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="39871" class="Symbol">(</a><a id="39872" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="39877" class="Symbol">(</a><a id="39878" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="39882" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a><a id="39885" class="Symbol">))</a> <a id="39888" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="39894" class="Symbol">(</a><a id="39895" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39897" class="String">&quot;z&quot;</a> <a id="39901" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39903" class="Symbol">(</a><a id="39904" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39906" class="String">&quot;n&quot;</a> <a id="39910" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39912" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39917" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39919" class="String">&quot;n&quot;</a><a id="39922" class="Symbol">)</a> <a id="39924" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39926" class="Symbol">((</a><a id="39928" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39930" class="String">&quot;n&quot;</a> <a id="39934" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39936" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39941" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39943" class="String">&quot;n&quot;</a><a id="39946" class="Symbol">)</a> <a id="39948" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39950" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39952" class="String">&quot;z&quot;</a><a id="39955" class="Symbol">))</a> <a id="39958" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="39964" class="Symbol">((</a><a id="39966" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39968" class="String">&quot;z&quot;</a> <a id="39972" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39974" class="Symbol">(</a><a id="39975" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="39977" class="String">&quot;n&quot;</a> <a id="39981" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="39983" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="39988" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="39990" class="String">&quot;n&quot;</a><a id="39993" class="Symbol">)</a> <a id="39995" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="39997" class="Symbol">((</a><a id="39999" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40001" class="String">&quot;n&quot;</a> <a id="40005" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40007" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40012" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40014" class="String">&quot;n&quot;</a><a id="40017" class="Symbol">)</a> <a id="40019" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40021" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40023" class="String">&quot;z&quot;</a><a id="40026" class="Symbol">))</a> <a id="40029" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
     <a id="40036" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40041" class="Symbol">)</a>
   <a id="40046" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40050" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="40055" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="40059" class="Symbol">(</a><a id="40060" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40064" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40070" class="Symbol">)</a> <a id="40072" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40078" class="Symbol">(</a><a id="40079" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40081" class="String">&quot;z&quot;</a> <a id="40085" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40087" class="Symbol">(</a><a id="40088" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40090" class="String">&quot;n&quot;</a> <a id="40094" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40096" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40101" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40103" class="String">&quot;n&quot;</a><a id="40106" class="Symbol">)</a> <a id="40108" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40110" class="Symbol">((</a><a id="40112" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40114" class="String">&quot;n&quot;</a> <a id="40118" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40120" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40125" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40127" class="String">&quot;n&quot;</a><a id="40130" class="Symbol">)</a> <a id="40132" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40134" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40136" class="String">&quot;z&quot;</a><a id="40139" class="Symbol">))</a> <a id="40142" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="40148" class="Symbol">((</a><a id="40150" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40152" class="String">&quot;n&quot;</a> <a id="40156" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40158" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40163" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40165" class="String">&quot;n&quot;</a><a id="40168" class="Symbol">)</a> <a id="40170" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40172" class="Symbol">((</a><a id="40174" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40176" class="String">&quot;n&quot;</a> <a id="40180" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40182" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40187" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40189" class="String">&quot;n&quot;</a><a id="40192" class="Symbol">)</a> <a id="40194" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40196" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40201" class="Symbol">))</a>
   <a id="40207" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40211" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="40216" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="40220" class="Symbol">(</a><a id="40221" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="40226" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="40230" class="Symbol">(</a><a id="40231" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40235" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40241" class="Symbol">))</a> <a id="40244" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40250" class="Symbol">(</a><a id="40251" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40253" class="String">&quot;z&quot;</a> <a id="40257" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40259" class="Symbol">(</a><a id="40260" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40262" class="String">&quot;n&quot;</a> <a id="40266" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40268" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40273" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40275" class="String">&quot;n&quot;</a><a id="40278" class="Symbol">)</a> <a id="40280" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40282" class="Symbol">((</a><a id="40284" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40286" class="String">&quot;n&quot;</a> <a id="40290" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40292" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40297" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40299" class="String">&quot;n&quot;</a><a id="40302" class="Symbol">)</a> <a id="40304" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40306" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40308" class="String">&quot;z&quot;</a><a id="40311" class="Symbol">))</a> <a id="40314" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="40320" class="Symbol">((</a><a id="40322" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40324" class="String">&quot;n&quot;</a> <a id="40328" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40330" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40335" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40337" class="String">&quot;n&quot;</a><a id="40340" class="Symbol">)</a> <a id="40342" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40344" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40349" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40354" class="Symbol">)</a>
   <a id="40359" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40363" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="40368" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="40372" class="Symbol">(</a><a id="40373" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40377" class="Symbol">(</a><a id="40378" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40384" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40390" class="Symbol">))</a> <a id="40393" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40399" class="Symbol">(</a><a id="40400" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40402" class="String">&quot;z&quot;</a> <a id="40406" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40408" class="Symbol">(</a><a id="40409" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40411" class="String">&quot;n&quot;</a> <a id="40415" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40417" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40422" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40424" class="String">&quot;n&quot;</a><a id="40427" class="Symbol">)</a> <a id="40429" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40431" class="Symbol">((</a><a id="40433" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40435" class="String">&quot;n&quot;</a> <a id="40439" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40441" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40446" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40448" class="String">&quot;n&quot;</a><a id="40451" class="Symbol">)</a> <a id="40453" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40455" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40457" class="String">&quot;z&quot;</a><a id="40460" class="Symbol">))</a> <a id="40463" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a>
    <a id="40469" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40474" class="Symbol">(</a><a id="40475" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40480" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40485" class="Symbol">)</a>
   <a id="40490" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40494" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40498" class="Symbol">(</a><a id="40499" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40505" class="Symbol">(</a><a id="40506" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40512" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40518" class="Symbol">))</a> <a id="40521" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40527" class="Symbol">(</a><a id="40528" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40530" class="String">&quot;n&quot;</a> <a id="40534" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40536" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40541" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40543" class="String">&quot;n&quot;</a><a id="40546" class="Symbol">)</a> <a id="40548" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40550" class="Symbol">((</a><a id="40552" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40554" class="String">&quot;n&quot;</a> <a id="40558" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40560" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40565" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40567" class="String">&quot;n&quot;</a><a id="40570" class="Symbol">)</a> <a id="40572" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40574" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40579" class="Symbol">(</a><a id="40580" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40585" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40590" class="Symbol">))</a>
   <a id="40596" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40600" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="40605" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="40609" class="Symbol">(</a><a id="40610" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40614" class="Symbol">(</a><a id="40615" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40621" class="Symbol">(</a><a id="40622" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40628" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40634" class="Symbol">)))</a> <a id="40638" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40644" class="Symbol">(</a><a id="40645" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">ƛ</a> <a id="40647" class="String">&quot;n&quot;</a> <a id="40651" href="/PLFA-zh/Lambda/#3841" class="InductiveConstructor Operator">⇒</a> <a id="40653" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40658" href="/PLFA-zh/Lambda/#3802" class="InductiveConstructor Operator">`</a> <a id="40660" class="String">&quot;n&quot;</a><a id="40663" class="Symbol">)</a> <a id="40665" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">·</a> <a id="40667" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40672" class="Symbol">(</a><a id="40673" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40678" class="Symbol">(</a><a id="40679" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40684" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40689" class="Symbol">))</a>
   <a id="40695" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">—→⟨</a> <a id="40699" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="40703" class="Symbol">(</a><a id="40704" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40710" class="Symbol">(</a><a id="40711" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40717" class="Symbol">(</a><a id="40718" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40724" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40730" class="Symbol">)))</a> <a id="40734" href="/PLFA-zh/Lambda/#21934" class="InductiveConstructor Operator">⟩</a>
    <a id="40740" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40745" class="Symbol">(</a><a id="40746" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40751" class="Symbol">(</a><a id="40752" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40757" class="Symbol">(</a><a id="40758" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc</a> <a id="40763" href="/PLFA-zh/Lambda/#3935" class="InductiveConstructor">`zero</a><a id="40768" class="Symbol">)))</a>
   <a id="40775" href="/PLFA-zh/Lambda/#21893" class="InductiveConstructor Operator">∎</a><a id="40776" class="Symbol">)</a>
   <a id="40781" class="Symbol">(</a><a id="40782" href="/PLFA-zh/Properties/#30819" class="InductiveConstructor">done</a> <a id="40787" class="Symbol">(</a><a id="40788" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40794" class="Symbol">(</a><a id="40795" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40801" class="Symbol">(</a><a id="40802" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40808" class="Symbol">(</a><a id="40809" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="40815" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a><a id="40821" class="Symbol">)))))</a>
<a id="40827" class="Symbol">_</a> <a id="40829" class="Symbol">=</a> <a id="40831" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>And again, the example in the previous section was derived by editing the
above.</p>

<h4 id="exercise-mul-example-recommended">Exercise <code class="highlighter-rouge">mul-example</code> (recommended)</h4>

<p>Using the evaluator, confirm that two times two is four.</p>

<pre class="Agda"><a id="41043" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-progress-preservation">Exercise: <code class="highlighter-rouge">progress-preservation</code></h4>

<p>Without peeking at their statements above, write down the progress
and preservation theorems for the simply typed lambda-calculus.</p>

<pre class="Agda"><a id="41264" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-subject_expansion">Exercise <code class="highlighter-rouge">subject_expansion</code></h4>

<p>We say that <code class="highlighter-rouge">M</code> <em>reduces</em> to <code class="highlighter-rouge">N</code> if <code class="highlighter-rouge">M —→ N</code>,
but we can also describe the same situation by saying
that <code class="highlighter-rouge">N</code> <em>expands</em> to <code class="highlighter-rouge">M</code>.
The preservation property is sometimes called <em>subject reduction</em>.
Its opposite is <em>subject expansion</em>, which holds if
<code class="highlighter-rouge">M —→ N</code> and <code class="highlighter-rouge">∅ ⊢ N ⦂ A</code> imply <code class="highlighter-rouge">∅ ⊢ M ⦂ A</code>.
Find two counter-examples to subject expansion, one
with case expressions and one not involving case expressions.</p>

<pre class="Agda"><a id="41753" class="Comment">-- Your code goes here</a></pre>

<h2 id="well-typed-terms-dont-get-stuck">Well-typed terms don’t get stuck</h2>

<p>A term is <em>normal</em> if it cannot reduce:</p>
<pre class="Agda"><a id="Normal"></a><a id="41879" href="/PLFA-zh/Properties/#41879" class="Function">Normal</a> <a id="41886" class="Symbol">:</a> <a id="41888" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a> <a id="41893" class="Symbol">→</a> <a id="41895" class="PrimitiveType">Set</a>
<a id="41899" href="/PLFA-zh/Properties/#41879" class="Function">Normal</a> <a id="41906" href="/PLFA-zh/Properties/#41906" class="Bound">M</a>  <a id="41909" class="Symbol">=</a>  <a id="41912" class="Symbol">∀</a> <a id="41914" class="Symbol">{</a><a id="41915" href="/PLFA-zh/Properties/#41915" class="Bound">N</a><a id="41916" class="Symbol">}</a> <a id="41918" class="Symbol">→</a> <a id="41920" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="41922" class="Symbol">(</a><a id="41923" href="/PLFA-zh/Properties/#41906" class="Bound">M</a> <a id="41925" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="41928" href="/PLFA-zh/Properties/#41915" class="Bound">N</a><a id="41929" class="Symbol">)</a></pre>

<p>A term is <em>stuck</em> if it is normal yet not a value:</p>
<pre class="Agda"><a id="Stuck"></a><a id="42007" href="/PLFA-zh/Properties/#42007" class="Function">Stuck</a> <a id="42013" class="Symbol">:</a> <a id="42015" href="/PLFA-zh/Lambda/#3783" class="Datatype">Term</a> <a id="42020" class="Symbol">→</a> <a id="42022" class="PrimitiveType">Set</a>
<a id="42026" href="/PLFA-zh/Properties/#42007" class="Function">Stuck</a> <a id="42032" href="/PLFA-zh/Properties/#42032" class="Bound">M</a>  <a id="42035" class="Symbol">=</a>  <a id="42038" href="/PLFA-zh/Properties/#41879" class="Function">Normal</a> <a id="42045" href="/PLFA-zh/Properties/#42032" class="Bound">M</a> <a id="42047" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="42049" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="42051" href="/PLFA-zh/Lambda/#11573" class="Datatype">Value</a> <a id="42057" href="/PLFA-zh/Properties/#42032" class="Bound">M</a></pre>

<p>Using progress, it is easy to show that no well-typed term is stuck:</p>
<pre class="Agda"><a id="42153" class="Keyword">postulate</a>
  <a id="unstuck"></a><a id="42165" href="/PLFA-zh/Properties/#42165" class="Postulate">unstuck</a> <a id="42173" class="Symbol">:</a> <a id="42175" class="Symbol">∀</a> <a id="42177" class="Symbol">{</a><a id="42178" href="/PLFA-zh/Properties/#42178" class="Bound">M</a> <a id="42180" href="/PLFA-zh/Properties/#42180" class="Bound">A</a><a id="42181" class="Symbol">}</a>
    <a id="42187" class="Symbol">→</a> <a id="42189" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="42191" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="42193" href="/PLFA-zh/Properties/#42178" class="Bound">M</a> <a id="42195" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="42197" href="/PLFA-zh/Properties/#42180" class="Bound">A</a>
      <a id="42205" class="Comment">-----------</a>
    <a id="42221" class="Symbol">→</a> <a id="42223" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="42225" class="Symbol">(</a><a id="42226" href="/PLFA-zh/Properties/#42007" class="Function">Stuck</a> <a id="42232" href="/PLFA-zh/Properties/#42178" class="Bound">M</a><a id="42233" class="Symbol">)</a></pre>

<p>Using preservation, it is easy to show that after any number of steps,
a well-typed term remains well-typed:</p>
<pre class="Agda"><a id="42369" class="Keyword">postulate</a>
  <a id="preserves"></a><a id="42381" href="/PLFA-zh/Properties/#42381" class="Postulate">preserves</a> <a id="42391" class="Symbol">:</a> <a id="42393" class="Symbol">∀</a> <a id="42395" class="Symbol">{</a><a id="42396" href="/PLFA-zh/Properties/#42396" class="Bound">M</a> <a id="42398" href="/PLFA-zh/Properties/#42398" class="Bound">N</a> <a id="42400" href="/PLFA-zh/Properties/#42400" class="Bound">A</a><a id="42401" class="Symbol">}</a>
    <a id="42407" class="Symbol">→</a> <a id="42409" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="42411" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="42413" href="/PLFA-zh/Properties/#42396" class="Bound">M</a> <a id="42415" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="42417" href="/PLFA-zh/Properties/#42400" class="Bound">A</a>
    <a id="42423" class="Symbol">→</a> <a id="42425" href="/PLFA-zh/Properties/#42396" class="Bound">M</a> <a id="42427" href="/PLFA-zh/Lambda/#21860" class="Datatype Operator">—↠</a> <a id="42430" href="/PLFA-zh/Properties/#42398" class="Bound">N</a>
      <a id="42438" class="Comment">---------</a>
    <a id="42452" class="Symbol">→</a> <a id="42454" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="42456" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="42458" href="/PLFA-zh/Properties/#42398" class="Bound">N</a> <a id="42460" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="42462" href="/PLFA-zh/Properties/#42400" class="Bound">A</a></pre>

<p>An easy consequence is that starting from a well-typed term, taking
any number of reduction steps leads to a term that is not stuck:</p>
<pre class="Agda"><a id="42622" class="Keyword">postulate</a>
  <a id="wttdgs"></a><a id="42634" href="/PLFA-zh/Properties/#42634" class="Postulate">wttdgs</a> <a id="42641" class="Symbol">:</a> <a id="42643" class="Symbol">∀</a> <a id="42645" class="Symbol">{</a><a id="42646" href="/PLFA-zh/Properties/#42646" class="Bound">M</a> <a id="42648" href="/PLFA-zh/Properties/#42648" class="Bound">N</a> <a id="42650" href="/PLFA-zh/Properties/#42650" class="Bound">A</a><a id="42651" class="Symbol">}</a>
    <a id="42657" class="Symbol">→</a> <a id="42659" href="/PLFA-zh/Lambda/#30376" class="InductiveConstructor">∅</a> <a id="42661" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⊢</a> <a id="42663" href="/PLFA-zh/Properties/#42646" class="Bound">M</a> <a id="42665" href="/PLFA-zh/Lambda/#32516" class="Datatype Operator">⦂</a> <a id="42667" href="/PLFA-zh/Properties/#42650" class="Bound">A</a>
    <a id="42673" class="Symbol">→</a> <a id="42675" href="/PLFA-zh/Properties/#42646" class="Bound">M</a> <a id="42677" href="/PLFA-zh/Lambda/#21860" class="Datatype Operator">—↠</a> <a id="42680" href="/PLFA-zh/Properties/#42648" class="Bound">N</a>
      <a id="42688" class="Comment">-----------</a>
    <a id="42704" class="Symbol">→</a> <a id="42706" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="42708" class="Symbol">(</a><a id="42709" href="/PLFA-zh/Properties/#42007" class="Function">Stuck</a> <a id="42715" href="/PLFA-zh/Properties/#42648" class="Bound">N</a><a id="42716" class="Symbol">)</a></pre>
<p>Felleisen and Wright, who introduced proofs via progress and
preservation, summarised this result with the slogan <em>well-typed terms
don’t get stuck</em>.  (They were referring to earlier work by Robin
Milner, who used denotational rather than operational semantics. He
introduced <code class="highlighter-rouge">wrong</code> as the denotation of a term with a type error, and
showed <em>well-typed terms don’t go wrong</em>.)</p>

<h4 id="exercise-stuck">Exercise <code class="highlighter-rouge">stuck</code></h4>

<p>Give an example of an ill-typed term that does get stuck.</p>

<pre class="Agda"><a id="43203" class="Comment">-- Your code goes here</a></pre>

<h4 id="exercise-unstuck-recommended">Exercise <code class="highlighter-rouge">unstuck</code> (recommended)</h4>

<p>Provide proofs of the three postulates, <code class="highlighter-rouge">unstuck</code>, <code class="highlighter-rouge">preserves</code>, and <code class="highlighter-rouge">wttdgs</code> above.</p>

<pre class="Agda"><a id="43375" class="Comment">-- Your code goes here</a></pre>

<h2 id="reduction-is-deterministic">Reduction is deterministic</h2>

<p>When we introduced reduction, we claimed it was deterministic.
For completeness, we present a formal proof here.</p>

<p>A case term takes four arguments (three subterms and a bound
variable), and our proof will need a variant
of congruence to deal with functions of four arguments.  It
is exactly analogous to <code class="highlighter-rouge">cong</code> and <code class="highlighter-rouge">cong₂</code> as defined previously:</p>
<pre class="Agda"><a id="cong₄"></a><a id="43800" href="/PLFA-zh/Properties/#43800" class="Function">cong₄</a> <a id="43806" class="Symbol">:</a> <a id="43808" class="Symbol">∀</a> <a id="43810" class="Symbol">{</a><a id="43811" href="/PLFA-zh/Properties/#43811" class="Bound">A</a> <a id="43813" href="/PLFA-zh/Properties/#43813" class="Bound">B</a> <a id="43815" href="/PLFA-zh/Properties/#43815" class="Bound">C</a> <a id="43817" href="/PLFA-zh/Properties/#43817" class="Bound">D</a> <a id="43819" href="/PLFA-zh/Properties/#43819" class="Bound">E</a> <a id="43821" class="Symbol">:</a> <a id="43823" class="PrimitiveType">Set</a><a id="43826" class="Symbol">}</a> <a id="43828" class="Symbol">(</a><a id="43829" href="/PLFA-zh/Properties/#43829" class="Bound">f</a> <a id="43831" class="Symbol">:</a> <a id="43833" href="/PLFA-zh/Properties/#43811" class="Bound">A</a> <a id="43835" class="Symbol">→</a> <a id="43837" href="/PLFA-zh/Properties/#43813" class="Bound">B</a> <a id="43839" class="Symbol">→</a> <a id="43841" href="/PLFA-zh/Properties/#43815" class="Bound">C</a> <a id="43843" class="Symbol">→</a> <a id="43845" href="/PLFA-zh/Properties/#43817" class="Bound">D</a> <a id="43847" class="Symbol">→</a> <a id="43849" href="/PLFA-zh/Properties/#43819" class="Bound">E</a><a id="43850" class="Symbol">)</a>
  <a id="43854" class="Symbol">{</a><a id="43855" href="/PLFA-zh/Properties/#43855" class="Bound">s</a> <a id="43857" href="/PLFA-zh/Properties/#43857" class="Bound">w</a> <a id="43859" class="Symbol">:</a> <a id="43861" href="/PLFA-zh/Properties/#43811" class="Bound">A</a><a id="43862" class="Symbol">}</a> <a id="43864" class="Symbol">{</a><a id="43865" href="/PLFA-zh/Properties/#43865" class="Bound">t</a> <a id="43867" href="/PLFA-zh/Properties/#43867" class="Bound">x</a> <a id="43869" class="Symbol">:</a> <a id="43871" href="/PLFA-zh/Properties/#43813" class="Bound">B</a><a id="43872" class="Symbol">}</a> <a id="43874" class="Symbol">{</a><a id="43875" href="/PLFA-zh/Properties/#43875" class="Bound">u</a> <a id="43877" href="/PLFA-zh/Properties/#43877" class="Bound">y</a> <a id="43879" class="Symbol">:</a> <a id="43881" href="/PLFA-zh/Properties/#43815" class="Bound">C</a><a id="43882" class="Symbol">}</a> <a id="43884" class="Symbol">{</a><a id="43885" href="/PLFA-zh/Properties/#43885" class="Bound">v</a> <a id="43887" href="/PLFA-zh/Properties/#43887" class="Bound">z</a> <a id="43889" class="Symbol">:</a> <a id="43891" href="/PLFA-zh/Properties/#43817" class="Bound">D</a><a id="43892" class="Symbol">}</a>
  <a id="43896" class="Symbol">→</a> <a id="43898" href="/PLFA-zh/Properties/#43855" class="Bound">s</a> <a id="43900" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="43902" href="/PLFA-zh/Properties/#43857" class="Bound">w</a> <a id="43904" class="Symbol">→</a> <a id="43906" href="/PLFA-zh/Properties/#43865" class="Bound">t</a> <a id="43908" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="43910" href="/PLFA-zh/Properties/#43867" class="Bound">x</a> <a id="43912" class="Symbol">→</a> <a id="43914" href="/PLFA-zh/Properties/#43875" class="Bound">u</a> <a id="43916" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="43918" href="/PLFA-zh/Properties/#43877" class="Bound">y</a> <a id="43920" class="Symbol">→</a> <a id="43922" href="/PLFA-zh/Properties/#43885" class="Bound">v</a> <a id="43924" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="43926" href="/PLFA-zh/Properties/#43887" class="Bound">z</a> <a id="43928" class="Symbol">→</a> <a id="43930" href="/PLFA-zh/Properties/#43829" class="Bound">f</a> <a id="43932" href="/PLFA-zh/Properties/#43855" class="Bound">s</a> <a id="43934" href="/PLFA-zh/Properties/#43865" class="Bound">t</a> <a id="43936" href="/PLFA-zh/Properties/#43875" class="Bound">u</a> <a id="43938" href="/PLFA-zh/Properties/#43885" class="Bound">v</a> <a id="43940" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="43942" href="/PLFA-zh/Properties/#43829" class="Bound">f</a> <a id="43944" href="/PLFA-zh/Properties/#43857" class="Bound">w</a> <a id="43946" href="/PLFA-zh/Properties/#43867" class="Bound">x</a> <a id="43948" href="/PLFA-zh/Properties/#43877" class="Bound">y</a> <a id="43950" href="/PLFA-zh/Properties/#43887" class="Bound">z</a>
<a id="43952" href="/PLFA-zh/Properties/#43800" class="Function">cong₄</a> <a id="43958" href="/PLFA-zh/Properties/#43958" class="Bound">f</a> <a id="43960" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="43965" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="43970" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="43975" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="43980" class="Symbol">=</a> <a id="43982" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>It is now straightforward to show that reduction is deterministic:</p>
<pre class="Agda"><a id="det"></a><a id="44079" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44083" class="Symbol">:</a> <a id="44085" class="Symbol">∀</a> <a id="44087" class="Symbol">{</a><a id="44088" href="/PLFA-zh/Properties/#44088" class="Bound">M</a> <a id="44090" href="/PLFA-zh/Properties/#44090" class="Bound">M′</a> <a id="44093" href="/PLFA-zh/Properties/#44093" class="Bound">M″</a><a id="44095" class="Symbol">}</a>
  <a id="44099" class="Symbol">→</a> <a id="44101" class="Symbol">(</a><a id="44102" href="/PLFA-zh/Properties/#44088" class="Bound">M</a> <a id="44104" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="44107" href="/PLFA-zh/Properties/#44090" class="Bound">M′</a><a id="44109" class="Symbol">)</a>
  <a id="44113" class="Symbol">→</a> <a id="44115" class="Symbol">(</a><a id="44116" href="/PLFA-zh/Properties/#44088" class="Bound">M</a> <a id="44118" href="/PLFA-zh/Lambda/#19239" class="Datatype Operator">—→</a> <a id="44121" href="/PLFA-zh/Properties/#44093" class="Bound">M″</a><a id="44123" class="Symbol">)</a>
    <a id="44129" class="Comment">--------</a>
  <a id="44140" class="Symbol">→</a> <a id="44142" href="/PLFA-zh/Properties/#44090" class="Bound">M′</a> <a id="44145" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="44147" href="/PLFA-zh/Properties/#44093" class="Bound">M″</a>
<a id="44150" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44154" class="Symbol">(</a><a id="44155" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44160" href="/PLFA-zh/Properties/#44160" class="Bound">L—→L′</a><a id="44165" class="Symbol">)</a>   <a id="44169" class="Symbol">(</a><a id="44170" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44175" href="/PLFA-zh/Properties/#44175" class="Bound">L—→L″</a><a id="44180" class="Symbol">)</a>     <a id="44186" class="Symbol">=</a>  <a id="44189" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a> <a id="44195" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">_·_</a> <a id="44199" class="Symbol">(</a><a id="44200" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44204" href="/PLFA-zh/Properties/#44160" class="Bound">L—→L′</a> <a id="44210" href="/PLFA-zh/Properties/#44175" class="Bound">L—→L″</a><a id="44215" class="Symbol">)</a> <a id="44217" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="44222" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44226" class="Symbol">(</a><a id="44227" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44232" href="/PLFA-zh/Properties/#44232" class="Bound">L—→L′</a><a id="44237" class="Symbol">)</a>   <a id="44241" class="Symbol">(</a><a id="44242" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44247" href="/PLFA-zh/Properties/#44247" class="Bound">VL</a> <a id="44250" href="/PLFA-zh/Properties/#44250" class="Bound">M—→M″</a><a id="44255" class="Symbol">)</a>  <a id="44258" class="Symbol">=</a>  <a id="44261" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44268" class="Symbol">(</a><a id="44269" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44274" href="/PLFA-zh/Properties/#44247" class="Bound">VL</a> <a id="44277" href="/PLFA-zh/Properties/#44232" class="Bound">L—→L′</a><a id="44282" class="Symbol">)</a>
<a id="44284" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44288" class="Symbol">(</a><a id="44289" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44294" href="/PLFA-zh/Properties/#44294" class="Bound">L—→L′</a><a id="44299" class="Symbol">)</a>   <a id="44303" class="Symbol">(</a><a id="44304" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44308" class="Symbol">_)</a>          <a id="44320" class="Symbol">=</a>  <a id="44323" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44330" class="Symbol">(</a><a id="44331" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44336" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="44340" href="/PLFA-zh/Properties/#44294" class="Bound">L—→L′</a><a id="44345" class="Symbol">)</a>
<a id="44347" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44351" class="Symbol">(</a><a id="44352" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44357" href="/PLFA-zh/Properties/#44357" class="Bound">VL</a> <a id="44360" class="Symbol">_)</a>    <a id="44366" class="Symbol">(</a><a id="44367" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44372" href="/PLFA-zh/Properties/#44372" class="Bound">L—→L″</a><a id="44377" class="Symbol">)</a>     <a id="44383" class="Symbol">=</a>  <a id="44386" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44393" class="Symbol">(</a><a id="44394" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44399" href="/PLFA-zh/Properties/#44357" class="Bound">VL</a> <a id="44402" href="/PLFA-zh/Properties/#44372" class="Bound">L—→L″</a><a id="44407" class="Symbol">)</a>
<a id="44409" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44413" class="Symbol">(</a><a id="44414" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44419" class="Symbol">_</a> <a id="44421" href="/PLFA-zh/Properties/#44421" class="Bound">M—→M′</a><a id="44426" class="Symbol">)</a> <a id="44428" class="Symbol">(</a><a id="44429" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44434" class="Symbol">_</a> <a id="44436" href="/PLFA-zh/Properties/#44436" class="Bound">M—→M″</a><a id="44441" class="Symbol">)</a>   <a id="44445" class="Symbol">=</a>  <a id="44448" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a> <a id="44454" href="/PLFA-zh/Lambda/#3887" class="InductiveConstructor Operator">_·_</a> <a id="44458" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="44463" class="Symbol">(</a><a id="44464" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44468" href="/PLFA-zh/Properties/#44421" class="Bound">M—→M′</a> <a id="44474" href="/PLFA-zh/Properties/#44436" class="Bound">M—→M″</a><a id="44479" class="Symbol">)</a>
<a id="44481" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44485" class="Symbol">(</a><a id="44486" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44491" class="Symbol">_</a> <a id="44493" href="/PLFA-zh/Properties/#44493" class="Bound">M—→M′</a><a id="44498" class="Symbol">)</a> <a id="44500" class="Symbol">(</a><a id="44501" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44505" href="/PLFA-zh/Properties/#44505" class="Bound">VM</a><a id="44507" class="Symbol">)</a>         <a id="44517" class="Symbol">=</a>  <a id="44520" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44527" class="Symbol">(</a><a id="44528" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44533" href="/PLFA-zh/Properties/#44505" class="Bound">VM</a> <a id="44536" href="/PLFA-zh/Properties/#44493" class="Bound">M—→M′</a><a id="44541" class="Symbol">)</a>
<a id="44543" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44547" class="Symbol">(</a><a id="44548" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44552" class="Symbol">_)</a>        <a id="44562" class="Symbol">(</a><a id="44563" href="/PLFA-zh/Lambda/#19273" class="InductiveConstructor">ξ-·₁</a> <a id="44568" href="/PLFA-zh/Properties/#44568" class="Bound">L—→L″</a><a id="44573" class="Symbol">)</a>     <a id="44579" class="Symbol">=</a>  <a id="44582" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44589" class="Symbol">(</a><a id="44590" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44595" href="/PLFA-zh/Lambda/#11601" class="InductiveConstructor">V-ƛ</a> <a id="44599" href="/PLFA-zh/Properties/#44568" class="Bound">L—→L″</a><a id="44604" class="Symbol">)</a>
<a id="44606" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44610" class="Symbol">(</a><a id="44611" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44615" href="/PLFA-zh/Properties/#44615" class="Bound">VM</a><a id="44617" class="Symbol">)</a>       <a id="44625" class="Symbol">(</a><a id="44626" href="/PLFA-zh/Lambda/#19354" class="InductiveConstructor">ξ-·₂</a> <a id="44631" class="Symbol">_</a> <a id="44633" href="/PLFA-zh/Properties/#44633" class="Bound">M—→M″</a><a id="44638" class="Symbol">)</a>   <a id="44642" class="Symbol">=</a>  <a id="44645" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44652" class="Symbol">(</a><a id="44653" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44658" href="/PLFA-zh/Properties/#44615" class="Bound">VM</a> <a id="44661" href="/PLFA-zh/Properties/#44633" class="Bound">M—→M″</a><a id="44666" class="Symbol">)</a>
<a id="44668" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44672" class="Symbol">(</a><a id="44673" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44677" class="Symbol">_)</a>        <a id="44687" class="Symbol">(</a><a id="44688" href="/PLFA-zh/Lambda/#19449" class="InductiveConstructor">β-ƛ</a> <a id="44692" class="Symbol">_)</a>          <a id="44704" class="Symbol">=</a>  <a id="44707" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="44712" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44716" class="Symbol">(</a><a id="44717" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="44723" href="/PLFA-zh/Properties/#44723" class="Bound">M—→M′</a><a id="44728" class="Symbol">)</a>  <a id="44731" class="Symbol">(</a><a id="44732" href="/PLFA-zh/Lambda/#19555" class="InductiveConstructor">ξ-suc</a> <a id="44738" href="/PLFA-zh/Properties/#44738" class="Bound">M—→M″</a><a id="44743" class="Symbol">)</a>    <a id="44748" class="Symbol">=</a>  <a id="44751" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="44756" href="/PLFA-zh/Lambda/#3969" class="InductiveConstructor Operator">`suc_</a> <a id="44762" class="Symbol">(</a><a id="44763" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44767" href="/PLFA-zh/Properties/#44723" class="Bound">M—→M′</a> <a id="44773" href="/PLFA-zh/Properties/#44738" class="Bound">M—→M″</a><a id="44778" class="Symbol">)</a>
<a id="44780" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44784" class="Symbol">(</a><a id="44785" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="44792" href="/PLFA-zh/Properties/#44792" class="Bound">L—→L′</a><a id="44797" class="Symbol">)</a> <a id="44799" class="Symbol">(</a><a id="44800" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="44807" href="/PLFA-zh/Properties/#44807" class="Bound">L—→L″</a><a id="44812" class="Symbol">)</a>   <a id="44816" class="Symbol">=</a>  <a id="44819" href="/PLFA-zh/Properties/#43800" class="Function">cong₄</a> <a id="44825" href="/PLFA-zh/Lambda/#4010" class="InductiveConstructor Operator">case_[zero⇒_|suc_⇒_]</a>
                                         <a id="44887" class="Symbol">(</a><a id="44888" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44892" href="/PLFA-zh/Properties/#44792" class="Bound">L—→L′</a> <a id="44898" href="/PLFA-zh/Properties/#44807" class="Bound">L—→L″</a><a id="44903" class="Symbol">)</a> <a id="44905" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="44910" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="44915" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="44920" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44924" class="Symbol">(</a><a id="44925" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="44932" href="/PLFA-zh/Properties/#44932" class="Bound">L—→L′</a><a id="44937" class="Symbol">)</a> <a id="44939" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>           <a id="44956" class="Symbol">=</a>  <a id="44959" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="44966" class="Symbol">(</a><a id="44967" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="44972" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a> <a id="44979" href="/PLFA-zh/Properties/#44932" class="Bound">L—→L′</a><a id="44984" class="Symbol">)</a>
<a id="44986" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="44990" class="Symbol">(</a><a id="44991" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="44998" href="/PLFA-zh/Properties/#44998" class="Bound">L—→L′</a><a id="45003" class="Symbol">)</a> <a id="45005" class="Symbol">(</a><a id="45006" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="45012" href="/PLFA-zh/Properties/#45012" class="Bound">VL</a><a id="45014" class="Symbol">)</a>       <a id="45022" class="Symbol">=</a>  <a id="45025" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="45032" class="Symbol">(</a><a id="45033" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="45038" class="Symbol">(</a><a id="45039" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="45045" href="/PLFA-zh/Properties/#45012" class="Bound">VL</a><a id="45047" class="Symbol">)</a> <a id="45049" href="/PLFA-zh/Properties/#44998" class="Bound">L—→L′</a><a id="45054" class="Symbol">)</a>
<a id="45056" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="45060" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>         <a id="45075" class="Symbol">(</a><a id="45076" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="45083" href="/PLFA-zh/Properties/#45083" class="Bound">M—→M″</a><a id="45088" class="Symbol">)</a>   <a id="45092" class="Symbol">=</a>  <a id="45095" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="45102" class="Symbol">(</a><a id="45103" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="45108" href="/PLFA-zh/Lambda/#11662" class="InductiveConstructor">V-zero</a> <a id="45115" href="/PLFA-zh/Properties/#45083" class="Bound">M—→M″</a><a id="45120" class="Symbol">)</a>
<a id="45122" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="45126" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>         <a id="45141" href="/PLFA-zh/Lambda/#19819" class="InductiveConstructor">β-zero</a>           <a id="45158" class="Symbol">=</a>  <a id="45161" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="45166" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="45170" class="Symbol">(</a><a id="45171" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="45177" href="/PLFA-zh/Properties/#45177" class="Bound">VL</a><a id="45179" class="Symbol">)</a>     <a id="45185" class="Symbol">(</a><a id="45186" href="/PLFA-zh/Lambda/#19638" class="InductiveConstructor">ξ-case</a> <a id="45193" href="/PLFA-zh/Properties/#45193" class="Bound">L—→L″</a><a id="45198" class="Symbol">)</a>   <a id="45202" class="Symbol">=</a>  <a id="45205" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="45212" class="Symbol">(</a><a id="45213" href="/PLFA-zh/Properties/#3582" class="Function">V¬—→</a> <a id="45218" class="Symbol">(</a><a id="45219" href="/PLFA-zh/Lambda/#11710" class="InductiveConstructor">V-suc</a> <a id="45225" href="/PLFA-zh/Properties/#45177" class="Bound">VL</a><a id="45227" class="Symbol">)</a> <a id="45229" href="/PLFA-zh/Properties/#45193" class="Bound">L—→L″</a><a id="45234" class="Symbol">)</a>
<a id="45236" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="45240" class="Symbol">(</a><a id="45241" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="45247" class="Symbol">_)</a>      <a id="45255" class="Symbol">(</a><a id="45256" href="/PLFA-zh/Lambda/#19932" class="InductiveConstructor">β-suc</a> <a id="45262" class="Symbol">_)</a>        <a id="45272" class="Symbol">=</a>  <a id="45275" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="45280" href="/PLFA-zh/Properties/#44079" class="Function">det</a> <a id="45284" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a>            <a id="45299" href="/PLFA-zh/Lambda/#20083" class="InductiveConstructor">β-μ</a>              <a id="45316" class="Symbol">=</a>  <a id="45319" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The proof is by induction over possible reductions.  We consider
three typical cases:</p>

<ul>
  <li>
    <p>Two instances of <code class="highlighter-rouge">ξ-·₁</code>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L —→ L′                 L —→ L″
--------------- ξ-·₁    --------------- ξ-·₁
L · M —→ L′ · M         L · M —→ L″ · M
</code></pre></div>    </div>

    <p>By induction we have <code class="highlighter-rouge">L′ ≡ L″</code>, and hence by congruence
<code class="highlighter-rouge">L′ · M ≡ L″ · M</code>.</p>
  </li>
  <li>
    <p>An instance of <code class="highlighter-rouge">ξ-·₁</code> and an instance of <code class="highlighter-rouge">ξ-·₂</code>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        Value L
L —→ L′                 M —→ M″
--------------- ξ-·₁    --------------- ξ-·₂
L · M —→ L′ · M         L · M —→ L · M″
</code></pre></div>    </div>

    <p>The rule on the left requires <code class="highlighter-rouge">L</code> to reduce, but the rule on the right
requires <code class="highlighter-rouge">L</code> to be a value.  This is a contradiction since values do
not reduce.  If the value constraint was removed from <code class="highlighter-rouge">ξ-·₂</code>, or from
one of the other reduction rules, then determinism would no longer hold.</p>
  </li>
  <li>
    <p>Two instances of <code class="highlighter-rouge">β-ƛ</code>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value V                              Value V                         
----------------------------- β-ƛ    ----------------------------- β-ƛ
(ƛ x ⇒ N) · V —→ N [ x := V ]        (ƛ x ⇒ N) · V —→ N [ x := V ]
</code></pre></div>    </div>

    <p>Since the left-hand sides are identical, the right-hand sides are
also identical. The formal proof simply invokes <code class="highlighter-rouge">refl</code>.</p>
  </li>
</ul>

<p>Five of the 18 lines in the above proof are redundant, e.g., the case
when one rule is <code class="highlighter-rouge">ξ-·₁</code> and the other is <code class="highlighter-rouge">ξ-·₂</code> is considered twice,
once with <code class="highlighter-rouge">ξ-·₁</code> first and <code class="highlighter-rouge">ξ-·₂</code> second, and the other time with the
two swapped.  What we might like to do is delete the redundant lines
and add</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>det M—→M′ M—→M″ = sym (det M—→M″ M—→M′)
</code></pre></div></div>

<p>to the bottom of the proof. But this does not work: the termination
checker complains, because the arguments have merely switched order
and neither is smaller.</p>

<h4 id="quiz">Quiz</h4>

<p>Suppose we add a new term <code class="highlighter-rouge">zap</code> with the following reduction rule</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-------- β-zap
M —→ zap
</code></pre></div></div>

<p>and the following typing rule:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------- ⊢zap
Γ ⊢ zap ⦂ A
</code></pre></div></div>

<p>Which of the following properties remain true in
the presence of these rules?  For each property, write either
“remains true” or “becomes false.” If a property becomes
false, give a counterexample:</p>

<ul>
  <li>
    <p>Determinism of <code class="highlighter-rouge">step</code></p>
  </li>
  <li>
    <p>Progress</p>
  </li>
  <li>
    <p>Preservation</p>
  </li>
</ul>

<h4 id="quiz-1">Quiz</h4>

<p>Suppose instead that we add a new term <code class="highlighter-rouge">foo</code> with the following
reduction rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------------------ β-foo₁
(λ x ⇒ ` x) —→ foo

----------- β-foo₂
foo —→ zero
</code></pre></div></div>

<p>Which of the following properties remain true in
the presence of this rule?  For each one, write either
“remains true” or else “becomes false.” If a property becomes
false, give a counterexample:</p>

<ul>
  <li>
    <p>Determinism of <code class="highlighter-rouge">step</code></p>
  </li>
  <li>
    <p>Progress</p>
  </li>
  <li>
    <p>Preservation</p>
  </li>
</ul>

<h4 id="quiz-2">Quiz</h4>

<p>Suppose instead that we remove the rule <code class="highlighter-rouge">ξ·₁</code> from the step
relation. Which of the following properties remain
true in the absence of this rule?  For each one, write either
“remains true” or else “becomes false.” If a property becomes
false, give a counterexample:</p>

<ul>
  <li>
    <p>Determinism of <code class="highlighter-rouge">step</code></p>
  </li>
  <li>
    <p>Progress</p>
  </li>
  <li>
    <p>Preservation</p>
  </li>
</ul>

<h4 id="quiz-3">Quiz</h4>

<p>We can enumerate all the computable function from naturals to
naturals, by writing out all programs of type <code class="highlighter-rouge">`ℕ ⇒ `ℕ</code> in
lexical order.  Write <code class="highlighter-rouge">fᵢ</code> for the <code class="highlighter-rouge">i</code>‘th function in this list.</p>

<p>Say we add a typing rule that applies the above enumeration
to interpret a natural as a function from naturals to naturals:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ L ⦂ `ℕ
Γ ⊢ M ⦂ `ℕ
-------------- _·ℕ_
Γ ⊢ L · M ⦂ `ℕ
</code></pre></div></div>

<p>And that we add the corresponding reduction rule:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fᵢ(m) —→ n
---------- δ
i · m —→ n
</code></pre></div></div>

<p>Which of the following properties remain true in
the presence of this rule?  For each one, write either
“remains true” or else “becomes false.” If a property becomes
false, give a counterexample:</p>

<ul>
  <li>
    <p>Determinism of <code class="highlighter-rouge">step</code></p>
  </li>
  <li>
    <p>Progress</p>
  </li>
  <li>
    <p>Preservation</p>
  </li>
</ul>

<p>Are all properties preserved in this case? Are there any
other alterations we would wish to make to the system?</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ƛ  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
Δ  U+0394  GREEK CAPITAL LETTER DELTA (\GD or \Delta)
β  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
δ  U+03B4  GREEK SMALL LETTER DELTA (\Gd or \delta)
μ  U+03BC  GREEK SMALL LETTER MU (\Gm or \mu)
ξ  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
ρ  U+03B4  GREEK SMALL LETTER RHO (\Gr or \rho)
ᵢ  U+1D62  LATIN SUBSCRIPT SMALL LETTER I (\_i)
ᶜ  U+1D9C  MODIFIER LETTER SMALL C (\^c)
–  U+2013  EM DASH (\em)
₄  U+2084  SUBSCRIPT FOUR (\_4)
↠  U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
⇒  U+21D2  RIGHTWARDS DOUBLE ARROW (\=&gt;)
∅  U+2205  EMPTY SET (\0)
∋  U+220B  CONTAINS AS MEMBER (\ni)
≟  U+225F  QUESTIONED EQUAL TO (\?=)
⊢  U+22A2  RIGHT TACK (\vdash or \|-)
⦂  U+2982  Z NOTATION TYPE COLON (\:)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Lambda/">前一章</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/roger-uw/PLFA-zh/blob/dev/src/plfa/Properties.lagda">源代码</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/PLFA-zh/DeBruijn/">后一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。<br />
    This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
